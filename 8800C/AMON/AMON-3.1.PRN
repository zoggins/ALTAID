

                ;==============================================================
                ; AMON
                ;
                ; ROM-based monitor for an 8080 based system, supporting the
                ; 88-2SIOJP and the Altair 88-2SIO, this version modified to
                ; support the CompuPro Interfacer 1 Channel B as transfer port
                ; option 7.
                ;
                ; Formatted to assemble with digital Research's ASM.
                ;
                ;==============================================================
                ; Entry Points:
                ; F800h: Cold-start AMON, enter command loop
                ; FC00h: Boot from MITS 88-HDSK Altair Hard Disk
                ;        (equivalent to my HDBL)
                ; FE00h: Boot from Altair paper or cassette tape
                ;        (equivalent to MITS's MBL)
                ; FF00h: Boot from MITS 88-DCDD 8" floppy or 88-MDS minidisk
                ;        (equivalent to my CDBL, and MITS's DBL and MDBL)
                ;==============================================================
                ;
                ; AMON assumes the console is on port 0 of the 88-2SIO/JP,
                ; and that the console terminal may optionally be a printing
                ; terminal (e.g. a Teletype) that has no backspace capability.
                ;
                ; AMON defines a "transfer port" for uploads, downloads, and
                ; terminal mode. This can be set to any of the standard Altair
                ; ports. You can also set up a custom port prior to assembly,
                ; which will be port 7 in the TP command. (If your custom port
                ; requires initialization, then you must add code for this.)
                ; This version of AMON has the custom port set up for the
                ; CompuPro Interfacer 1, Channel B.
                ;
                ; Commands: (All values are in hex). The "?" and "MT" commands
                ; are only available with a 2732 EPROM (EPROM32 = TRUE)
                ;
                ; ?   Print help screen {EPROM32 only}
                ;
                ; AD <ADR> <BCNT> [<GO>]
                ;     Write <BCNT> bytes of memory starting at <ADR> in Altair
                ;     Absolute Binary format, to the current Transfer Port.
                ;     Optional GO record appended if <GO> provided.
                ;
                ; AL  [<0/1/2>]
                ;    Load and execute an Altair Absolute Binary file from the
                ;    current Transfer Port. (This is MBL.) If the optional
                ;    parameter is 0 then the GO record in the file will be
                ;    ignored, and control returns to the monitor, after
                ;    printing the GO address on the console. If the parameter
                ;    is 2 then an IN from port FF is executed (to disable this
                ;    PROM) before loading AND the GO record is executed.
                ;    Parameter defaultsto 1 (meaning a Go record is executed).
                ;    The "disable PROM" option is only available if EPROM32.
                ;
                ; BO  Boot from Altair floppy disk. (This is CDBL.)
                ;
                ; CO <SRC> <DST> <BCNT> [<RPT>]
                ;    Copy <BCNT> bytes of memory from address <SRC> to address
                ;    <DST>. optionally repeat <RPT> times (For programming
                ;    EPROMS with e.g. a Cromemco Bytesaver).
                ;
                ; DU [<ADR> [<BCNT>]]
                ;    Dump <BCNT> (which defaults to 1) bytes of memory starting
                ;    at address <ADR> (which defaults to 0).
                ;
                ; EN [<ADR>]
                ;    Enter hex data into memory at <ADR>, which defaults to 0.
                ;    values are separated with spaces or CR'S. Quit EN command
                ;    with a blank line.
                ;
                ; EX [<ADR> [<OPT>]]
                ;    Execute at <ADR>, which defaults to 0. Programs can ret
                ;    to AMON's MAIN loop. If <OPT>=1 then an IN from port
                ;    FF is executed first, to disable this PROM.
                ;
                ; FI [<VAL> [<ADR> [<BCNT>]]]
                ;    Fill <BCNT> bytes of memory starting at <ADR> with <VAL>
                ;    <VAL> and <ADR> default to 0. <BCNT> defaults to all of
                ;    memory, stopping (after wrap-around if necessary) when
                ;    the fill reaches AMON's RAM page.
                ;
                ; HB [<PLTR>] Boot from hard disk platter <PLTR> (0 or 1)
                ;    <PLTR> argument only supported if EPROM32
                ;
                ; HD <ADR> <BCNT> [<OFST>]
                ;    Intel hex dump <BCNT> bytes of memory starting at <ADR>,
                ;    to the Transfer Port. Add <OFST> to each address.
                ;
                ; HL [<OFST>]
                ;    Load Intel hex file to memory from the Transfer Port. Add
                ;    optional address offset <OFST> to each record address.
                ;    Prints a pacifier dot on the console for each record.
                ;
                ; IN <PORT>
                ;    Read from <PORT> and print the result on the console
                ;
                ; MT <ADR> <BCNT> {EPROM32 only}
                ;    Test <BCNT> bytes of memory, starting at <ADR>. This will
                ;    skip over the portion of RAM used by AMON.
                ;
                ; OT <PORT> <VAL>
                ;    Write the specified value to the specified output port
                ;
                ; SE <ADR> <BYTE1> [<BYTE2> [<BYTE3> [..<BYTEn>]]]
                ;     or
                ; SE <ADR> 'text string'
                ;    Search for string of bytes in memory, starting at <ADR>
                ;    can also mix forms, e.g.
                ; SE 100 'hello world' 0D 0A 'second line'
                ;
                ; TE [<EXCHR>]
                ;    Terminal Mode: console keyboard data goes to the Transfer
                ;    port, and Transfer Port data goes to the console.
                ;    ^C to exit, unless you specified a different exit chr.
                ;
                ; TP [<port>]
                ;    Set the Transfer Port:
                ;        port   device
                ;         0    88-2SIO port 0, 2 stop bits
                ;         1    88-2SIO port 0, 2 stop bits
                ;         2    88-SIO
                ;         3    88-ACR
                ;         4    88-4PIO port 0
                ;         5    88-PIO
                ;         6    88-2SIO port 1, 2 stop bits
                ;         7    CompuPro Interfacer 1 Channel B
                ;
                ; TT [0/1]
                ;    TT 1 specifies a Teletype (or other non-backspacing
                ;    device) as the console. TT or TT 0 specifies a device
                ;    (such as a terminal) that can backspace. This controls how
                ;    a backspace is displayed.
                ;
                ; VE <SRC> <DST> <BCNT>
                ;    Verify (compare) <BCNT> bytes of memory, starting at <SRC>
                ;    and <DST>
                ;
                ;==============================================================
                ; RAM USAGE
                ;
                ; Amon finds and uses the highest contiguous 256-byte page of
                ; RAM for its stack, buffers, and code that gets modified (such
                ; as the serial I/O routines).
                ;
                ; When MBL is executed directly (not via a call from AMON), it
                ; reads the switch register to determine the boot port. Note
                ; that the 88-2SIOJP may be configured to disable the PROM once
                ; an "IN 0FFh" (input from the front panel switch register) is
                ; executed. 
                ;
                ; The sector buffer is positioned within the RAM page such that
                ; its last byte is the last byte of the RAM page. This makes
                ; the timing work in the critical byte-read loop, when booting
                ; from an 8" floppy diskette.
                ;
                ; The available space for the stack depends on the command. For
                ; most commands, the stack grows down from the console input
                ; buffer at xxB0, with room for 18 pushes. However, for the BO
                ; and AL commands, as well as for entry at MBL or CDBL, the
                ; stack grows down from the sector buffer at xx7B, with room 
                ; for only 8 pushes.
                ;
                ; RAM Page Organization:
                ;
                ; xx00: Transfer Port I/O routines
                ;       RSETP: set the Transfer Port according to register a
                ;              (see TP command below.)
                ;       RTPIS: get Transfer Port input status. Z clear if
                ;              data is available.
                ;       RTPIN: wait for and get one chr from the Transfer Port
                ;       RTIIF: read immediately from the Transfer Port (flush)
                ;       RTPOUT: write a to the Transfer Port
                ; xx49-xx68: PTABLE, which may be wiped out by the stack
                ;
                ; xx69-xx7A: DSTACK (room for 8 pushes)
                ; xx7B-xxFF: Sector buffer (for BO command) (DSKBUF)
                ; xx7B-xxFF: MBL RAM code for AL command, especially for direct
                ;            execution from FE00
                ;
                ; xx69-xxAF: STACK (room for 18 pushes)
                ; xxB0-xxFF: Console input buffer (LINBUF)
                ;==============================================================
                ;--------------------------
                ;This code'S version number
                ;--------------------------
 0031 =         VERSION	equ	31h	;high nibble = major revision number
                			;low nibble minor version
                ;--------------------------------------------------------------
                ; REVISION HISTORY
                ; Vers. 3.1 M. Eberhard  10 February 2024
                ;   Fix bug in GETTPD (that was introduced in version 2.8),
                ;   which had caused AL to fail when the console was also the
                ;   transfer port. Tidy up few comments. Define console port
                ;   better.
                ; Vers. 3.0 D. Hansel 12 February 2023
                ;   Fix MBL direct entry at FE00
                ;   Add option to disable PROM before load in AL commmand
                ; Vers. 2.9 D. Hansel 29 January 2023
                ;   Fix hard disk boot loader
                ;   Fix hex dump command end condition and user interrupt
                ; Vers. 2.8 M. Eberhard 27 March 2022
                ;   say 'OK' if verify succeeds or memory test passes.
                ;   More thorough transfer port flush on AL command if EPROM32.
                ; Vers. 2.7 M. Eberhard 24 March 2022
                ;   Fix MT bug when tested memory overlaps the RAM page. Fix
                ;   stack bug: larger stack for commands that use a lot of
                ;   stack. Print 'Memory OK' if MT passes. Slightly improve
                ;   help screens. Allow ESC to abort commands too.
                ; Vers. 2.6 M. Eberhard 26 November 2020
                ;   No pacifiers during HD and HL if Transfer Port=Console
                ;   Supports CompuPro Interfacer 1 Channel B
                ; vers. 2.5 M. Eberhard 11 June 2020
                ;   Use 2732 EPROM to add MT and ? commands
                ; Vers. 2.4 M. Eberhard 13 October 2016
                ;   Unify error messages, add GO record to AD command, add
                ;   option to ignore GO record on AL command, verify memory
                ;   write on HL command, improve labels
                ; Vers. 2.3 M. Eberhard  10 October 2016
                ;   Squeeze code, improve error reporting, improve comments
                ; Vers. 2.2  M. Eberhard 4 October 2016
                ;   Squeeze code a bit, add IN and OT commands
                ; Vers. 2.1  M. Eberhard  27 August 2016
                ;   Fix bug when executing at F800
                ; Vers. 2.0  M. Eberhard  26 July 2016
                ;   First released version
                ; Vers. 1.00-1.06
                ;   Development
                ;==============================================================
 0000 =         FALSE	equ	0
 FFFF =         TRUE	equ	not FALSE
                
                ;======================================
                ; EPROM size option
                ; Set EPROM32 to TRUE for 2732 EPROM
                ; (Otherwise, code will fit in a 2716.)
                ;======================================
                
 FFFF =         EPROM32 equ	TRUE
                
                ;*****
                ;ASCII
                ;*****
 0003 =         CTRLC	equ	03H		;control-C
 0008 =         BS	equ	08H		;backspace
 000D =         CR	equ	0DH
 000A =         LF	equ	0AH
 001B =         ESC	equ	1Bh		;Escape
 0027 =         QUOTE	equ	27h		;single-quote
 007F =         DEL	equ	7Fh		;delete
                
                ;---------------
                ;program Equates
                ;---------------
 003E =         PROMPT	equ	'>'	;Prompt character
 0003 =         CABKEY	equ	CTRLC	;command abort character
 001B =         CBKEY2	equ	ESC	;2nd cmd abort chr (EPROM32 only)
 0003 =         DTEXIT	equ	CTRLC	;default Terminal Mode exit CHR
 0020 =         PAUKEY	equ	' '	;pauses dumping
 002E =         PCFIER	equ	'.'	;console pacifier character
                
 0050 =         LBSIZE	equ	80	;input line buffer size
 0010 =         HRLEN	equ	16	;Intel hex record length for HD
                
 0006 =         DTPORT	equ	6	;default transfer port
                
                ;-------------------------------
                ;Single-Character Error Messages
                ;-------------------------------
 0043 =         CERMSG	equ	'C'	;checksum/marker byte error
 0048 =         HERMSG	equ	'H'	;Illegal hex digit
 004D =         MERMSG	equ	'M'	;memory write verify error
 004F =         OERMSG	equ	'O'	;memory overlay error
                
                ;-----------------------------------
                ;Altair Absolute Binary file Equates
                ;-----------------------------------
 003C =         ALTPLR	equ	3CH	;Program load record
 0078 =         ALTGOR	equ	78H	;EOF/GO address record
 0055 =         ALTBNR	equ	55H	;begin/program name (not supported)
 000D =         ALTBND	equ	0DH	;end-of-name mark (not supported)
 003C =         ALTLDR	equ	60	;Leader/trailer length
                
                ;--------------------
                ;Sense Switch Equates
                ;--------------------
 00FF =         SSWTCH	equ	0FFh	;front panel switch register
 0007 =         LDMASK	equ	007H	;load device mask
                
                ;--------------
                ;88-SIO Equates
                ;--------------
                ;88-SIO registers	
                
 0000 =         SIOCTL	equ	00		;control port
 0000 =         SIOSTA	equ	00		;status
 0001 =         SIOTXD	equ	01		;transmit data
 0001 =         SIORXD	equ	01		;receive data
                
                ;Status register bits
                
 0001 =         SIOIDR	equ	00000001B	;input dev rdy (RX BUF full)
 0004 =         SIOPE	equ	00000100B	;parity error
 0008 =         SIOFE	equ	00001000B	;framing error
 0010 =         SIODOV	equ	00010000B	;data overflow
 0080 =         SIOODR	equ	10000000B	;output dev rdy (TX BUF empty)
                
                ;--------------------------------------------------------
                ;88-ACR (Audio Cassette recorder) Equates
                ;NOTE: the Altair 88-ACR is built around an Altair 88-SIO
                ;--------------------------------------------------------
                ;88-ACR registers	
                
 0006 =         ACRCTL	equ	06		;control port
 0006 =         ACRSTA	equ	06		;status
 0007 =         ACRTXD	equ	07		;transmit data
 0007 =         ACRRXD	equ	07		;receive data
                
                ;Status register bits
                
 0001 =         ACRIDR	equ	00000001B	;input dev rdy (RX BUF full)
 0004 =         ACRPE	equ	00000100B	;parity error
 0008 =         ACRFE	equ	00001000B	;framing error
 0010 =         ACRDOV	equ	00010000B	;data overflow
 0080 =         ACRODR	equ	10000000B	;output dev rdy (TX BUF empty)
                
                ;---------------
                ;88-2SIO Equates
                ;---------------
                ; 88-2SIO registers
                
 0010 =         SIOBAS	equ	10h
 0010 =         S2CTLA	EQU	SIOBAS		;ACIA A control output port
 0010 =         S2STAA	EQU	SIOBAS		;ACIA A status input port
 0011 =         S2TXDA	EQU	SIOBAS+1	;ACIA A Tx data register
 0011 =         S2RXDA	EQU	SIOBAS+1	;ACIA A Rx data register
 0012 =         S2CTLB	EQU	SIOBAS+2	;ACIA B control output port
 0012 =         S2STAB	EQU	SIOBAS+2	;ACIA B status input port
 0013 =         S2TXDB	EQU	SIOBAS+3	;ACIA B Tx data register
 0013 =         S2RXDB	EQU	SIOBAS+3	;ACIA B Rx data register
                
                ;MOTOROLA 6850 ACIA ctrl/stat values
                
 0001 =         S2RDF	EQU	00000001B	;Rx data register full
 0002 =         S2TBE	equ	00000010B	;Tx data register empty
                
 0003 =         S2RST	equ	00000011B	;Master reset
 0011 =         S22STP	equ	00010001B	;2 stop bits, /16
 0015 =         S21STP	equ	00010101B	;1 stop bit, /16
                
                ;--------------
                ;88-PIO Equates
                ;--------------
                ;88-PIO registers	
                
 0004 =         PIOCTL	equ	04		;control port
 0004 =         PIOSTA	equ	04		;status
 0005 =         PIOTXD	equ	05		;transmit data
 0005 =         PIORXD	equ	05		;receive data
                
                ;Status register bits
                
 0002 =         PIORDF	equ	00000010B	;RX data register full
 0001 =         PIOTDE	equ	00000001B	;TX data register empty
                
                ;-------------------------------------------
                ;88-4PIO Equates
                ;NOTE: the 88-HSR uses port 1 of the 88-4PIO
                ;-------------------------------------------
                ;88-4PIO registers	
                
 0020 =         P4CA0	equ	20h		;port 0 section A ctrl/stat
 0021 =         P4DA0	equ	21H		;port 0 section A data
 0022 =         P4CB0	equ	22H		;port 0 section B ctrl/stat
 0023 =         P4DB0	equ	23H		;port 0 section B data
 0024 =         P4CA1	equ	24H		;port 1 section A ctrl/stat
 0025 =         P4DA1	equ	25H		;port 1 section A data
 0026 =         P4CB1	equ	26H		;port 1 section B ctrl/stat
 0027 =         P4DB1	equ	27H		;port 1 section B data
                
                ;Status register bits
                
 0080 =         P4RDF	equ	10000000B	;RX data register full
 0080 =         P4TDE	equ	10000000B	;TX data register empty
 0040 =         HSRRDF	equ	01000000B	;RX data register full for HSR
                
                ;Control register bits
                
 0001 =         P4C1C0	equ	00000001B	;C1 control bit 0
 0002 =         P4C1C1	equ	00000010B	;C1 control bit 1
 0004 =         P4DDR	equ	00000100B	;data direction register
 0008 =         P4C2C3	equ	00001000B	;C2 control bit 3
 0010 =         P4C2C4	equ	00010000B	;C2 control bit 4
 0020 =         P4C2C5	equ	00100000B	;C2 control bit 5
 0040 =         P4IC2	equ	01000000B	;C2 interrupt control bit
 0080 =         P4IC1	equ	10000000B	;C1 interrupt control bit
                
                ;4PIO Initialization
                
 002C =         P4INIT	equ	P4C2C5+P4C2C3+P4DDR	;2Ch
                			;bits 0,1: C1 input active low, int off
                			;bit 2: access data reg
                			;bits 3-5: C2 output handshake
                
                ;-----------------------------------------------
                ;CompuPro Interfacer 1 Channel B Equates
                ;(Change these values for a custom transfer port
                ;The custom port's data port address must be
                ;immediately after its ctrl/stat port.) 
                ;-----------------------------------------------
 0002 =         CPRCTL	equ	02h		;Rx ctrl/stat port
 0003 =         CPRDAT	equ	CPRCTL+1	;Rx data must be CPRCTL+1
 0002 =         CPRRDY	equ	02h		;Receiver ready (Data Available)
                
 0002 =         CPTCTL	equ	02h		;Tx ctrl/stat port
 0003 =         CPTDAT	equ	CPTCTL+1	;Tx data must be CPTCTL+1
 0001 =         CPTRDY	equ	01h		;transmitter ready (Buffer Empty)
                
 0000 =         CPSPOL	equ	0		;0 for active-high flags
                				;1 for active-low flags
                
 0008 =         CICTS	equ	08h		;CompuPro Interfacer CTS bit
                
                ;-----------------------------------------------------------
                ;Altair 8800 Floppy Disk Controller Equates (These are the
                ;same for the 88-DCDD controller and the 88-MDS controller.)
                ;-----------------------------------------------------------
 0008 =         DENABL	equ	08H		;Drive enable output
 0080 =         DDISBL	  equ	  80h		  ;disable disk controller
                
 0008 =         DSTAT	equ	08H		;status input (active low)
 0001 =         ENWDAT	  equ	  01h		  ;-enter write data
 0002 =         MVHEAD	  equ	  02h		  ;-Move Head OK
 0004 =         HDSTAT	  equ	  04h		  ;-Head status
 0008 =         DRVRDY	  equ	  08h		  ;-Drive Ready
 0020 =         INTSTA	  equ	  20h		  ;-interrupts enabled
 0040 =         TRACK0	  equ	  40h		  ;-Track 0 detected
 0080 =         NRDA	  equ	  80h		  ;-new Read data Available
                
 0009 =         DCTRL	equ	09h		  ;Drive control output
 0001 =         STEPIN	  equ	  01H		  ;Step-In
 0002 =         STEPOT	  equ	  02H		  ;Step-Out
 0004 =         HEDLOD	  equ	  04H		  ;8" disk: load head
                				  ;Minidisk: restart 6.4 S timer
 0008 =         HDUNLD	  equ	  08h		  ;unload head (8" only)
 0010 =         IENABL	  equ	  10h		  ;enable sector interrupt
 0020 =         IDSABL	  equ	  20h		  ;Disable interrupts
 0080 =         WENABL	  equ	  80h		  ;enable drive write circuits
                
 0009 =         DSECTR	equ	09h		;Sector position input
 0001 =         SVALID	  equ	  01h		  ;Sector valid (1st 30 uS
                				  ;..of sector pulse)
 003E =         SECMSK	  equ	  3Eh		  ;Sector mask for MDSEC
                
 000A =         DDATA	equ	0Ah		;Disk data (input/output)
                
                ;Floppy Disk Parameters
                
 0080 =         BPS	equ	128		;data bytes/sector
 0010 =         MDSPT	equ	16		;Minidisk sectors/track
                				;this code assumes SPT for 8"
                				;disks = MDSPT * 2.
                
 0003 =         HDRSIZ	equ	3		;header bytes before data
 0002 =         TLRSIZ	equ	2		;trailer bytes read after data
                
 0085 =         SECSIZ	equ	BPS+HDRSIZ+TLRSIZ ;total bytes/sector
                
 0010 =         RETRYS	equ	16		;max retries per sector
                
                ;------------------------------------
                ;88-HDSK Datakeeper Hard Disk Equates
                ;------------------------------------
                ;88-HDSK ports (The interface board is actually an 88-4PIO.)
                
 00A0 =         CREADY	equ	0A0h	;IN: Ctlr ready for command (bit7)
 00A1 =         CSTAT	equ	0A1h	;IN: error flags, reset CREADY
 00A2 =         ACSTA	equ	0A2h	;IN: Command Ack (bit 7)
 00A3 =         ACMD	equ	0A3h	;IN: reset Command Ack
                			;OUT: Command high byte/initiate
 00A4 =         CDSTA	equ	0A4h	;IN: data/stat available at CDATA
 00A5 =         CDATA	equ	0A5h	;IN: Disk data or status from Ctlr
 00A6 =         ADSTA	equ	0A6h	;IN: ADATA Port Available (bit 7)
 00A7 =         ADATA	equ	0A7h	;OUT: Command low byte
                
                ;88-HDSK ACMD:ADATA Commands
                
 0024 =         BINIT	equ	24h	;bits 0,1: C1 input active low, int off
                			;bit 2: access data reg
                			;bits 3-5: C2 input handshake
                
                
 002C =         CINIT	equ	2Ch	;bits 0,1: C1 input active low, int off
                			;bit 2: access data reg
                			;bits 3-5: C2 output handshake
                
 0000 =         CSEEK	equ	00h	;Bits 15:12 = 0000b
                			;Bits 11:10 = Unit #
                			;Bits  9:0  = Cylinder #
                
 0030 =         CRDSEC	equ	30h	;Bits 15:12 = 0011b
                			;Bits 11:10 = Unit #
                			;Bits  9:8  = Buffer #
                			;Bit   7:6  = Platter #
                			;Bits    5  = Side #
                			;Bits  4:0  = Sector #
                
 0020 =         CSIDE	 equ	  020h	  ;Side select for CRDSEC
 00C0 =         CFPLTR	 equ	  0C0h	  ;platter mask for CRDSEC
 000C =         CUNIT	 equ	  00Ch	  ;Unit mask for CSEEK & CRDSEC
                
 0050 =         CRDBUF	equ	50h	;Bits 15:12 = 0101b
                			;Bits 11:10 = not used
                			;Bits  9:8  = buffer #
                			;Bits  7:0  = # bytes to transfer
                			;(00 means 256)
                
                ;88-HDSK CSTAT error bits
                
 0001 =         ERDNR	equ	01h	;drive not ready
 0002 =         ERBADS	equ	02h	;illegal sector
 0004 =         ERSCRC	equ	04h	;CRC error during sector read
 0008 =         ERHCRC	equ	08h	;CRC error during header read
 0010 =         ERSWRG	equ	10h	;header has wrong sector
 0020 =         ERCWRG	equ	20h	;header has wrong cylinder
 0040 =         ERHWRG	equ	40h	;header has wrong head
 0080 =         WPROT	equ	80h	;Write Protect
 007F =         ERMASK	equ	7Fh	;all the actual error bits
                
                ;88-HDSK Constants
                
 0028 =         OSOFF	equ	40	;Page 0 offset to opsys pointers
 0018 =         HDSPT	equ	24	;Sectors per track
 0000 =         DBUFR	equ	0	;Default controller buffer: 0-3
                			;Code gets longer if <>0
                
                ;**************************
                ;Define the Console Port
                ;(Normal is 88-2SIO port A)
                ;**************************
 0010 =         CONSTA	equ	S2STAA
 0011 =         CONTXD	equ	S2TXDA
 0011 =         CONRXD	equ	S2RXDA
 0001 =         CONRDF	equ	S2RDF
 0002 =         CONTBE	equ	S2TBE
 0000 =         CONTPO	equ	NOP		;active-high Tx status bit
 0000 =         CONRPO	equ	NOP		;active-high Rx status bit
                
                ;***********************
                ;EPROM Memory Allocation
                ;***********************
 0000 =         DMAADR	equ	00000h		;Disk load/execution address
                				;(Code assumes DMAADR=0)
 F800 =         MONADR	equ	0F800h		;Address of monitor
 FC00 =         HDBADR	equ	0FC00h		;Beginning of HDBL PROM
 FE00 =         MBLADR	equ	0FE00h		;MBL Subsystem address
 FF00 =         DBLADR	equ	0FF00h		;CDBL Subsystem address
                
                 if EPROM32
 F000 =         MON32A	equ	0F000h		;base of 2732 monitor extension
                 endif	;EPROM32
                 if not EPROM32
                MON32A	equ	0
                 endif ;not EPROM32
                
                ;************************************************
                ;Address Offsets of components in AMON's RAM page
                ;************************************************
 0000 =         RAMCOD	equ	0		;Relocated code at bottom
 007B =         DSKBUF	equ	100h-SECSIZ	;Exactly room for 1 complete sector
 007B =         DSTACK	equ	DSKBUF		;Disk cmd Stack down from here
                
 00B0 =         LINBUF	equ	100h-LBSIZE	;Input line buffer
 00B0 =         STACK	equ	LINBUF		;Normal cmd stack down from here
 0010 =         MINSTK	equ	10h		;minimum stack size
                
                ;Floppy disk sector buffer component offsets
                
 007C =         SFSIZE	equ	DSKBUF+1	;file size
 007E =         SDATA	equ	DSKBUF+HDRSIZ	;sector data
 00FE =         SMARKR	equ	SDATA+BPS	;marker byte
 00FF =         SCKSUM	equ	SMARKR+1	;checksum byte
                
                ;=====================================================
                ;Help the EPROM programmer auto-detect the memory page
                ;=====================================================
                 if EPROM32
 F000           	org MON32A		;base of 2732 monitor extension
 F000 00        	db 0
                 endif	;EPROM32
                
                ;=============================
                ;= Cold-start Initialization =
                ;=============================
 F800           	org MONADR		;Monitor ROM start
                
 F800 01B9F8    	lxi	b,INIT2		;return address
                
                ;Fall into INIT
                
                ;***Special Subroutine**********************
                ;Initialization
                ;   find RAM for the stack and sector buffer
                ;   Install RAM code
                ;   Initialize I/O ports
                ;On Entry:
                ;  bc = return address
                ;On Exit:
                ;  e = 0
                ;  sp = address of new stack
                ;  All standard Altair I/O ports initialized
                ;  interrupts disabled
                ;Trashes psw,d,hl
                ;*******************************************
 F803 F3        INIT:	di			;no interrupts please
                
                ;----------------------------------------------
                ;Hunt for the highest RAM page
                ;This assumes at least one 256-byte page of RAM
                ;and that if one byte within each page is RAM
                ;then the other 255 bytes are RAM too.
                ;----------------------------------------------
 F804 2100FF    	lxi	h,0FF00h
                
 F807 24        CSLOOP:	inr	h		;next RAM page
                
 F808 7E        	mov	a,m		;Original RAM data
 F809 2F        	cma
 F80A 77        	mov	m,a		;write inverted
 F80B BE        	cmp	m		;Correct?
 F80C 2F        	cma
 F80D 77        	mov	m,a		;put original data back
 F80E CA07F8    	jz	CSLOOP		;keep looking if RAM write OK
                
 F811 25        	dcr	h		;point to last good RAM page
                
                ;-------------------------------------------
                ;Relocate  and Install RAM code
                ;This loop moves more bytes than necessary
                ;to install the actual RAM code. The extra
                ;bytes land harmlessly in the (uninitialized)
                ;stack space and buffer space.
                ;On Entry:
                ;   bc = return address
                ;   h = destination address high byte
                ; On Exit:
                ;   e = 0
                ;-------------------------------------------
 F812 1156F8    	lxi	d,RIOCOD	;RAM code source
                
 F815 1A        RCLOOP:	ldax	d
 F816 BA        	cmp	d		;need to relocate an address?
 F817 C221F8    	jnz	RCL1
                
 F81A 2B        	dcx	h		;back up to fix low address byte
 F81B 7E        	mov	a,m
 F81C D656      	sui	(RIOCOD-RAMCOD) and 0FFh ;low byte of offset
 F81E 77        	mov	m,a
 F81F 23        	inx	h
                
 F820 7C        	mov	a,h		;relocate high byte
                
 F821 77        RCL1:	mov	m,a
                
 F822 2C        	inr	l
 F823 1C        	inr	e		;end with e=0 for INIT exit
                
 F824 C215F8    	jnz	RCLOOP	
                
                ;------------------------------------------------
                ;Create the stack in the RAM page now, so we can
                ;use CALLs. Push the given return address onto it
                ;
                ;Entry from MBL or CDBL requires the stack  to be
                ;at DSTACK instead of STACK, to make room for the
                ;disk/RAM code buffer. We always set the stack to
                ;DSTACK here. MAIN will move it to STACK, if
                ;that's where we return.
                ;On Entry:
                ;   bc = return address
                ;    h = RAM page high byte
                ;------------------------------------------------
 F827 2E7B      	mvi	l,DSTACK	;put stack in RAM page
 F829 F9        	sphl
 F82A C5        	push	b		;push our return address
                
                ;-------------------------------------
                ;Reset all standard Altair I/O devices
                ;the way that MBL does
                ;-------------------------------------
                ;make 4PIO 'A' channels inputs and 'B' channels outputs
                
 F82B AF        	xra	a
 F82C D320      	out	P4CA0		;access 4PIO port 0A DDR
 F82E D321      	out	P4DA0		;set 4PIO port 0A as input
                
 F830 D322      	out	P4CB0		;access 4PIO port 0B DDR
 F832 2F        	cma			;0FFh
 F833 D323      	out	P4DB0		;set 4PIO port 0B as output
                
                ;Set up the other 3 4PIO ports all the same
 F835 3E2C      	mvi	a,P4INIT
 F837 D320      	out	P4CA0		;4PIO port 0A control
 F839 D322      	out	P4CB0		;4PIO port 0B control
                
                ;Send reset command to both 2SIO ports
 F83B 3E03      	mvi	a,S2RST		;2SIO reset
 F83D D310      	out	S2CTLA		;2SIO port 0
 F83F D312      	out	S2CTLB		;2SIO port 1
                
                ;Set up both 2SIO ports: 8 data bits, 2 stop bits, no parity, 
                ;clock divide by 16 
 F841 3E11      	mvi	a,S22STP	;8N2, /16
 F843 D310      	out	S2CTLA		;2SIO port 0 control
 F845 D312      	out	S2CTLB		;2SIO port 1 control
                
                ;-------------------------------------
                ;Reset the COmpuPro Interfacer 1
                ;(Really, just set CTS output active.)
                ;-------------------------------------
 F847 3E08      	mvi	a,CICTS		;turn on CTS
 F849 D302      	out	CPTCTL
                
                ;----------------------------------------------------
                ;Fall into TPCMD to set the default transfer port and
                ;"Return" to the address provided in bc on entry.
                ;---------------------------------------------------- 
 F84B 2E06      	mvi	l,DTPORT	;default transfer port
                
                ;***Command Routine*******************
                ;TP [<port>] Set Transfer Port
                ; Port   Device
                ;  0    88-2SIO port 0, 2 stop bits
                ;  1    88-2SIO port 0, 2 stop bits
                ;  2    88-SIO
                ;  3    88-ACR
                ;  4    88-4PIO port 0
                ;  5    88-PIO
                ;  6    88-2SIO port 1, 2 stop bits
                ;  7    CompuPro Interfacer 1 Port B
                ;
                ;On Entry:
                ;  l=port number (upper digit ignored)
                ;Trashes psw,bc,hl
                ;*************************************
 F84D 7D        TPCMD:	mov	a,l			;get port
 F84E E607      	ani	7			;make it a legal value
 F850 CDEDFF    	call	 RAMPAG
 F853 2E00      	mvi	l,RSETP-RIOCOD+RAMCOD
 F855 E9        	pchl				;run RSETP (a=value)
                
                ;==============================================================
                ; AMON RAM I/O Code
                ; This code must be in RAM either because it gets modified or
                ; because it may get called after an IN from port FF (which may
                ; disable the PROM). All of RIOCOD must be in the same page.
                ;
                ; The ROM versions of some of these routines also double as the
                ; console I/O routines, when called in ROM.
                ;==============================================================
                RIOCOD:
                
                ;---RAM Subroutine-------------------------------------
                ;Patch the Transfer Port routines with the correct
                ;parameters for the load port that is specified in a.
                ;On Entry:
                ;  a = transfer port value (values compatible with MITS
                ;      loaders from rev 3.0 onward.). A < 8
                ;Trashes psw,bc,hl
                ;------------------------------------------------------
 F856 0199F8    RSETP:	lxi	b,PTABLE	;lookup table
                
 F859 87        	add	a		;4 bytes/entry
 F85A 87        	add	a
 F85B 81        	add	c		;look up in PTABLE (clr carry)
 F85C 4F        	mov	c,a		;bc=PTABLE(port value)
                
                ;Set up the input port routine
 F85D 0A        	ldax	b		;input data port & CMA flag
 F85E 1F        	rar			;move CMA flag into Carry
 F85F 3289F8    	sta	TPIDP+1		;install data port address
                
                ;hl gets the status port (in l) and either NOP or CMA (in h)
 F862 2600      	mvi	h,NOP		;NOP instruction
 F864 D269F8    	jnc	RSETP1
 F867 262F      	mvi	h,CMA		;CMA instruction
                RSETP1:
                
 F869 3D        	dcr	a		;status port = data port-1
 F86A 6F        	mov	l,a		;install status port address
                
                ;Set the status port and either NOP or CMA instruction
 F86B 2283F8    	shld	TPISP+1		;status port and NOP/CMA
                
 F86E 0C        	inr	c		;next table entry is
 F86F 0A        	ldax	b		;..the data available mask
 F870 3286F8    	sta	TPIMSK+1	;install mask
                
                ;Set up the output port routine
 F873 0C        	inr	c		;next table entry is
 F874 0A        	ldax	b		;..the data output port address
 F875 3296F8    	sta	TPODP+1		;install data port address
                
 F878 3D        	dcr	a		;status port = data port-1
 F879 6F        	mov	l,a		;install stat port address
 F87A 228DF8    	shld	TPOSP+1		;status port and NOP/CMA
                
 F87D 0C        	inr	c		;next table entry is
 F87E 0A        	ldax	b		;..the transmitter ready mask
 F87F 3290F8    	sta	TPOMSK+1	;install ready mask
                
                ;Fall into RTPIS to return, saving one byte
                
                ;===Subroutine==============
                ;Get Console keyboard Status
                ;On Exit:
                ;  Z clear if data available
                ;===========================
                KSTAT:
                
                ;Fall into the ROM version of Transfer Port Input Status,
                ;which is the get consolekeyboard status routine
                
                ;---RAM Subroutine---------------
                ;Get Transfer Port input status
                ;This code gets modified by RSETP
                ;On Exit:
                ;  Z clear if data available
                ;  a=0 and Z set if not
                ;--------------------------------
                RTPIS:	
 F882 DB10      TPISP:	in	CONSTA		;(status port) read status
 F884 00        TPINOP:	db	CONRPO		;(either NOP or CMA)
 F885 E601      TPIMSK:	ani	CONRDF		;(port bit mask)
 F887 C9        	ret
                
                ;---RAM Subroutine----------------------------
                ;Get a byte from the Transfer Port immediately
                ;This code gets modified by RSETP
                ;(The ROM version of this subroutine is the
                ;get console keyboard data routine.)
                ;On Entry:
                ;  Transfer port Rx data is ready
                ;On Exit:
                ;  a = input character
                ;  Z cleared
                ;---------------------------------------------
                RTPIN:				;call here to flush port
 F888 DB11      TPIDP:	in	CONRXD		;(data port) get data byte
                
 F88A C9        	ret			;result in a
                
                ;===Subroutine============
                ;Send byte to Console
                ;On Entry:
                ;  a = byte to send
                ;On Exit:
                ;  All registers preserved
                ;=========================
                PRINTA:
                
                ;Fall into the ROM version of Transfer Port Tx Data,
                ;which is the write to console routine
                
                ;---RAM Subroutine---------------
                ;Send a byte to the Transfer Port
                ;This code gets modified by RSETP
                ;On Entry:
                ;  a = byte to send
                ;All registers preserved
                ;--------------------------------
 F88B F5        RTPOUT:	push	psw
                
                WAITPO:
 F88C DB10      TPOSP:	in	CONSTA		;(status port) read status
 F88E 00        TPONOP:	db	CONTPO		;(NOP or CMA)
 F88F E602      TPOMSK:	ani	CONTBE		;(Tx port mask)
 F891 CA8CF8    	jz	WAITPO
                
 F894 F1        	pop	psw
 F895 D311      TPODP:	out	CONTXD		;(data port)
 F897 C9        	ret	
                
                ;==============================================================
                ; RAM Variable (the only one)
                ;==============================================================
 F898 00        TTYPE:	db	0	;0 (even) means terminal (backspacing)
                			;1 (odd) means Teletype (no backspace)
                
                ;---RAM Table-------------------------------------------
                ;Port parameters: One 4-byte entry for each port:
                ; byte 1 = Rx data port address * 2 + cma flag
                ; byte 2 = ready mask for data input
                ; byte 3 = Tx data port address
                ; byte 4 = ready mask for data output
                ;Assumptions:
                ; the control ports for TX or Rx immediately precede the
                ;   data ports.
                ; the polarity of the Tx ready status bit is the same as
                ;   the rx empty status bit.
                ; Rx port addresses are all < 80h
                ;
                ;The first 6 entries are standard for MITS software.
                ;The 7th entry replaces the MITS high-speed paper tape
                ;  reader with the 88-2SIO's 2nd serial port.
                ;The 8th entry is a custom port, currently the CompuPro
                ;  Interfacer 1 channel B, defined way above.
                ;-------------------------------------------------------
 F899 22011102  PTABLE:	db	S2RXDA*2,S2RDF,S2TXDA,S2TBE	;0:2SIO A
 F89D 22011102  	db	S2RXDA*2,S2RDF,S2TXDA,S2TBE	;1:2SIO A
 F8A1 03010180  	db	SIORXD*2+1,SIOIDR,SIOTXD,SIOODR	;2:SIO
 F8A5 0F010780  	db	ACRRXD*2+1,ACRIDR,ACRTXD,ACRODR	;3:ACR
 F8A9 42802380  	db	P4DA0*2,P4RDF,P4DB0,P4TDE	;4:4PIO port 0
 F8AD 0A020501  	db	PIORXD*2,PIORDF,PIOTXD,PIOTDE	;5:PIO
 F8B1 26011302  	db	S2RXDB*2,S2RDF,S2TXDB,S2TBE	;6:2SIO B
                
 F8B5 06020301  	db CPRDAT*2+CPSPOL,CPRRDY,CPTDAT,CPTRDY ;7: Interfacer
                
                ;===Assembly Check=====================================
                ; All of RIOCOD must be in the same 256-byte EPROM page
                ;======================================================
 F8B9 =         RCEND	equ	$
                
                 if (RCEND-1)/256-(RIOCOD/256)
                	ERROR: RAM I/O code is not all in one page
                 endif
                
                ;===Assembly Check==========================
                ; All of RIOCOD must fit in one RAM page,
                ; together with the stack and the RAM buffer
                ;===========================================
                 if (((RCEND-1)-RIOCOD)+MINSTK+SECSIZ)/256
                	ERROR: RAM I/O code is too large
                 endif
                
                ;========================================
                ;= Cool-Start Initialization            =
                ;= Print banner, go to MAIN             =
                ;= On Entry:                            =
                ;=   sp points to a valid stack address =
                ;========================================
 F8B9 CD56FD    INIT2:	call	CILPRT		;print banner
                				;returns a=0
 F8BC 414D4F4E20	db	'AMON '
 F8C1 332E      	db 	((VERSION AND 0F0h)/16)+'0','.'
 F8C3 31        	db	(VERSION AND 0Fh) +'0'
 F8C4 206279204D	db	' by M. Eberhard',CR,LF
 F8D5 52414D3AA0	db	'RAM:',' '+80h
                
                ;Announce address of the first byte of RAM page
                ;a=0 here
 F8DA CDEDFF    	call	RAMPAG
 F8DD CD01FD    	call	PHLCHX		;Print hl on console
                
                ;Fall into main
                
                ;***********************************
                ; Command Processor Main entry point
                ; (Re)create the stack, print the
                ; prompt, get and process commands
                ;***********************************
                MAIN:
                
                ;Repair/Move the stack to where there is plenty of space
                ;leaving room for just the line buffer above the stack
 F8E0 3EB0      	mvi	a,STACK		;point to bottom of stack
 F8E2 CDEDFF    	call	RAMPAG		;find stack
 F8E5 F9        	sphl			;fix stack
                
                ;Print the prompt, and get a line of keyboard input
                ;This assumes PTABLE and MAIN are in the same page
 F8E6 11E0F8    	lxi	d,MAIN		;create command-return
 F8E9 D5        	push	d		;..address on the stack
                
 F8EA CD56FD    	call	CILPRT		;print CR,LF, prompt
 F8ED BE        	db	PROMPT+80h
                
 F8EE CDD1FB    	call	GETLIN		;get user input line
                				;de=beginning of line
                				;Z set if no character found
                				;0 at end of line
                
 F8F1 F3        	di			;INTE light off (cancel error)
 F8F2 C8        	rz			;No command? just ignore.
                
                ;Check command list, and execute the command if found
 F8F3 EB        	xchg			;command address to hl
 F8F4 11FEEF    	lxi	d,COMTAB-2	;point to command table
                
 F8F7 4E        	mov	c,m		;1st command chr in c
 F8F8 23        	inx	h		;2nd command chr in m
                
                ;Search through table at de for a 2-character match of c,m
                ;allowing uppercase or lowercase letters.
 F8F9 13        NXTCOM:	inx	d		;skip over address
 F8FA 13        	inx	d
 F8FB 1A        	ldax	d
 F8FC B7        	ora	a		;test for table end
 F8FD CAF8FF    	jz	CMDERR		;not in table
                
 F900 A9        	xra	c		;test first character
 F901 47        	mov	b,a		;temp save result
 F902 13        	inx	d		;2nd table character
 F903 1A        	ldax	d
 F904 AE        	xra	m		;test 2nd character
                
 F905 13        	inx	d		;point to address offset
                
 F906 B0        	ora	b		;both characters match?
 F907 E6DF      	ani  ('a'-'A') XOR 0FFh	;lowercase is ok
 F909 C2F9F8    	jnz	NXTCOM		;NO match: keep looking
                
 F90C 23        	inx	h		;skip past 2-letter command
                
                ;Got a match. Get command routine address, put it on the stack
 F90D EB        	xchg			;(hl)=address of cmd routine
                				;de=input pointer
                
 F90E 4E        	mov	c,m		;address low byte
 F90F 23        	inx	h
                
 F910 7E        	mov	a,m		;address high byte
 F911 F680      	ori	80h		;clear non-hex flag bit
 F913 47        	mov	b,a		;..to make legit address
                
 F914 C5        	push	b		;command routine address
                
                ;If the msb of the routine address was zero (this bit used as
                ;a flag), then any parameters are not hex - so go directly to
                ;the command execution routine.
 F915 AE        	xra	m		;Non-hex? (clears carry too)
 F916 C0        	rnz			;y: go directly to routine
                
                ;Get the following hex parameter (if any) and put it in hl.
                ;Set the Carry flag if no parameter present.
                ;Leave de pointing to the 1st chr after the 1st parameter.
                ;'return' to the Command Routine on the stack.
                
                ;skip into FNDHEX
                
 F917 21        	db	21h		;'lxi h' opcode skips 2
                
                ;***Subroutine*************************************
                ;Scan past blanks and get a hex value
                ;On Entry:
                ;  de=address of next item in the input line buffer
                ;On Exit:
                ;  hl=value
                ;  de advanced past character
                ;  top-of-stack = prior hl value
                ;  Z set, Carry clear if value
                ;  Carry set and a=hl=0 if no value found
                ;**************************************************
 F918 E3        PHFHEX:	xthl			;push hl
 F919 E5        	push	h		;..beneath return address
                
                ;Fall into FNDHEX
                
                ;***Subroutine*************************************
                ;Scan past blanks and get a hex value
                ;On Entry:
                ;  de=address of next item in the input line buffer
                ;On Exit:
                ;  hl = hex value
                ;  de advanced past character
                ;  Z set, Carry clear if value
                ;  Carry set and a=hl=0 if no value found
                ;**************************************************
 F91A 210000    FNDHEX:	lxi	h,0		;default value
 F91D CDE7FB    	call	SSPACE		;skip spaces to find 1st digit
 F920 37        	stc			;Carry set if no digits
 F921 C8        	rz
                
 F922 1A        FHEXLP:	ldax	d		;get digit
 F923 B7        	ora	a		;end of line?
 F924 C8        	rz			;y: ret with carry clear
                
 F925 FE20      	cpi	' '		;value separator?
 F927 C8        	rz			;y: ret with carry clear
                
 F928 FE41      	cpi	'A'		;convert letters to uppercase
 F92A DA2FF9    	jc	FHNUM
 F92D E6DF      	ani	('a'-'A') XOR 0FFh	
                FHNUM:
                
 F92F 29        	dad	h		;make room for the new digit
 F930 29        	dad	h
 F931 29        	dad	h
 F932 29        	dad	h
                
 F933 CD6EFE    	call	HEXCON		;Do the conversion
 F936 D2F8FF    	jnc	CMDERR		;not valid hexidecimal value?
                
 F939 85        	add	l
 F93A 6F        	mov	l,a		;move new digit in
 F93B 13        	inx	d		;bump the pointer
 F93C C322F9    	jmp	FHEXLP
                
                ;***Command Routine***********************
                ;AD <SRC> <BCNT> [<GO>]
                ; (Dump memory in Altair binary format)
                ;On Entry:
                ;  hl=<SRC>
                ;  Carry set if none entered
                ;  de points to <BCNT>
                ;  TP command has set up the Transfer Port
                ;*****************************************
 F93F CDF3FF    ADCMD:	call	GETHEX		;save <SRC>, get <BCNT>
 F942 CD18F9    	call	PHFHEX		;save <BCNT>, get <GO>
                
 F945 D1        	pop	d		;get de=<BCNT>
 F946 E3        	xthl			;save <GO>, get <SRC>
 F947 F5        	push	psw		;Carry set if no <GO> provided
                
 F948 EB        	xchg			;de= <SRC>, hl=<BCNT>
                
                ;de = source address
                ;hl = byte count
                
                ;Punch a pre-leader so that MITS's MBL can load this file
 F949 3E20      	mvi	a,20h		;punch 20h as the pre-leader
 F94B CD86F9    	call	LEADER
                
                ;Punch null leader
 F94E CD85F9    	call	LEADR0		;returns with b=0
                
                ;Loop to punch all the requested data
                ;(b=0 here, both on initial entry and upon looping)
                
                ;Compute b=data byte count of the next block, max=255
 F951 05        NXTBLK:	dcr	b		;b=FFh=255
                
 F952 7C        	mov	a,h		;>256 bytes left?
 F953 B7        	ora	a
 F954 C258F9    	jnz	BLKSIZ
 F957 45        	mov	b,l		;N: do what's left
                BLKSIZ:
                
                ;Punch the the block header info:
                ; sync chr, byte count, & 2-byte load address
                ;  b = block size
                ; de = starting memory address for block data
                ; hl = remaining bytes to punch
 F958 D5        	push	d		;save load address
                
 F959 1E3C      	mvi	e,ALTPLR	;Punch load-block sync chr
 F95B 50        	mov	d,b		;and block byte count	
 F95C CD8EFB    	call	TPOED
                
 F95F D1        	pop	d		;restore load address
 F960 CD8EFB    	call	TPOED		;Punch de=load address
                				;ends with a=d
 F963 83        	add	e		;a=checksum of the address
                
                ;Punch b bytes of block data, computing checksum as we go
                ;  a = checksum so far
                ;  b = block size
                ; de = starting memory address for block data
                ; hl = remaining bytes to punch
 F964 4F        BDATLP:	mov	c,a		;temp save checksum
 F965 1A        	ldax	d		;get memory data
 F966 CD93FB    	call	TPOUT		;...and punch it
 F969 2B        	dcx	h		;one fewer to punch
                
 F96A 81        	add	c		;update checksum
                
 F96B 13        	inx	d		;Next address
 F96C 05        	dcr	b		;Loop 'til done with block data
 F96D C264F9    	jnz	BDATLP		;ends with b=0
                
                ;a = block checksum
                ;b = 0
 F970 CD93FB    	call	TPOUT		;Punch the block checksum
                
                ;Continue until all the data has been punched
                ;  b = 0
                ; de = next address to punch
                ; hl = remaining bytes to punch
                ; Test for hl=0, meaning there are more bytes to punch
 F973 7D        	mov	a,l
 F974 B4        	ora	h
 F975 C251F9    	jnz	NXTBLK		;Y: Do another block
                
                ;Punch a GO record, if the user asked for one
 F978 F1        	pop	psw		;carry set if no <GO> provided
 F979 D1        	pop	d		;Go address
 F97A DA85F9    	jc	LEADR0		;no go record?
                
 F97D 3E78      	mvi	a,ALTGOR	;Go record sync chr
 F97F CD93FB    	call	TPOUT		;punch it
                
 F982 CD8EFB    	call	TPOED		;Punch de=go address
                
                ;Fall into LEADR0 to punch a null trailer and return to MAIN
                
                ;---Local Subroutine------------
                ;Punch a null leader
                ;On Exit:
                ;  a=0
                ;  b=0
                ;  all other registers preserved
                ;-------------------------------
 F985 AF        LEADR0:	xra	a		;leader chr
                
                ;Fall into LEADER (with a=0) to punch the leader
                
                ;---Local Subroutine------------
                ;Punch a leader
                ;On Entry:
                ;  a = leader character
                ;On Exit:
                ;  b=0
                ;  all other registers preserved
                ;-------------------------------
 F986 063C      LEADER:	mvi	b,ALTLDR	;leader length
                
 F988 CD93FB    LEADLP:	call	TPOUT
 F98B 05        	dcr	b
 F98C C288F9    	jnz	LEADLP		;ends with b=0
                
 F98F C9        	ret
                
                ;***Command Routine*********************************
                ;CO <SRC> <DST> <BCNT> [<RPT>] (Copy Memory)
                ;
                ; Copy <BCNT> bytes of memory from <SRC> to <DST>.
                ; Repeat <RPT> times (for EPROM programming). Verify
                ; result when done.
                ;On Entry:
                ;  hl=<SRC>
                ;  de points to <DST>, <BCNT>, <RPT> follow
                ;***************************************************
 F990 CDF3FF    COCMD:	call	GETHEX		;save source, get destination
 F993 CDF3FF    	call	GETHEX		;save dest, get byte count
                
 F996 CD56FD    	call	CILPRT
 F999 436F707969	db	'Copyin','g'+80h
                
 F9A0 CD18F9    	call	PHFHEX		;save <BCNT>, get <RPT>
 F9A3 7D        	mov	a,l		;default to 1
 F9A4 CE00      	aci	0		;Carry if no value given
                
                ;Repeat copy the specified number of times (in a)
 F9A6 C1        MCRLP:	pop	b		;bc=count
 F9A7 D1        	pop	d		;de=destination
 F9A8 E1        	pop	h		;hl=source
                
 F9A9 E5        	push	h		;save source
 F9AA D5        	push	d		;save Dest
 F9AB C5        	push	b		;save count
                
 F9AC F5        	push	psw		;save a=repeat count
                
                ;Loop to copy bc bytes from (hl) to (de)
 F9AD 7E        MCLOOP:	mov	a,m
 F9AE 12        	stax	d
 F9AF 23        	inx	h
 F9B0 13        	inx	d
 F9B1 0B        	dcx	b
 F9B2 78        	mov	a,b
 F9B3 B1        	ora	c
 F9B4 C2ADF9    	jnz	MCLOOP
                
                ;Repeat the copy as requested by the user
 F9B7 F1        	pop	psw		;recover repeat count
 F9B8 3D        	dcr	a		;repeat as requested
                
                ;Print a pacifier dot for all but the last pass
                ;(This eliminates the dot for a single-pass copy)
 F9B9 47        	mov	b,a		;temp save repeat count
 F9BA 3E2E      	mvi	a,PCFIER
 F9BC C48BF8    	cnz	PRINTA		;preserves all regs
 F9BF 78        	mov	a,b		;repeat count
                
 F9C0 C2A6F9    	jnz	MCRLP
                
 F9C3 C3CDF9    	jmp	VERIFY		;good copy?
                
                ;***Command Routine*********************************
                ;VE <SRC> <DST> <BCNT> (Verify Memory)
                ;
                ; Compare <BCNT> bytes of memory from <SRC> to <DST>
                ; and report pass/fail
                ;On Entry:
                ;  hl=<SRC>
                ;  Carry set if none entered
                ;  de points to <DST>, <BCNT> follows
                ;***************************************************
 F9C6 CDF3FF    VECMD:	call	GETHEX		;save <SRC>, get <DST>
 F9C9 CDF3FF    	call	GETHEX		;save <DST>, get <BCNT>
 F9CC E5        	push	h		;save <BCNT>
                
                ;Fall into VERIFY to actually verify
                
                ;***Subroutine***************************
                ;Verify memory. Report errors to console.
                ;On Entry:
                ;  Top of stack=byte count
                ;  next on stack = destination address
                ;  next on stack - source address
                ;  next on stack=return address (TO MAIN)
                ;****************************************
 F9CD C1        VERIFY:	pop	b		;byte count
 F9CE E1        	pop	h		;hl=destination
 F9CF D1        	pop	d		;de=source
                
                 if EPROM32
 F9D0 CD56FD    	call	CILPRT
 F9D3 5665726966	db	'Verifyin','g'+80h
                				;returns carry clear
 F9DC F5        	push	psw		;c gets set if error found
                
 F9DD C32DF1    	jmp	DOVRFY
                 endif ;EPROM32
                
                 if not EPROM32
                	call	CILPRT
                	db	'Checkin','g'+80h
                				;returns carry clear
                ;Loop to compare memory, reporting mismatches
                VLOOP:	ldax	d		;get expected data
                	cmp	m		;match?
                	cnz	MERROR		;N: error
                
                	inx	h
                	inx	d
                	dcx	b
                	mov	a,b
                	ora	c
                	jnz	VLOOP
                
                	ret
                 endif ;not EPROM32
                
                ;***Command Routine*********************************
                ;SE <ADR> <BYTE1> [<BYTE2> [<BYTEn>]]
                ;    Search for string of bytes, starting at <ADR>
                ;    <BYTEn> can be either hex byte or 'text string'
                ;On Entry:
                ;  hl=<ADR>
                ;  Carry set if none entered
                ;  de points to <BYTEs>
                ;***************************************************
                SECMD:
                
                ;Get search string from input buffer, convert each byte
                ;to binary, and save result in the RAM buffer
 F9E0 CDE9FF    	call	FNDBUF		;push hl, find RAM buffer
                
 F9E3 E5        	push	h		;binary string address
 F9E4 012700    	lxi	b,QUOTE		;b=byte count, c=QUOTE
                	
                ;--------------------------------------
                ;loop to get either a 2-digit hex value
                ;or a text string (in quotes) each pass
                ;--------------------------------------
 F9E7 CDE7FB    SCHLUP:	call	SSPACE		;returns a=found chr, 0 if none
                
 F9EA B9        	cmp	c		;is 1st chr a quote?
 F9EB CC52FA    	cz	SSTRNG		;y:search for a string
 F9EE C45FFA    	cnz	SCHHEX		;n: search for hex
                				;returns carry set if end
 F9F1 D2E7F9    	jnc	SCHLUP		;loop to get all input
                
                ;----------------------------------------	
                ;Search RAM for the requested string
                ; b = string length
                ; top-of-stack = binary string address
                ; next-on-stack = starting search address
                ;----------------------------------------
 F9F4 D1        	pop	d		;binary string address
 F9F5 E1        	pop	h		;search start address
                
 F9F6 78        	mov	a,b		;anything to search for?
 F9F7 B7        	ora	a
 F9F8 CAF8FF    	jz	CMDERR		;error if not
                
 F9FB E5        SLOOP1:	push	h		;search start address
 F9FC D5        	push	d		;binary string address
                
 F9FD 48        	mov	c,b		;string byte count
                
                ;Loop through all bytes of the requested string
                ;until either all bytes match or 1st non-matching byte
 F9FE 7A        SLOOP2:	mov	a,d
 F9FF BC        	cmp	h		;don't search our own RAM page
 FA00 CA3DFA    	jz	NOMTCH
                
 FA03 1A        	ldax	d		;search string
 FA04 BE        	cmp	m		;current RAM
 FA05 C23DFA    	jnz	NOMTCH
                
 FA08 23        	inx	h		;test next byte
 FA09 13        	inx	d
 FA0A 0D        	dcr	c		;tested all bytes yet?
 FA0B C2FEF9    	jnz	SLOOP2
                
                ;String match found. Print address, ask to continue search
 FA0E D1        	pop	d		;binary string address
 FA0F E1        	pop	h		;search start address
                
 FA10 CD56FD    	call	CILPRT
 FA13 466F756E64	db	'Found at',' '+80h
                
 FA1C C5        	push	b
 FA1D CD01FD    	call	PHLCHX		;print match address, trash bc
 FA20 C1        	pop	b
                
 FA21 CD56FD    	call	CILPRT
 FA24 4D6F726520	db	'More (Y/N)?',' '+80h
                
 FA30 CDCAFB    	call	GETKBD		;user response
 FA33 CD8BF8    	call	PRINTA		;echo
                
 FA36 F620      	ori	('y'-'Y')	;make it lowercase
 FA38 FE79      	cpi	'y'
 FA3A C0        	rnz			;anything but y ends
                
 FA3B E5        	push	h		;search start address
 FA3C D5        	push	d		;binary string address
                
                ;Search again, starting at the next byte after hl.
                ;Quit if we've reached the end of memory, FFFFh
 FA3D D1        NOMTCH:	pop	d		;binary string address
 FA3E E1        	pop	h		;search start address
                
 FA3F 23        	inx	h		;next RAM
 FA40 7C        	mov	a,h
 FA41 B5        	ora	l		;End of memory?
 FA42 C2FBF9    	jnz	SLOOP1
                
 FA45 CD56FD    	call	CILPRT
 FA48 4E6F742066	db	'Not foun','d'+80h
                
 FA51 C9        	ret
                
                ;---Local Subroutine-----------------------
                ;Get a text string from user input at (de),
                ;store string at (hl), bump count in b
                ;On Entry:
                ;  b = byte count
                ;  c=QUOTE
                ;  de points to initial quote
                ;On Exit:
                ;  Z flag set
                ;------------------------------------------
 FA52 13        SSTRNG:	inx	d		;skip over quote
                
 FA53 1A        STLOOP:	ldax	d
 FA54 B7        	ora	a		;end quote is not required
 FA55 C8        	rz	
                
 FA56 13        	inx	d		;point past this input chr
                
 FA57 B9        	cmp	c		;end of string?
 FA58 C8        	rz	
                
 FA59 77        	mov	m,a		;store a string byte
 FA5A 23        	inx	h
 FA5B 04        	inr	b
                
 FA5C C353FA    	jmp	STLOOP		;get more of this string
                
                ;---Local Subroutine-------------------------------
                ;Get one hex value from user input at (de), convert
                ;it to binary, store it at (hl), bump count in b
                ;On Exit:
                ;  Carry set if no hex digit found
                ;--------------------------------------------------
 FA5F CD18F9    SCHHEX:	call	PHFHEX		;save next string addr byte,
                				;get a value.
                				;hl=0 & carry set if none
                
 FA62 24        	inr	h		;no high byte allowed
 FA63 25        	dcr	h		;does not change carry
 FA64 C2F8FF    	jnz	CMDERR
                
 FA67 7D        	mov	a,l		;binary value
 FA68 E1        	pop	h		;next string address byte
                
 FA69 D8        	rc			;carry set means end of input
                
 FA6A 77        	mov	m,a		;store the hex digit
 FA6B 23        	inx	h
 FA6C 04        	inr	b
                
 FA6D C9        	ret
                
                ;***Command Routine****************************
                ;TT [0/1] Set Terminal Type
                ;  0 (even) means backspacing works
                ;  1 (odd) means no backspacing (e.g. Teletype)
                ;On Entry:
                ;  l = 0 or 1 (odd or even really)
                ;**********************************************
 FA6E 4D        TTCMD:	mov	c,l		;user value
 FA6F 3E42      	mvi	a,TTYPE-RIOCOD+RAMCOD
 FA71 CDEDFF    	call	RAMPAG
                
 FA74 71        	mov	m,c		;remember terminal type
 FA75 C9        	ret
                
                ;***Command Routine********************
                ;EX [<ADR> [<OPT>]] (execute)
                ;
                ;JUMP to <ADR>. If <OPT>=1 the execute
                ;an "IN FF" first, to disable this PROM
                ;On Entry:
                ;  hl = address, default to 0
                ;  de points to <OPT>
                ;  Carry set if none entered
                ;  TOP-of-stack has MAIN address
                ;**************************************
 FA76 CD18F9    EXCMD:	call	PHFHEX		;save <ADR>, get l=<OPT>
 FA79 2D        	dcr	l		;anything but 1
 FA7A C0        	rnz			;..just executes at <ADR>
                
                ;Fall into EXECDP
                
                ;***Exit******************************
                ;Execute "IN FF" and then jump to code
                ;(This disables PROM)
                ;On Entry:
                ;  execution address is on stack
                ;*************************************
 FA7B 1EC9      EXECDP:	mvi	e,RET		;RET opcode, <don't care>
 FA7D D5        	push	d		;..onto stack
                	
 FA7E 11DBFF    	lxi	d,0FFDBh	;IN FF opcode
 FA81 D5        	push	d		;..onto stack
                
 FA82 210000    	lxi	h,0
 FA85 39        	dad	sp		;point hl to our code
                
 FA86 D1        	pop	d		;point sp to <ADR>
 FA87 D1        	pop	d
 FA88 E9        	pchl			;execute: IN  FF
                				;         RET
                
                ;***Command Routine**********************************
                ;DU [<ADR>] [<BCNT>] (dump memory to console)
                ;
                ;Print <BCNT> bytes of memory contents from <ADR> on
                ;the console in hex. If no count is specified, then
                ;then print the contents of all memory, 10000h bytes.
                ;Pause with the space bar, abort with control-C.
                ;On Entry:
                ;  hl=<ADR>
                ;  de points to <BCNT>, if any
                ;****************************************************
 FA89 CD18F9    DUCMD:	call	PHFHEX		;save <ADR>, get hl=<BCNT>
 FA8C 7D        	mov	a,l		;low byte
 FA8D CE00      	aci	0		;default to 1
 FA8F 6F        	mov	l,a
                
 FA90 EB        	xchg			;de has byte count
 FA91 E1        	pop	h		;recover start address
                
                ;Print the address at the beginning of each line
 FA92 CD60FE    DLINE:	call	PHLADR		;print hl as an address
                				;Sets b=0, trashes c
                
                ;Print 16 bytes of hex data separated by spaces
 FA95 E5        	push	h		;save for ASCII dump
 FA96 D5        	push	d
                
 FA97 7E        DLOOP:	mov	a,m		;get the character
 FA98 CD44FE    	call	PAHEX		;TO console in hex (b=0)
                
 FA9B CD5BFD    	call	ILPRNT		;print a space
 FA9E A0        	db	' '+80h
                
 FA9F 23        	inx	h		;next address
                
 FAA0 1B        	dcx	d		;all done?
 FAA1 7A        	mov	a,d
 FAA2 B3        	ora	e
 FAA3 CAACFA    	jz	DLDONE		;Y: done with command
                
 FAA6 3E0F      	mvi	a,0Fh		;new line every XXX0 hex
 FAA8 A5        	ana	l
                
 FAA9 C297FA    	jnz	DLOOP		;not zero if more for this line
                
 FAAC D1        DLDONE:	pop	d		;recover count and address
 FAAD E1        	pop	h
                
                ;Print up to 16 ASCII characters, or '.' if unprintable
 FAAE CD5BFD    	call	ILPRNT		;pretty space
 FAB1 A0        	db	' '+80h
                
 FAB2 7E        ADLOOP:	mov	a,m		;get the character
 FAB3 3C        	inr	a		;del (7F) is also nonprinting
 FAB4 E67F      	ani	7Fh		;clear parity
 FAB6 FE21      	cpi	' '+1		;everything below space
 FAB8 D2BDFA    	jnc	PRNTBL		;..is nonprinting
                
 FABB 3E2F      	mvi	a,'.'+1		;dot for non-printing
                
 FABD 3D        PRNTBL:	dcr	a		;undo inc
                
 FABE CD8BF8    	call	PRINTA		;Print ASCII or dot
                
 FAC1 1B        	dcx	d		;all done?
 FAC2 7A        	mov	a,d
 FAC3 B3        	ora	e
 FAC4 C8        	rz			;done with command
                
 FAC5 23        	inx	h		;next line?
 FAC6 3E0F      	mvi	a,0Fh		;new line every XXX0 hex
 FAC8 A5        	ana	l
                
 FAC9 C2B2FA    	jnz	ADLOOP		;not zero if more for this line
                
                ;Give user a chance to pause or quit at the end of each line
 FACC CDC4FB    	call	CKPAUS		;Pause or abort?
 FACF C392FA    	jmp	DLINE		;next line
                
                ;***Command Routine**********************************
                ;FI [<VAL> [<ADR> [<BCNT>]]] (fill memory)
                ;
                ;Fill <BCNT> bytes of memory with <VAL> from <ADR>.
                ;if <VAL> is not provided, then fill the specified
                ;range with 00. <ADR> defaults to 0. If <BCNT> is not
                ;provided, fill until we reach AMON's RAM page.
                ;On Entry:
                ;  hl=<ADR>
                ;  Carry set if none entered
                ;  de points to <BCNT>, <VAL> follows, if any
                ;****************************************************
 FAD2 4D        FICMD:	mov	c,l		;<VAL> c
                
 FAD3 CD1AF9    	call	FNDHEX		;get <ADR>, default 0
 FAD6 CD18F9    	call	PHFHEX		;save <ADR>, get hl=<BCNT>
 FAD9 EB        	xchg			;de has byte count
                
 FADA CDEDFF    	call	RAMPAG		;find our RAM
 FADD 44        	mov	b,h		;b remembers RAM page
                
 FADE E1        	pop	h		;hl has start address
                
                ;Loop to fill memory, quitting if RAM page
 FADF 7C        FMLOOP:	mov	a,h
 FAE0 B8        	cmp	b		;Filling RAM page?
 FAE1 C8        	rz			;y: done	
                
 FAE2 71        	mov	m,c
 FAE3 23        	inx	h
                
 FAE4 1B        	dcx	d		;done yet?
 FAE5 7A        	mov	a,d
 FAE6 B3        	ora	e
 FAE7 C2DFFA    	jnz	FMLOOP
                
 FAEA C9        	ret
                
                ;***Command Routine**********************************
                ;TE [<EXCHR>] (simple Terminal Mode)
                ;
                ;Send all console keyboard data to Transfer Port,
                ;and send send all Transfer Port data to the console.
                ;If the Transfer Port is the console, then just echo
                ;the keyboard to the console. Nulls from the keyboard
                ;are ignored.
                ; <EXCHR> on the keyboard to exit
                ; (defaults to DTEXIT)
                ;****************************************************
 FAEB CD5BFD    TECMD:	call	ILPRNT		;announce exit character
 FAEE 457869743A	db	'Exit: ','^'+80h
                
 FAF5 CDE7FB    	call	SSPACE		;get optional exit character
 FAF8 C2FDFA    	jnz	TMNL1		;Got an exit value in a
 FAFB 3E03      	mvi	a,DTEXIT	;default abort
                
                ;Convert exit character to uppercase, non-control, and
                ;print exit character message
 FAFD E61F      TMNL1:	ani	1Fh		;make it a control chr
 FAFF 6F        	mov	l,a		;remember exit character
                
 FB00 F640      	ori	'C'-CTRLC	;make it printable
 FB02 CD8BF8    	call	PRINTA
                
 FB05 CD56FD    	call	CILPRT		;CR,LF,LF to be pretty
 FB08 8A        	db	LF+80h
                
                ;Be a terminal until we get an exit character=l.
                ;Just echo if Transfer Port = console
 FB09 CD82F8    TLOOP:	call	KSTAT		;anything typed?
 FB0C C46AFD    	cnz	KDATA		;Y:get the keyboard data
                
 FB0F BD        	cmp	l		;exit character?
 FB10 C8        	rz			;Y: done
                
 FB11 B7        	ora	a		;anything typed? (ignore nulls)
 FB12 C493FB    	cnz	TPOUT		;KBD data to Transfer Port
                
 FB15 CD9DFD    	call	TESTTP		;Transfer Port = console?
                				;Z set if so
                
 FB18 C498FD    	cnz	TPISTA		;Any Transfer Port data?
                				;NZ if so
                
 FB1B C491FD    	cnz	TPIN		;get Transfer Port data
                				;always returns W/ nz
 FB1E C48BF8    	cnz	PRINTA		;and send it to console
 FB21 C309FB    	jmp	TLOOP
                
                ;***Command Routine*********************************
                ;OT <PORT> <DATA> (Output to port)
                ;
                ;On Entry:
                ;  l=PORT
                ;  de points to DATA
                ;
                ;Creates this routine on the stack, then executes it
                ;	NOP
                ;	MVI  a,<DATA>       
                ;       OUT  <PORT>
                ;       RET
                ;***************************************************
 FB24 26C9      OTCMD:	mvi	h,RET		;opcode
 FB26 CD18F9    	call	PHFHEX		;push <PORT>, RET opcode
                				;Get l=<DATA>
                
 FB29 26D3      	mvi	h,OUT		;opcode
 FB2B E5        	push	h		;data, OUT opcode
                
 FB2C 21003E    	lxi	h,3E00h		;NOP, MVI A, opcodes
 FB2F E5        	push	h
                
 FB30 65        	mov	h,l		;hl=0
 FB31 39        	dad	sp		;hl points to routine
                
 FB32 D1        	pop	d		;fix stack
 FB33 D1        	pop	d
 FB34 D1        	pop	d
 FB35 E9        	pchl			;execute RAM routine
                
                ;***Command Routine****************************************
                ;HD <ADR> <BCNT> [<OFST>] (Intel hex dump to transfer port)
                ;
                ;Dump the specified memory range to the Transfer
                ;Port as an Intel hex file
                ;On Entry:
                ;  hl=ADR
                ;  de points to subsequent parameters
                ;**********************************************************
 FB36 CDF3FF    HDCMD:	call	GETHEX		;save <ADR>, get hl=<BCNT>	
 FB39 CD18F9    	call	PHFHEX		;save <BCNT>, get hl=<OFST>
                
 FB3C E3        	xthl			;hl=byte count
 FB3D C1        	pop	b		;bc=offset
 FB3E D1        	pop	d		;de= start address
 FB3F C5        	push	b		;address offset onto stack
                
                ;Loop to send requested data in HRLEN-byte records
                HDLINE:
                
                 if EPROM32
                
                ;Print a pacifier unless the transfer
                ;port is the same as the console
                
 FB40 CD16F1    	call	PACIFY
                 endif ;EPROM32
                
                 if not EPROM32
                
                ;Give the user a chance to break in at the end of each line
                	call	CHKKBD		;abort if user says so
                
                 endif ;not EPROM32
                
                ;send record-start
 FB43 D5        	push	d		;print CRLF
 FB44 CD8BFB    	call	TPCRLF
 FB47 D1        	pop	d
                
 FB48 3E3A      	mvi	a,':'
 FB4A CD93FB    	call	TPOUT
                
                ;Compute this record byte count
 FB4D 0610      	mvi	b,HRLEN		;default bytes/line
                
 FB4F 7D        	mov	a,l		;short last line?
 FB50 90        	sub	b		;normal bytes/line
 FB51 7C        	mov	a,h
 FB52 DE00      	sbi	0
 FB54 D258FB    	jnc	HDLIN1		;N: full line
                
 FB57 45        	mov	b,l		;Y:short line
                HDLIN1:
                
                ;If byte count is 0 then go finish EOF record
 FB58 78        	mov	a,b
 FB59 B7        	ora	a
 FB5A CA80FB    	jz	HDEOF
                
                ;Send record byte count=a to Transfer Port (b<>0)
 FB5D CD40FE    	call	PAHEXC		;send byte count
                
 FB60 48        	mov	c,b		;initiate checksum		
                
                ;Compute the address by adding the RAM address to the
                ;address offset. Send the address at the beginning of
                ;each address, computing checksum in c (b<>0)
 FB61 E3        	xthl			;hl=address offset
                				;remaining byte count on stack
 FB62 E5        	push	h		;save address offset
                
 FB63 19        	dad	d		;compute address with offset
 FB64 CD38FE    	call	PHLHEX		;send address with offset
                
 FB67 E1        	pop	h		;recover address offset
 FB68 E3        	xthl			;offset on stack,
                				;remaining byte count to hl
                
                ;Send the record type (00)
 FB69 AF        	xra	a
 FB6A CD40FE    	call	PAHEXC
                
                ;Send b bytes of hex data on each line, computing
                ;the checksum in c. b>0 here.
 FB6D 1A        HDLOOP:	ldax	d		;get the character
 FB6E CD40FE    	call	PAHEXC		;send to Transfer Port
                				;(b<>0)
 FB71 2B        	dcx	h
 FB72 13        	inx	d
 FB73 05        	dcr	b		;next
 FB74 C26DFB    	jnz	HDLOOP
                
                ;Send the checksum (with b<>0)
 FB77 AF        	xra	a
 FB78 91        	sub	c
 FB79 04        	inr	b		;b<>0 means Transfer Port
 FB7A CD40FE    	call	PAHEXC
                
                ;Next record
 FB7D C340FB    	jmp	HDLINE		;next record
                
                ;--------------------------------------------
                ;Finish end-of-file Intel hex record
                ;On Entry:
                ;  The CR LF and colon have already been sent
                ;  The address offset is still on the stack
                ;--------------------------------------------
 FB80 C1        HDEOF:	pop	b		;chuck address offset
 FB81 0605      	mvi	b,5		;5 bytes for EOF
                
 FB83 AF        HDELP:	xra	a
 FB84 CD44FE    	call	PAHEX		;b<>0 for Transfer Port
 FB87 05        	dcr	b
 FB88 C283FB    	jnz	HDELP
                
                ;Fall into TPCRLF
                
                ;===============
                ;= subroutines =
                ;===============
                
                ;***Subroutine*****************
                ;Send CRLF to the transfer port
                ;Trashes de
                ;******************************
 FB8B 110D0A    TPCRLF:	lxi	d,LF*256+CR
                
                ;Fall into TPOED
                
                ;***Subroutine*********************
                ;Send e then d to the transfer port
                ;On Exit:
                ;  a=d
                ;**********************************
 FB8E 7B        TPOED:	mov	a,e
 FB8F CD93FB    	call	TPOUT
 FB92 7A        	mov	a,d
                
                ;Fall into TPOUT
                
                ;***Subroutine*********************
                ;Send a to the Transfer Port
                ;On Entry:
                ;  a = data to send
                ;  SP points into the RAM page
                ;  Transfer Port is already set up
                ;All registers preserved
                ;**********************************
 FB93 CDEBFF    TPOUT:	call	HRMPAG			;don't mess up a
 FB96 2E35      	mvi	l,RTPOUT-RIOCOD+RAMCOD	;hl points to RTPOUT
                
 FB98 E3        	xthl				;restore hl, put
                					;..address on stack
 FB99 C9        	ret				;go to RTPOUT with a
                
                ;***Subroutine***********************
                ;Print memory error details, and give
                ;user a chance to pause or abort
                ;On Entry:
                ;  a=Expected (Source) data
                ;  hl=Destination Address
                ;  (hl)=Found data
                ;Trashes psw
                ;************************************
 FB9A C5        MERROR:	push	b
 FB9B F5        	push	psw		;save source data
                
 FB9C CD56FD    	call	CILPRT
 FB9F 3FBA      	db	'?',':'+80H
 FBA1 CD01FD    	call	PHLCHX		;Print address in hl on console,
                				;..trash c, set b=0
                
 FBA4 CD5BFD    	CALL	ILPRNT
 FBA7 2045787065	db	' Expected',' '+80H
                
 FBB1 F1        	pop	psw		;recover source data
 FBB2 CD44FE    	call	PAHEX
                
 FBB5 CD5BFD    	call	ILPRNT
 FBB8 2C20726561	db	', read',' '+80H
 FBBF 7E        	mov	a,m		;Get destination data
 FBC0 CD44FE    	call	PAHEX
                
 FBC3 C1        	pop	b
                
                ;Fall into CKPAUS
                
                ;***Subroutine*******************************
                ;Get a keyboard character, abort if control-C
                ;pause (until anything else typed) if space
                ;On Exit:
                ;  a=keyboard character, Z cleared
                ;********************************************
 FBC4 CD73FD    CKPAUS:	call	CHKKBD		;Abort or pause?
                
 FBC7 FE20      	cpi	PAUKEY		;Pause?
 FBC9 C0        	rnz
                
                ;Fall into GETKBD and wait for any key to end pause
                
                ;***Subroutine*******************************
                ;Get a keyboard character, abort if control-C
                ;On Exit:
                ;   a=keyboard character, Z cleared
                ;********************************************
 FBCA CD73FD    GETKBD:	call	CHKKBD		;get KBD character, test for ^C
 FBCD CACAFB    	jz	GETKBD		;wait for character
                
 FBD0 C9        	ret
                
                ;***Subroutine*********************************************
                ;Read a command line from the keyboard, echoing and saving
                ;it in the input line buffer
                ;
                ;CR input ends the sequence. the CR is not saved in the
                ;input line buffer. instead, the line is terminated with 0.
                ;
                ;On Exit:
                ;  complete command line is in the input line buffer
                ;  de=address of the first non-blank character on the line
                ;  a = first non-blank value found
                ;  Z set if nothing but spaces found
                ;**********************************************************
 FBD1 3EB0      GETLIN:	mvi	a,LINBUF
 FBD3 CDEBFF    	call	HRMPAG		;find line buffer, push h
                
 FBD6 E5        	push	h		;save input line buffer'S
                				;..start address
                
                ;Get & echo characters, stashing them in the input line buffer
                ;at hl, until a CR is encountered
 FBD7 CD1DFD    GLLOOP:	call	LBCHR		;get kbd chr into line buffer
                				;with echo
                
 FBDA D60D      	sui	CR		;end of line from user?
 FBDC C2D7FB    	jnz	GLLOOP		;n: get another chr
                
 FBDF 2B        	dcx	h		;back up to CR
 FBE0 77        	mov	m,a		; overwrite CR with null
                
 FBE1 CD5BFD    	call	ILPRNT		;linefeed to follow CR
 FBE4 8A        	db	LF+80h
                
 FBE5 D1        	pop	d		;input line buffer address
 FBE6 E1        	pop	h		;Restore original hl
                
                ;Fall into SSPACE to skip initial spaces
                
                ;***Subroutine****************************
                ;Scan past spaces, looking for the first
                ;non-space character
                ;
                ;On Entry:
                ;  de=address within the input line buffer
                ;On Exit:
                ;  a=0 and Z set if none found
                ;  a=character value and Z clear if found
                ;*****************************************
 FBE7 1A        SSPACE:	ldax	d		;get next character
 FBE8 B7        	ora	a		;terminating null?
 FBE9 C8        	rz
                
 FBEA FE20      	cpi	' '		;another space?
 FBEC C0        	rnz			;we're past them
                
 FBED 13        	inx	d		;next scan address
 FBEE C3E7FB    	jmp	SSPACE		;keep skipping
                
                ;===Assembly Check================================
                ; The above code must not overrun the next section
                ;=================================================
 FBF1 =         H0END	equ	$
                
                 if (HDBADR - H0END)/256
                	ERROR: HDBL is overwriting prior code
                 endif
                
                ;==============================================================
                ; Hard Disk Boot Loader Subsystem (HDBL)
                ;
                ; The standard 88-HDSK system uses a Pertec D3422 disk drive,
                ; which contains 2 platters - one is in a removable cartridge,
                ; the other is a fixed platter. (However, The 88-HDSK
                ; controller can actually support up to 4 platters, supporting
                ; the Pertec D3462 disk drive, which has one removable
                ; platter, and 3 fixed platters.)
                ;
                ; There are 24 256-byte sectors per track, and these are
                ; numbered 0 through 23 on each track. Each platter has 2
                ; sides, numbered 0 and 1. Data on each platter is organized as
                ; a sequence of Disk Pages, where each Page is one sector.
                ; Pages are numbered sequentially starting at 0 (on track 0,
                ; side 0), through the 24 sectors on track 0, side 0, and then
                ; on to track 0, side 1, where sector 0 is page 24.  Page 47 is
                ; the first sector on track 1, side 0, and page numbering
                ; continues this way through all the tracks.
                ;
                ; Page 0 (which is track 0, side 0, sector 0) is the Pack
                ; Descriptor Page, containing various information about the
                ; particular disk platter. Bytes 40-43 of this Page are the
                ; "Opsys Pointers." Bytes 40 & 41 are the Page number of the
                ; starting boot Page, Bytes 42 & 43 are the number of Pages to
                ; load during boot. HDBL assumes that the boot file is to be
                ; loaded into memory starting at address 0000, and executed
                ; there.
                ;==============================================================
 FC00           	org HDBADR
                
                ;==============================================================
                ; Entry here to execute HDBL directly, to boot from a hard
                ; disk. This is the same address where my HDBL PROM starts.
                ;==============================================================
 FC00 0106FC    HDBL:	lxi	b,HDBRET	;return address
 FC03 C303F8    	jmp	INIT		;go find a real stack
                				;and initialize ACIAs
                				;returns with e=0
                
 FC06 6B        HDBRET:	mov	l,e		;boot from platter 0
                
                ;Fall into HBCMD
                
                ;***Command Routine*****
                ;HB  Boot from hard disk
                ;On Entry:
                ;  l<0> = platter
                ;***********************
                HBCMD:	
                 if EPROM32
 FC07 7D                mov	a,l
 FC08 E601      	ani	1		;just the lsb
 FC0A 0F        	rrc			;Platter goes in bits <7:6>
 FC0B 0F        	rrc			;..which is CFPLTR
 FC0C 57                mov     d,a             ;d<7:6>=platter bits
                 endif
                ;-------------------------------------- 
                ;Initialize 88-HDSK interface board
                ;(Actually ports 0 and 1 of an 88-4PIO)
                ;--------------------------------------
                
 FC0D AF                xra	a
 FC0E 67                mov     h,a
 FC0F 6F                mov     l,a
                        
 FC10 D3A0      	out	0A0h		;Select port 0Ah DDR 
 FC12 D3A2      	out	0A2h		;Select port 0Bh DDR
 FC14 D3A4      	out	0A4h		;Select port 1Ah DDR
 FC16 D3A6      	out	0A6h		;Select port 1Bh DDR
 FC18 D3A1      	out	0A1h		;Port 0Ah is an input port
 FC1A D3A5      	out	0A5h		;Port 1Ah is an input port
                
 FC1C 2F        	cma
 FC1D D3A3      	out	0A3h		;Port 0Bh is an output port
 FC1F D3A7      	out	0A7h		;Port 1Bh is an output port
                
 FC21 3E2C      	mvi	a,CINIT		;set up input port handshakes
 FC23 D3A0      	out	0A0h
 FC25 D3A4      	out	0A4h
 FC27 D3A6      	out	0a6h		;output port 1Bh handshakes
                
 FC29 3E24      	mvi	a,BINIT		;set up port 0Bh handshakes
 FC2B D3A2      	out	0A2h
                
 FC2D DBA1      	in	CSTAT		;clear Controller Ready bit
                
                ;-----------------------------------------------
                ;Read the Pack Descriptor Page (Disk Page 0)
                ;to get the Opsys Pointers:
                ;  Bytes 41:40 = Initial Disk Page number
                ;  Bytes 43:42 = Disk Page count (Byte 43=MSB=0)
                ;On Entry:
                ;  d = platter in bits <7:6>, bits <5:0>=0
                ;  hl = 0
                ;-----------------------------------------------
                
 FC2F 3E2B              mvi     a,OSOFF+3       ;byte count to end of pointers
 FC31 5F                mov     e,a             ;...into e
                 if EPROM32
 FC32 B2                ora     d               ;add in platter bits
                 endif
 FC33 47                mov     b,a             ;...into b
 FC34 CD56FC    	call	GETPAG		;Seek, read page hl platter b<7:6> 
                                                ;into buffer, set up to read b<5:0> 
                                                ;buffer bytes
                
                ;Read from the controller buffer and discard everything until
                ;we get to the opsys pointers. Load the opsys pointers into
                ;c & hl. Note: no testing any handshake here - just assume
                ;the controller can keep up. (The controller can send a data
                ;byte every 2.5 uS.) This only reads the low byte of the
                ;page count, since the high byte must be 0 anyway.
 FC37 DBA5      PTRLUP:	in	CDATA		;read byte from controller
                
 FC39 6C        	mov	l,h		;shift everybody over...
 FC3A 61        	mov	h,c
 FC3B 4F        	mov	c,a		;...and put it away
                
 FC3C 1D        	dcr	e
 FC3D C237FC    	jnz	PTRLUP
                
                        
                ;-------------------------------------------------
                ;Read c Pages from disk, starting at Page hl, into
                ;memory starting at the address on the stack
                ;On Entry:
                ;  c = page count
                ;  d = platter in bits <7:6>, bits <5:0>=0
                ;  e = 0
                ;  hl = initial Disk page number
                ;-------------------------------------------------
                
                 if EPROM32
 FC40 42                mov     b,d             ;b=platter bits
                 endif
                 if not EPROM32
                        mov     b,e             ;b=0
                 endif        
 FC41 53        	mov	d,e		;set load/exec address to 0
 FC42 D5        	push	d		;execution address on stack
                        
 FC43 CD56FC    PAGELP:	call	GETPAG		;Seek, read page hl platter b<7:6> 
                                                ;into buffer, set up to read b<5:0> 
                                                ;buffer bytes
                
                ;Load 256 bytes of buffer data into memory at de
                ;Note: no testing any handshake here - just assume the
                ;controller can keep up. (The controller can send a data byte
                ;every 2.5 uS.)
 FC46 DBA5      BYTELP:	in	CDATA		;get a data byte
 FC48 12        	stax	d		;write it to RAM
 FC49 1C        	inr	e		;write entire page
 FC4A C246FC    	jnz	BYTELP		;until done
                
                ; Next Disk Page
 FC4D 14        	inr	d		;next RAM page
 FC4E 23        	inx	h		;Next Disk Page
 FC4F 0D        	dcr	c		;bump Disk Page count
 FC50 C243FC    	jnz	PAGELP
                
                ;---------------------------------------------------
                ;Go execute loaded code, at the address on the stack
                ;On Entry:
                ;  c = 0
                ;---------------------------------------------------
 FC53 C37BFA    	jmp	EXECDP		;disable PROM,
                				;go execute loaded code
                
                ;***Subroutine***************************************
                ;Seek and read disk Page hl into 88-HDSK buffer 0
                ;On Entry:
                ;  b<7:6>=platter
                ;  b<5:0>=number of bytes to transfer (0 means 256)
                ;On Exit:
                ;  a,flags trashed, all others preserved
                ;  Controller has specified sector data in its buffer
                ;****************************************************
 FC56 E5        GETPAG:	push	h		;Save requested Page
 FC57 D5        	push	d		;Save regs
 FC58 C5        	push	b		;save byte count
                
                ;----------------------------------------------------------
                ;Compute cylinder and sectorX2  from Disk Page number in hl
                ; hl := hl / (2*HDSPT) (Quotient=cylinder)
                ;  a := hl MOD (2*HDSPT) (Remainder=sectorx2)
                ;This is fast only if the cylinder number is low. MITS
                ;usually put the boot image starting at cylinder 0, side 1.
                ;But we will always miss the next sector anyway, so each
                ;sector will require a full disk rev (25 mS), lots of time.
                ;----------------------------------------------------------
 FC59 01D0FF    	lxi	b,-2*HDSPT
 FC5C 50        	mov	d,b		;de=FFFF=-1
 FC5D 58        	mov	e,b		;since loop goes 1 extra
                
 FC5E 13        DIV1:	inx	d		;compute quotient=cylinder
 FC5F 09        	dad	b		;hl gets remainder
 FC60 DA5EFC    	jc	DIV1
                
 FC63 7D        	mov	a,l		;fix remainder, since
 FC64 91        	sub	c		;..loop went 1 extra
                
 FC65 EB        	xchg			;cylinder number to hl
                
                ;--------------------------------------------------
                ;Compute Sector & Side
                ;If sectorX2 > sectors/track then set CSIDE
                ;bit, and reduce sector number by sectors/track
                ;  hl= Quotient (cylinder)
                ;  a = Remainder (sectorX2, either for head 0 or 1)
                ;--------------------------------------------------
 FC66 FE18      	cpi	HDSPT		;past end of side 0?
 FC68 DA6DFC    	jc	SIDEOK		;N: sector number is good
                
 FC6B C608      	adi	CSIDE-HDSPT	;Compute sector mod HDSPT,
                				;..and set side 1 bit
                
 FC6D 57        SIDEOK: mov     d,a             ;save sector # with side
                        
                ;------------------------------------------
                ;Seek Cylinder
                ;  hl = cylinder number<9:0>
                ;------------------------------------------
                 if CSEEK+DBUFR			;these are actually 00
                	mov	a,h		;h<1:0>=cylinder<9:8> 
                	ori	CSEEK+DBUFR	;combine with SEEK operation
                	mov	h,a
                 endif
                
 FC6E CD8BFC    	call	HDSKC		;hl=SEEK command with cyl #
                
                ;---------------------------------------------------------
                ;Read Sector from current track into controller's buffer 0
                ;  d<5> = side
                ;  d<4:0> = sector number
                ;---------------------------------------------------------
 FC71 C1        	pop	b		;b=platter number and byte count
                 if EPROM32
 FC72 78                mov     a,b             ;get into a
 FC73 E6C0              ani     0C0h            ;isolate platter bits <7:6>
 FC75 B2                ora     d               ;add in sector # and side
                 endif        
                 if not EPROM32
                        mov     a,d             ;get sector # and side
                 endif
                        
 FC76 2630              mvi     h,CRDSEC+DBUFR  ;issue Read Sector command
 FC78 CD8CFC    	call	HDSKCA		;low command byte is in a
                
                ;--------------------------------------------
                ;Issue CRDBUF command to kick off read of
                ;256 bytes from the controller's buffer
                ;Note: this assumes the controller is ready.
                ;(and it is, because HDSKC left it that way.)
                ;--------------------------------------------
 FC7B DBA5      	in	CDATA		;reset CDA in CDSTA
 FC7D DBA3      	in	ACMD		;clear CMDACK in ACSTA
                
 FC7F 78        	mov	a,b             ;a=platter number and byte count
                 if EPROM32
 FC80 E63F              ani     3Fh             ;isolate byte count (bits <5:0>)
                 endif        
 FC82 D3A7      	out	ADATA		;..to controller
                
 FC84 3E50      	mvi	a,CRDBUF+DBUFR	;issue Read Buffer command
 FC86 D3A3      	out	ACMD		;..to controller
                
 FC88 D1        	pop	d		;(10)
 FC89 E1        	pop	h		;(10) 15 uS total from 'out'
                
                ;The 8x300 is ready to transmit data in 8 uS. This code takes
                ;40 cycles (including the 'ret'), or 20 uS min to get around
                ;to reading the data - so there is no need to wait on CDSTA
                 if FALSE
                DATAWT:	in	CDSTA		;Wait for data port to be ready
                	rlc			;msb=CDA
                	jnc	DATAWT
                 endif
                
                ;---------------------------------
                ;Controller is ready to transfer
                ;256 bytes of data from its buffer
                ;---------------------------------
 FC8A C9        	ret			;(10)done with GETPAG
                
                ;***Subroutine************************************************
                ;Issue a disk command, and then wait for the controller
                ;to complete it
                ;
                ;Note: this just assumes the controller is ready, which is OK
                ;since the last command was either a seek (where HDSKC waited
                ;for the controller to become ready) or it was a CRDBUF, which
                ;ended with all bytes transferred - and the controller becomes
                ;ready very soon (1.5 uS) after the last byte is transferred.
                ;On Entry at HDSKC:
                ;  hl = complete command
                ;On Entry at HDSKCA:
                ;  a=low byte of command
                ;  h=high byte of command
                ;On Exit:
                ;  a,flags trashed, all others preserved.
                ;  The command is completed and the controller is ready.
                ;  Any errors will terminate the load, and print an error
                ;  message on the Terminal 
                ;*************************************************************
 FC8B 7D        HDSKC:	mov	a,l		;low byte of command
                
 FC8C D3A7      HDSKCA:	out	ADATA		;..to data port
                
 FC8E DBA1      	in	CSTAT		;reset CRDY flag just in case
 FC90 DBA3      	in	ACMD		;clear CMDACK in ACSTA
                
 FC92 7C        	mov	a,h		;command high byte
 FC93 D3A3      	out	ACMD		;issue command
                
 FC95 DBA0      HDWAIT:	in	CREADY		;Is the controller done? 
 FC97 07        	rlc			;look at msb=CRDY
 FC98 D295FC    	jnc	HDWAIT		;N: keep waiting
                
 FC9B DBA1      	in	CSTAT		;reset CRDY flag
 FC9D E67F      	ani	ERMASK		;and get A=error code
 FC9F C8        	rz			;No errors: happy return
                
                ; Report a load error and go to AMON's main loop
                ; On Entry:
                ;   a = error flag bits
                ;  hl = disk command
 FCA0 CD3EFE    	call	PCAHEX		;print error code in hex
 FCA3 C3D7FF    	jmp	HDERR		;finish the error message
                
                ;***Command Routine***************************************
                ;HL [<OFST>] (Intel hex load from transfer port)
                ;
                ;Load an Intel hex file from the Transfer Port into memory
                ;at the addresses specified in the hex file, with optional
                ;address offset <OFST>. done when any record with 0 data
                ;bytes is encountered, or if control-C is typed.
                ;
                ;print a pacifier dot for each record unless the transfer
                ;port is the same as the console
                ;
                ;On Entry:
                ;  hl= address offset from user (defaults to 0)
                ;
                ;register usage during hex load:
                ;  b: Scratch
                ;  c: record byte counter
                ;  d: record checksum
                ;  e: record byte count for EOF test
                ;  hl: memory address
                ;  Top of stack: address offset
                ;  Next on stack: record count
                ;*********************************************************
 FCA6 E5        HLCMD:	push	h		;address offset onto stack
                
 FCA7 210000    	lxi	h,0		;initialize record count
 FCAA E5        	push	h		;onto stack too
                
                ;Eat all characters until we get record-start colon
 FCAB CD85FD    GETCOL:	call	GETTPD
 FCAE E67F      	ani	7Fh		;strip parity
 FCB0 D63A      	sui	':'
 FCB2 C2ABFC    	jnz	GETCOL
                
 FCB5 57        	mov	d,a		;d=0: Init checksum
                
                 if EPROM32
 FCB6 CD16F1    	call	PACIFY
                 endif ;EPROM32
                
                 if not EPROM32
                	call	ILPRNT		;print a pacifier per record
                	db	PCFIER+80h
                 endif ;not EPROM32
                
                ;Restart checksum, then get 4-byte record header: (a=0 here)
                ; c gets 1st byte = data byte count
                ; h gets 2nd byte = address high byte
                ; l gets 3rd byte = address low byte
                ; b gets 4th byte = record type (ignored)
                
 FCB9 1E04      	mvi	e,4		;get 4 header bytes
                
                ;Shift in the four header bytes: c <- h <- l <- b
 FCBB 4C        HEDRLP:	mov	c,h		;c=byte 1: byte count
 FCBC 65        	mov	h,l		;h=byte 2: address MSB
 FCBD 68        	mov	l,b		;l=byte 3: address LSB
 FCBE CDA7FD    	call	GETTPH		;get header byte, do checksum
 FCC1 1D        	dcr	e
 FCC2 C2BBFC    	jnz	HEDRLP
                
                ;Offset the address by the value on top of the stack
                ;and bump the record count. a=checksum so far here
 FCC5 D1        	pop	d		;get offset
 FCC6 19        	dad	d		;offset the address in hl
                
 FCC7 E3        	xthl			;bump record count
 FCC8 23        	inx	h
 FCC9 E3        	xthl			;..leaving it on the stack
                
 FCCA D5        	push	d		;save offset
                
 FCCB 57        	mov	d,a		;d=checksum so far
 FCCC 59        	mov	e,c		;remember count for EOF test
                
                ;c = e = record byte count
                ;hl = RAM address for this record=record address+offset
 FCCD 79        	mov	a,c		;c=record byte count
 FCCE B7        	ora	a		;0-byte record?
 FCCF CAE9FC    	jz	GETCSM
                
                ;Loop to get data into memory at hl.
                
 FCD2 CDA7FD    DATALP:	call	GETTPH		;data byte in b, cksm in d
                
                ;See if this byte will overwrite our RAM area. This blocks
                ;out a 256-byte region of memory wherever this program found
                ;RAM for its stack.
 FCD5 CDEBFF    	call	HRMPAG		;(stuffs hl on stack)
 FCD8 7C        	mov	a,h		;a=RAM page address
 FCD9 E1        	pop	h		;restore RAM address
 FCDA BC        	cmp	h		;same as AMON's RAM page?
 FCDB CA67FF    	jz	OVRERR		;y:abort with overwrite error
                
                ;Write to memory, and verify the write
 FCDE 70        	mov	m,b		;store data in RAM
 FCDF 7E        	mov	a,m
 FCE0 B8        	cmp	b
 FCE1 C2CEFF    	jnz	MEMERR		;successful write?
 FCE4 23        	inx	h
                
 FCE5 0D        	dcr	c
 FCE6 C2D2FC    	jnz	DATALP
                
 FCE9 CDA7FD    GETCSM:	call	GETTPH		;get checksum in a & Z flag
 FCEC C2CBFF    	jnz	CSMERR		;should be zero
                
                ;All done with this record. Check for EOF (byte count=0)
 FCEF B3        	ora	e		;zero-byte record?
 FCF0 C2ABFC    	jnz	GETCOL		;N: go get another record
                
                ;-------------------------------------------
                ;Done. Print record count and return to MAIN
                ;-------------------------------------------
 FCF3 E1        HLDONE:	pop	h		;remove offset from stack
 FCF4 E1        	pop	h		;record count
                
 FCF5 CD56FD    	call	CILPRT
                
                 if EPROM32
 FCF8 5265636F72	db	'Records:',' '+80h
                 endif ;EPROM32
                 if NOT EPROM32
                	db	'Recs:',' '+80h
                 endif ;NOT EPROM32
                
                ;Fall into PHLCHX
                
                ;***Subroutine**************************
                ;Print hl as 4 hex digits on the console
                ;On Entry:
                ;  c=checksum so far
                ;  hl=2 bytes to print
                ;On Exit:
                ;  b=0
                ;  c=updated checksum
                ;Trashes a
                ;Stack depth: 6
                ;****************************************
 FD01 0600      PHLCHX:	mvi	b,0	;print on console
 FD03 C338FE    	jmp	PHLHEX
                
                ;***Command Routine**************************************
                ;EN [<ADR>] (enter data into memory)
                ;
                ;Get hex values from the keyboard and enter them
                ;sequentially into memory, starting at <ADR>. a blank
                ;line ends the routine and returns control to the
                ;command Mode. values may be separated by spaces or CR'S.
                ;Print the current address at the beginning of each line.
                ;On Entry:
                ;  hl = <ADR>, defaulting to 0
                ;  Carry set if none entered
                ;********************************************************
 FD06 CD60FE    ENCMD:	call	PHLADR		;print hl as an address
                
 FD09 CDD1FB    	call	GETLIN		;get a line of user input
 FD0C C8        	rz			;z=blank line terminates
                
                ;Get hex data from the user input line and write it to memory
 FD0D CD18F9    ENLOOP:	call	PHFHEX		;save memory address,
                				;Get/convert value
                
 FD10 7D        	mov	a,l		;get low byte as converted
 FD11 E1        	pop	h		;recover memory address
                
 FD12 77        	mov	m,a		;put in the value
 FD13 23        	inx	h		;next address
                
 FD14 CDE7FB    	call	SSPACE		;Scan to next input value
 FD17 C20DFD    	jnz	ENLOOP		;not end of line: continue
                
 FD1A C306FD    	jmp	ENCMD		;end of line: start new line
                
                ;===============
                ;= subroutines =
                ;===============
                
                ;***Subroutine*********************************************
                ;Get, echo, and store a console character in the input
                ;line buffer. Handle deletes and backspaces.
                ;
                ;On Entry:
                ;  hl = next free spot in the input line buffer
                ;  LBSIZE is max characters allowed in the input line buffer
                ;On Exit (not full, no deletes):
                ;  a=character
                ;  hl = hl+1
                ;  (hl-1) = character
                ;**********************************************************
 FD1D CDCAFB    LBCHR:	call	GETKBD		;get a character
 FD20 77        	mov	m,a		;store character in buffer
                
 FD21 FE7F      	cpi	DEL		;DEL character?
 FD23 CA28FD    	jz	GCDEL
 FD26 FE08      	cpi	BS		;BS is same as DEL
 FD28 7D        GCDEL:	mov	a,l		;buffer address low byte
 FD29 CA34FD    	jz	GDELET
                
 FD2C EEFE      	xri	LINBUF+LBSIZE-2	;input buffer full?
 FD2E 7E        	mov	a,m		;recover chr for echo
 FD2F C8        	rz			;full: ignore it
                
 FD30 23        	inx	h		;bump line buffer pointer
                
 FD31 C38BF8    	jmp	PRINTA		;echo & ret
                
                ;-----------------------------------------------------------
                ;Backspace or delete found. Delete if there is anything to
                ;delete, and echo to the user the right way, based on TTYPE.
                ;-----------------------------------------------------------
 FD34 D6B0      GDELET:	sui	LINBUF		;anything on the line?
 FD36 C8        	rz			;done if not.
                
                ;backspace either by erasing onscreen or Teletype-style
 FD37 2D        	dcr	l		;back up in buffer
                
 FD38 3E42      	mvi	a,TTYPE-RIOCOD+RAMCOD
 FD3A CDEBFF    	call	HRMPAG		;pushes hl too
 FD3D 7E        	mov	a,m		;get TTYPE variable
 FD3E E1        	pop	h
 FD3F 1F        	rar			;0 (even): backspacing terminal
 FD40 D24FFD    	jnc	GCBKUP
                
                ;Teletype-style delete
 FD43 CD4AFD    	call	PSLASH		;print deleted character
                
 FD46 7E        	mov	a,m		;..between slashes
 FD47 CD8BF8    	call	PRINTA
                
                ;Fall into PSLASH
                
                ;---Local Subroutine---
                ;Print a slash
                ;----------------------
 FD4A CD5BFD    PSLASH:	call	ILPRNT
 FD4D AF        	db	'/'+80h
 FD4E C9        	ret
                
                ;Terminal-style delete
 FD4F CD5BFD    GCBKUP:	call	ILPRNT		;back up on screen
 FD52 082088    	db	BS,' ',BS+80h	;Erase old character & back up
                
 FD55 C9        	ret
                
                ;***Subroutine*****************************
                ;Print CR LF then inline string at (sp)
                ;Calls to CILPRT are followed by the string
                ;the last string byte has its MSB set
                ;On Exit:
                ;  a = 0
                ;  Z & Carry cleared
                ;  all other registers preserved
                ;******************************************
 FD56 CD5BFD    CILPRT:	call	ILPRNT
 FD59 0D8A      	db	CR,LF+80h
                
                ;Fall into ILPRNT
                
                ;***Subroutine*****************************
                ;Print inline string at (SP)
                ;calls to ILPRNT are followed by the string
                ;the last string byte has its MSB set
                ;On Exit:
                ;  a = 0
                ;  Z & Carry cleared
                ;  all other registers preserved
                ;******************************************
 FD5B E3        ILPRNT:	xthl			;save hl, get string address
                
 FD5C 7E        IPLOOP:	mov	a,m		;loop through message
 FD5D E67F      	ani	7Fh		;strip end-marker
 FD5F CD8BF8    	call	PRINTA
 FD62 AE        	xra	m		;end? (clears Carry too)
 FD63 23        	inx	h
 FD64 CA5CFD    	jz	IPLOOP
                
 FD67 AF        	xra	a		;for return
 FD68 E3        	xthl			;restore hl
                				;..get ret address
 FD69 C9        	ret
                
                ;***Subroutine****************************
                ;Get console keyboard data
                ;On Entry:
                ;  A keyboard character is already waiting
                ;On Exit:
                ;  a=keyboard character, parity stripped
                ;  Z clear (unless null typed)
                ;*****************************************
 FD6A DB11      KDATA:	in	CONRXD		;get keyboard character
 FD6C E67F      	ani	7Fh		;strip parity
 FD6E C9        	ret
                
                ;***Subroutine**************************************
                ;Get keyboard status unless the transfer port is the
                ;console. Abort if CABKEY (control-C) or CBKEY2
                ;(ESCAPE).
                ;On Exit:
                ;  if a character is waiting, then character is in a
                ;  if no character waiting, Z set, a=0
                ;***************************************************	
 FD6F CD9DFD    CKABRT:	call	TESTTP		;Transfer Port = console?
 FD72 C8        	rz
                
                ;Fall into CHKKBD
                
                ;***Subroutine**************************************
                ;Get keyboard status. If a character is waiting,
                ;then return it in a with parity stripped. Abort
                ;if CABKEY (control-C) or CBKEY2 (ESCAPE).
                ;On Exit:
                ;  if a character is waiting, then character is in a
                ;  if no character waiting, Z set, a=0
                ;***************************************************	
 FD73 CD82F8    CHKKBD:	call	KSTAT		;anything typed?
 FD76 C8        	rz			;N: return w/ Z set
                
 FD77 CD6AFD    	call	KDATA		;Y: get the data
 FD7A FE03      	cpi	CABKEY		;abort character typed?
                
                 if EPROM32
 FD7C CAE0F8    	jz	MAIN
 FD7F FE1B      	cpi	CBKEY2		;Other abort character
                 endif ;EPROM32
                
 FD81 C0        	rnz
                
 FD82 C3E0F8    	jmp	MAIN
                
                ;***Subroutine******************************************
                ;Check for abort from the console (unless the transfer
                ;port is the console), and then get a printable ASCII
                ;byte from the Transfer Port.
                ;On Entry:
                ;  SP points into the RAM page
                ;  RAM code is in place
                ;On Exit:
                ;  character in a
                ;Stack depth: 6
                ;*******************************************************
 FD85 CD9DFD    GETTPD:	call	TESTTP		;Transfer Port = Console?
 FD88 C473FD    	cnz	CHKKBD		;No. User abort?
                
 FD8B CD98FD    	call	TPISTA		;Transfer Port character?
 FD8E CA85FD    	jz	GETTPD		;n: keep waiting
                
                ;Fall into TPIN
                
                ;***Subroutine**********************
                ;Get Transfer Port data immediately
                ;On Exit:
                ;  a=byte from Transfer Port
                ;  Z cleared
                ;***********************************
 FD91 3E32      TPIN:	mvi	a,RTPIN-RIOCOD+RAMCOD
                
                ;Fall into GORAM
                
                ;***Subroutine****************
                ;Execute RAM code
                ;On Entry:
                ;  a=RAM code address low byte
                ;*****************************
 FD93 CDEBFF    GORAM:	call	HRMPAG		;pushes h
                
 FD96 E3        	xthl			;fix hl, put address on stack
 FD97 C9        	ret			;'call' code ppointe to by a
                
                ;***Subroutine**************
                ;Get Transfer Port Rx status
                ;On Exit:
                ;  a=0 & Z set if no data
                ;***************************
 FD98 3E2C      TPISTA:	mvi	a,RTPIS-RIOCOD+RAMCOD
 FD9A C393FD    	jmp	GORAM		;recycle some code
                
                ;***Subroutine*************************
                ;Test to see if Transfer Port = console
                ;On Exit:
                ;  Z set if console = Transfer Port
                ;Trashes a
                ;Stack depth: 4
                ;**************************************
 FD9D 3E2D      TESTTP:	mvi	a,TPISP+1-RIOCOD+RAMCOD	;status register addr
 FD9F CDEBFF    	call	HRMPAG			;pushes h
                
 FDA2 7E        	mov	a,m
 FDA3 E1        	pop	h
                
 FDA4 FE10      	cpi	CONSTA			;Console's status port?
 FDA6 C9        	ret
                
                ;***Subroutine****************************************
                ;Get 2 hex digits from the Transfer Port, combine them
                ;into 1 byte, and add the result to the checksum in d
                ;On Entry:
                ;  d = checksum so far
                ;On Exit:
                ;  b=byte of data
                ;  a=d=new checksum value
                ;  Z flag set if checksum is now 0
                ;  all other registers preserved, unless error abort
                ;*****************************************************
 FDA7 CDB7FD    GETTPH:	call	GETTPN		;get high nibble
 FDAA 87        	add	a		;Shift high nibble in place
 FDAB 87        	add	a
 FDAC 87        	add	a
 FDAD 87        	add	a
 FDAE 47        	mov	b,a
 FDAF CDB7FD    	call	GETTPN		;get low nibble
                
 FDB2 B0        	ora	b		;combine nibbleS
 FDB3 47        	mov	b,a		;save result for return
 FDB4 82        	add	d		;compute checksum
 FDB5 57        	mov	d,a		;ret with checksum in a & d
 FDB6 C9        	ret
                
                ;---Local subroutine--------------------
                ;Get a hex digit from the Transfer Port,
                ;validate it, and return it in A<3:0>
                ;---------------------------------------
 FDB7 CD85FD    GETTPN:	call	GETTPD
 FDBA E67F      	ani	7Fh		;strip parity
 FDBC CD6EFE    	call	HEXCON
 FDBF D8        	rc			;Carry means OK
                
                ;Abort: ASCII character error - not a valid hex digit
 FDC0 3E48      	mvi	a,HERMSG
 FDC2 C3D0FF    	jmp	RPTERR
                
                ;==================================================
                ; Command Table
                ; Each entry:
                ;   Byte 0 = 1st command character
                ;   Byte 1 = 2nd command character
                ;   Byte 2 = command execution address low byte
                ;   Byte 3<6:0> = command execution address<14:8>
                ;                 (address<15> is assumed to be 1)
                ;   Byte 3<7> = 0 if the command's parameters are
                ;               not hexidecimal values
                ;
                ; The table is terminated by a null in Byte 0
                ;==================================================
                
                ;Table is in lower half of 2732 EPROM
                 if EPROM32
 FDC5 =         H1END	equ	$
 F000           	org MON32A
                 endif ;EPROM32
                
 F000 4144      COMTAB:	db	'AD'		;Dump in Altair format
 F002 3FF9      	dw	ADCMD
 F004 414C      	db	'AL'		;Load Altair format
 F006 06FE      	dw	ALCMD
                
 F008 424F      	db	'BO'		;Boot from FLOPPY
 F00A 06FF      	dw	BOCMD
 F00C 434F      	db	'CO'		;Copy memory
 F00E 90F9      	dw	COCMD
 F010 4455      	db	'DU'		;Dump to console
 F012 89FA      	dw	DUCMD
 F014 454E      	db	'EN'		;Enter
 F016 06FD      	dw	ENCMD
 F018 4558      	db	'EX'		;Execute
 F01A 76FA      	dw	EXCMD
 F01C 4649      	db	'FI'		;Fill memory
 F01E D2FA      	dw	FICMD
                
 F020 4842      	db	'HB'		;Boot from hard disk
 F022 07FC      	dw	HBCMD
                
 F024 4844      	db	'HD'		;Intel hex dump
 F026 36FB      	dw	HDCMD
 F028 484C      	db	'HL'		;Intel hex load
 F02A A6FC      	dw	HLCMD
                
 F02C 494E      	db	'IN'		;Input from port
 F02E 28FE      	dw	INCMD
 F030 4F54      	db	'OT'		;Output to port
 F032 24FB      	dw	OTCMD
                
 F034 5345      	db	'SE'		;Search
 F036 E0F9      	dw	SECMD
                
 F038 5445      	db	'TE'		;Terminal Mode
 F03A EB7A      	dw	TECMD and 7FFFh ;non-hex parameter
                
 F03C 5450      	db	'TP'		;Set Transfer Port
 F03E 4DF8      	dw	TPCMD
 F040 5454      	dw	'TT'		;Terminal Type
 F042 6EFA      	dw	TTCMD
                
 F044 5645      	db	'VE'		;Verify
 F046 C6F9      	dw	VECMD
                
                 if EPROM32
 F048 4D54      	db	'MT'		;Memory test
 F04A 51F0      	dw	MTCMD
                
 F04C 3F00      	db	'?',0		;Help command
 F04E 6771      	dw	HLPCMD and 7FFFh ;non-hex parameter
                 endif ;EPROM32
                
 F050 00        	db	0		;end of table mark
                
                ;=======================================================
                ;The following code is in the lower half of a 2732 EPROM
                ;=======================================================
                
                 if EPROM32
                
                ;***2732 Command Routine**********************************
                ;MT [<ADR> [<CNT>]] (Test Memory)
                ;
                ;On Entry:
                ;  Carry set if no parameters provided
                ;  hl=<ADR>
                ;  de points to <CNT>
                ; On Entry:
                ;  hl = <ADR>, defaulting to 0
                ;  Carry set if none entered
                ;*********************************************************
 F051 CD18F9    MTCMD:	call	PHFHEX		;push <ADR>, get hl=<CNT>
                				;hl=0 if none entered
 F054 CD56FD    	call	CILPRT
 F057 5465737469	db	'Testin','g'+80h
                
 F05E EB        	xchg			;de=byte count
 F05F CDEDFF    	call	RAMPAG		;get our RAM page
                				;..and clear carry
 F062 7C        	mov	a,h		;a=AMON's RAM page
                
 F063 E1        	pop	h		;hl=start address
                
 F064 01F8F0    	lxi	b,MTPAT		;Test pattern sequence
                
 F067 F5        	push	psw		;a=RAM page, carry is clear
                				;..indicating no errors (yet)
                
                ;-----------------------------------------------------------
                ;Loop until all memory locations have seen each pattern byte
                ;
                ;Throughout this loop, the carry flag in the psw word that's
                ;on the stack is set if any error is ever found.
                ;-----------------------------------------------------------
 F068 F1        MTLOOP:	pop	psw		;RAM page, error state
 F069 E5        	push	h		;Start address
 F06A D5        	push	d		;Byte count
 F06B C5        	Push	b		;Pattern position
 F06C F5        	push	psw		;a=RAM page, carry=error state
                	
                ;------------------------------------------------
                ;Fill memory with pattern, avoiding the stack. Do
                ;a read/invert/write twice to stress the memory.
                ;------------------------------------------------
 F06D F1        FIL0:	pop	psw		;a=RAM page address
 F06E F5        	push	psw		;(and carry=error state)
                
 F06F CDF1F0    	call	SKPSTK		;skip over the stack
 F072 D285F0    	jnc	FIL2		;..if needed
                
 F075 0A        	ldax	b		;Get a pattern byte
                
 F076 B7        	ora	a		;Pattern end?
 F077 C27DF0    	jnz	FIL1
 F07A 01F8F0    	lxi	b,MTPAT		;y: restart pattern
                
 F07D 03        FIL1:	inx	b
                
                ;High-frequency memory byte test while
                ;we fill memory with the pattern
 F07E 77        	mov	m,a		;Write pattern to memory
                
 F07F 7E        	mov	a,m		;Invert & write
 F080 2F        	cma
 F081 77        	mov	m,a
                
 F082 7E        	mov	a,m		;twice
 F083 2F        	cma
 F084 77        	mov	m,a
                
 F085 23        FIL2:	inx	h		;next address
                
 F086 1B        	dcx	d		;byte count
 F087 7A        	mov	a,d		;end?
 F088 B3        	ora	e
 F089 C26DF0    	jnz	FIL0		;n: keep filling
                
 F08C F1        	pop	psw		;RAM page address & error state
 F08D C1        	pop	b		;Pattern position
 F08E D1        	pop	d		;Byte count
 F08F E1        	pop	h		;Start address
                
                ;-------------------------------------------------
                ;Compare memory to the pattern, avoiding the stack
                ;-------------------------------------------------
 F090 E5        	push	h		;Start address
 F091 D5        	Push	d		;Byte count
 F092 C5        	push	b		;Pattern position
 F093 F5        	push	psw		;RAM page address & error state
                
 F094 F1        CMLOOP:	pop	psw		;a=RAM page
 F095 F5        	push	psw		;(and carry=error state)
                
 F096 CDF1F0    	call	SKPSTK		;skip over the stack
 F099 D2D0F0    	jnc	CML2		;..if needed
                
 F09C 0A        	ldax	b		;Get pattern byte
                
 F09D B7        	ora	a		;Pattern end?
 F09E C2A4F0    	jnz	CML1
 F0A1 01F8F0    	lxi	b,MTPAT		;y: restart pattern
                
 F0A4 03        CML1:	inx	b		;next pattern byte
                
 F0A5 BE        	cmp	m		;compare pattern to memory
 F0A6 CAD0F0    	jz	CML2		;OK?
                
                ;-------------------------
                ;Report and remember error
                ;-------------------------
 F0A9 C5        	push	b		;PHLADR trashes bc
 F0AA F5        	push	psw		;a=pattern byte
                
 F0AB CD60FE    	call	PHLADR		;address:
                				;Stack depth: 10
                
 F0AE CD5BFD    	call	ILPRNT
 F0B1 57726F7465	db	'Wrote',' '+80h
                
 F0B7 F1        	pop	psw		;expected data
 F0B8 CD44FE    	call	PAHEX
                
 F0BB CD5BFD    	call	ILPRNT
 F0BE 2C20726561	db	', read',' '+80h
 F0C5 7E        	mov	a,m
 F0C6 CD44FE    	call	PAHEX		;memory data
                
 F0C9 C1        	pop	b
 F0CA CDC4FB    	call	CKPAUS		;Abort or pause from user?
                
 F0CD F1        	pop	psw		;remember error
 F0CE 37        	stc			;..by setting carry in
 F0CF F5        	push	psw		;..the psw on the stack
                
                ;-------------------------------------------
                ;Next RAM location until done with this pass
                ;-------------------------------------------
 F0D0 23        CML2:	inx	h
                
 F0D1 1B        	dcx	d		;next byte count
 F0D2 7A        	mov	a,d		;end?
 F0D3 B3        	ora	e
 F0D4 C294F0    	jnz	CMLOOP
                
                ;-----------------------------------------------
                ;Done with one pass. Print pacifier, test for
                ;abort, and do another pass, unless we are done.
                ;-----------------------------------------------
 F0D7 CD5BFD    	call	ILPRNT		;print pacifier
 F0DA AE        	db	PCFIER+80h
                
 F0DB CD73FD    	call	CHKKBD		;Chance to abort
                
 F0DE F1        	pop	psw		;RAM page & error state
 F0DF C1        	pop	b		;Pattern position
 F0E0 D1        	pop	d		;Byte count
 F0E1 E1        	pop	h		;Start address
                
 F0E2 F5        	push	psw		;RAM page & error state
                
 F0E3 03        	inx	b		;rotate pattern once
 F0E4 0A        	ldax	b		;end of pattern?
 F0E5 B7        	ora	a
 F0E6 C268F0    	jnz	MTLOOP
                
                ;Fall into OKEXIT
                
                ;***Subroutine End**********************
                ;All done. Print 'OK' if we never
                ;saw an error, and then return (to Main)
                ;On Entry:
                ;  Top-of-stack has psw, with carry set
                ;  if any errors found 
                ;***************************************
 F0E9 F1        OKEXIT:	pop	psw		;carry set if ever an error
 F0EA D8        	rc			;to MAIN, without OK
                
 F0EB CD56FD    	call	CILPRT		;no errors: print OK
 F0EE 4FCB      	db	'O','K'+80h
                				;returns with Z cleared
 F0F0 C9        	ret
                
                ;---Local Subroutine----------------------------
                ;SKip over the stack and I/O routines in RAMPAG
                ;On Entry:
                ;  a=RAM page high address byte
                ;  hl = next RAM address to test
                ;On Exit:
                ;  carry clear if hl points to RAM used by AMON
                ;Trashes a
                ;-----------------------------------------------
 F0F1 BC        SKPSTK:	cmp	h		;on the RAM page?
 F0F2 37        	stc			;in case we return
 F0F3 C0        	rnz			;n: done, z clear
                
 F0F4 3EAF      	mvi	a,STACK-1	;top of stack
 F0F6 BD        	cmp	l		;above the stack?
 F0F7 C9        	ret			;carry set if yes
                
                ;--------------------------------------
                ;Memory Test Pattern Sequence
                ;Deliberately a prime number of bytes.
                ;The first byte may be 0. The last byte
                ;must be 0. No other bytes may be 0.
                ;--------------------------------------
 F0F8 00FF55AA33MTPAT:	db	000h,0FFh,055h,0AAh,033h,0CCH,0F0h,00Fh
 F100 C33C669978	db	0C3h,03CH,066h,099h,078h,001h,0FEh,002h
 F108 FD04FB08F7	db	0FDH,004h,0FBh,008h,0F7h,010h,0EFh,020h
 F110 FD40BF807F	db	0FDH,040h,0BFh,080h,07Fh
 F115 00        	db	00h	;End of table mark
                
                ;***2732 Subroutine**********************
                ;Print a pacifier dot unless the transfer
                ;port is the same as the console port
                ;trashes a
                ;****************************************
 F116 E5        PACIFY:	push    h
 F117 210000            lxi	h,0			;find transfer port
 F11A 39        	dad	sp			;..output port address
 F11B 2E40      	mvi	l,TPODP+1-RIOCOD+RAMCOD	;..located in RAM
                
 F11D 3A96F8    	lda	TPODP+1			;get console output port
 F120 BE        	cmp	m			;same?
 F121 E1                pop     h
 F122 CA73FD    	jz      CHKKBD			;y: done	
                
 F125 CD5BFD    	call	ILPRNT			;print a pacifier
 F128 AE        	db	PCFIER+80h
                
                ;Give the user a chance to break in at the end of each line
                
 F129 CD73FD    	call	CHKKBD		;abort if user says so
                
 F12C C9        	ret
                
                ;***Subroutine End*********************
                ;Verify command end
                ;On Entry
                ;  psw with carry clear is on the stack
                ;**************************************
                DOVRFY:
 F12D 1A        VLOOP:	ldax	d		;get expected data
 F12E BE        	cmp	m		;match?
 F12F CA38F1    	jz	VLUPOK
                
 F132 CD9AFB    	call	MERROR		;N: error
 F135 F1        	pop	psw
 F136 37        	stc			;remember error
 F137 F5        	push	psw
                
 F138 23        VLUPOK:	inx	h
 F139 13        	inx	d
 F13A 0B        	dcx	b
 F13B 78        	mov	a,b
 F13C B1        	ora	c
 F13D C22DF1    	jnz	VLOOP
                				;carry on stack set if error
 F140 C3E9F0    	jmp	OKEXIT		;say 'OK' of no errors
                
                ;***Subroutine End****************************************
                ;FLush the transfer port, and then jump to the already-
                ;loaded AL command's RAM code address
                ;On Entry:
                ;  hl=AL RAM code start address
                ;  e = 1 if Go record should be ignored
                ;  e = 2 if Go record should be executed
                ;  e = 3 if Go record should be executed and PROM disabled
                ;On Exit:
                ;  a=c=leader character
                ;Stack depth: 8
                ;*********************************************************
                TFLUSH:
                
                ;Flush external data latches for e.g. the OP-80
                ;or flush garbage from UARTs
 F143 CD91FD    	call	TPIN		;(without checking status)
                
                ;Find the leader: wait for two identical bytes in a row
                ;while allowing the user to abort (unless the transfer
                ;port is also the console)
 F146 AF        	xra	a
                
 F147 4F        FNDLDR:	mov	c,a
 F148 CD85FD    	call	GETTPD		;Get chr, chk for abort
 F14B B9        	cmp	c
 F14C C247F1    	jnz	FNDLDR
                
                ;check if e=3, set Z if so
 F14F 3E03              mvi     a,3
 F151 BB                cmp     e
 F152 79                mov     a,c
                
                ;Go to RAM code at SKPSWF (instead of MRCODE)
 F153 2E89              mvi	l,(SKPSWF-MRCODE)+DSKBUF
 F155 C266F1            jnz     TFGO            ; jump if PROM should stay enabled
                        
                ;Place "IN FF; MOV A,C" in RAM before SKPSWF and make sure we execute it
 F158 2B                dcx     h
 F159 3E79              mvi     a,79h           ; 'MOV A,C' opcode
 F15B 77                mov     m,a
 F15C 2B                dcx     h
 F15D 3EFF              mvi     a,SSWTCH        ; sense switch address
 F15F 77                mov     m,a
 F160 2B                dcx     h
 F161 3EDB              mvi     a,0DBh          ; 'IN' opcode
 F163 77                mov     m,a
 F164 AF                xra     a
 F165 5F                mov     e,a             ; e=0 means AMON PROM may be disabled
                                
 F166 E9        TFGO:   pchl
                
                ;***2732 Command Routine**********************************
                ;? (help)
                ;*********************************************************
 F167 CD56FD    HLPCMD:	call	CILPRT
                ;    123456789012345678901234567890123456789012345678901234567890123
 F16A 4144203C41 db 'AD <A> <C> [<G>]     Absolute binary dump, optional GO address'
 F1A8 0D0A       db CR,LF
 F1AA 414C205B3C db 'AL [<0/1/2>]         Absolute binary load,0=noexec,2=EPROM off'
 F1E8 0D0A       db CR,LF
 F1EA 424F202020 db 'BO                   Boot from Altair Floppy'
 F216 0D0A       db CR,LF
 F218 434F203C53 db 'CO <S> <D> <C> [<R>] Copy memory, optional repeat count <R>'
 F253 0D0A       db CR,LF
 F255 4455203C41 db 'DU <A> [<C>]         Dump memory'
 F275 0D0A       db CR,LF
 F277 454E203C41 db 'EN <A>               Enter data into memory'
 F2A2 0D0A       db CR,LF
 F2A4 4558203C41 db 'EX <A> [<1>]         Execute memory, optional EPROM disable'
 F2DF 0D0A       db CR,LF
 F2E1 4649205B3C db 'FI [<V> [<A> [<C>]]] Fill memory with hex value <V>'
 F314 0D0A       db CR,LF
 F316 4842205B3C db 'HB [<P>]             Altair Hard disk boot, opt. platter <P>'
 F352 0D0A       db CR,LF
 F354 4844203C41 db 'HD <A> <C> [<O>]     Hex dump, optional address offset <O>'
 F38E 0D0A       db CR,LF
 F390 484C205B3C db 'HL [<O>]             Hex load, optional address offset <O>'
 F3CA 0D0A       db CR,LF
 F3CC 4D54203C41 db 'MT <A> <C>           Memory test (can take several minutes)'
 F407 0D0A0A     db CR,LF,LF
 F40A 20203C413E db '  <A>, <S>, <D> are addresses. <C> is a byte count. All in hex.'
 F449 0D0A       db CR,LF
 F44B 20202D2D2D db '  ---More--','-'+80h
                
 F457 CDCAFB    	call	GETKBD		;wait for anything to be typed
                
 F45A CD56FD    	call	CILPRT
                ;    123456789012345678901234567890123456789012345678901234567890123
 F45D 0A         db LF
 F45E 494E203C50 db 'IN <P>               Read and report from input port <P>'
 F496 0D0A       db CR,LF
 F498 4F54203C50 db 'OT <P> <V>           Write hex value <V> to output port <P>'
 F4D3 0D0A       db CR,LF
 F4D5 5345203C41 db 'SE <A> <V1> ... <Vn> Search for hex string'
 F4FF 0D0A       db CR,LF
 F501 5345203C41 db 'SE <A> ',QUOTE,'text',QUOTE,'        Search for text string'
 F52C 0D0A       db CR,LF
 F52E 5445205B3C db 'TE [<E>]             Terminal mode, ^C [or ^<E>] to exit'
 F566 0D0A       db CR,LF
 F568 5450203C30 db 'TP <0-7>             Set transfer port:'
 F58F 0D0A       db CR,LF
 F591 2020202020 db '                      0: 88-2SIO port 0  4: 88-4PIO port 0'
 F5CB 0D0A       db CR,LF
 F5CD 2020202020 db '                      1: 88-2SIO port 0  5: 88-PIO'
 F5FF 0D0A       db CR,LF
 F601 2020202020 db '                      2: 88-SIO          6: 88-2SIO port 1'
 F63B 0D0A       db CR,LF
 F63D 2020202020 db '                      3: 88-ACR          7: Interfacer 1 port B'
 F67C 0D0A       db CR,LF
 F67E 5454203C30 db 'TT <0/1>             Video Terminal/Teletype-style deleting'
 F6B9 0D0A       db CR,LF
 F6BB 5645203C53 db 'VE <S> <D> <C>       Verify (compare) memory'
 F6E7 0D0A0A     db CR,LF,LF
 F6EA 20203C413E db '  <A>, <S>, <D> are addresses. <C> is a byte count. All in hex','.'+80h
                
 F729 C9        	ret		;done
                
 F72A =         H32END	equ	$
                 endif ;EPROM32
                
                 if not EPROM32
                H32END	equ	0
                 endif ;not EPROM32
                
                ;===Assembly Check================
                ;Check for overflow for the low 2K
                ;=================================
                 if EPROM32 and (MON32A+800h-H32END)/800h
                	ERROR: Lower 2K code is too large
                 endif ;EPROM32 and (MON32A+800h-H32END)/256
                
                ;===Assembly Check================================
                ; All of Monitor must not overrun the next section
                ;=================================================
                 if not EPROM32
                H1END	equ	$
                 endif ;not EPROM32
                
                 if (MBLADR - H1END)/256
                	ERROR: MBL is overwriting prior code
                 endif ;(MBLADR - H1END)/256
                
                ;==============================================================
                ;              Multi Boot Loader Subsystem (MBLe)
                ;
                ; Loads and runs an Altair 'Absolute Binary file' from input
                ; Transfer Port specified by the Sense switch settings.
                ;
                ; This code may be entered either by a call from the AMON main
                ; loop or directly from reset (either via the front panel or
                ; via Jump-Start hardware). If entered from AMON, then AMON
                ; will pass the selected load port, as requested by the user. 
                ; If executed directly, then this code will look at the front
                ; panel switch register to determine the load port.
                ;
                ;** Differences between MITS MBL and this code **
                ;
                ; 1) The code starts off by relocating itself to the highest
                ;    page of RAM that is found, so that it will still work
                ;    if the PROM is Phantomed by an IN instruction from port
                ;    FF (the switch register).
                ; 2) All HSR support is eliminated, including 88-4PIO port 1
                ;    initialization and code for starting the HSR transport.
                ; 3) The second 88-2SIOJP port (port 1) is initialized.
                ; 4) The switch setting that was assigned to the HSR has been
                ;    reassigned to the 88-2SIOJP's second port.
                ; 5) PTABLE has an 8th entry, which is the same as the 1st
                ;    (2SIO port 0). Testing for illegal sense switch setting
                ;    is thereby eliminated.
                ; 6) An initial read is performed for both the 88-PIO and the
                ;    88-4PIO port 0, to clear data handshake latches in
                ;    external devices such as the OP-80 paper tape reader
                ; 7) If the tape leader character is 0, then no checksum
                ;    loader will be skipped. 
                ; 9) Sense switch A11 is ignored when getting the load device,
                ;    rather than generating an I error.
                ;
                ; Since the 88-2SIOJP may optionally disable PROMS when an IN
                ; instruction accesses port FFh (like some versions of the MITS
                ; 8800b Turnkey Module), this code cannot execute from
                ; PROM - at least not from the point where the Sense switches
                ; are read onwards.
                ;
                ;==============================================================
                ; An Altair 'Absolute Binary file' has 4 sections, which may be
                ; separated by any number of nulls. these sections are:
                ;
                ; 1) the Leader, which comprises 2 or more identical bytes, the
                ;    value of which is the length of the checksum loader.
                ;
                ; 2) the checksum loader, which is a program that is normally
                ;    used to load the subsequent sections
                ;
                ; 3) zero or more load records, each structured as follows:
                ;       byte 0: Sync byte = 3Ch (identifies a load record)
                ;       byte 1: NN = number of data bytes in record
                ;       byte 2: LL = load address low byte
                ;       byte 3: HH = load address high byte
                ; bytes 4-NN+3: NN data bytes to store at HHLl, NN>0
                ;    byte NN+4: CC = checksum of bytes 2 through NN+3
                ;
                ; 4) the Go record, structured as follows
                ;       byte 0: Sync byte = 78H (identifies the Go record)
                ;       byte 1: LL = low byte of go address
                ;       byte 2: HH = high byte of go address
                ;
                ; Altair file Leaders and checksum loaders are specific to
                ; both the version of the particular software and the memory
                ; size. for example, the checksum loader for 4K Basic 3.2 is
                ; different than the checksum loader for 8K Basic 3.2. and
                ; both the Leader and checksum loader for 8K Basic 3.2 are
                ; different than those for 8K Basic 4.0.
                ;
                ; The MBL code is able to read any such Altair file by simply
                ; skipping over the Leader and checksum loader, and loading
                ; the load and Go records directly.
                ;
                ; When executed at the MBL address, MBL chooses its input
                ; Port based on the front panel Sense switches <2:0>, using
                ; the conventions set up in Basic 4.X, more or less.
                ;
                ;  device                   bits 2:0
                ;  88-2SIO port 0 (2 stops)   000b
                ;  88-2SIO port 0 (2 stops)   001b
                ;  88-SIO                     010b
                ;  88-ACR                     011b
                ;  88-4PIO                    100b
                ;  88-PIO                     101b
                ;  88-2SIO Port 1 (2 stops)   110b (was high-speed reader)
                ;  ComnpuPro Interfacer 1     111b (custom)
                ;
                ; Prior to Basic 4.0, MITS used different Sense switch settings
                ; to specify the console device. You can load an older tape
                ; by setting the switches according to the above table and
                ; starting the load. after the checksum loader on the tape
                ; has been skipped, and load records are loading (but before
                ; the load completes) change the Sense switch settings as
                ; required by the earlier version of Basic (or other program)
                ; that you are loading.
                ;
                ; The stack gets move to the DSTACK position, to make room for
                ; the sector buffer above it. (The sector buffer is used here
                ; for RAM code.) This restricts the stack to only 16 bytes (8
                ; pushes) deep. Since we changed the stack, we must JMP to MAIN
                ;when done - we can't RET.
                ;==============================================================
 FE00           	org MBLADR
                
                ;--------
                ;find RAM
                ;--------
 FE00 010BFE    MBL:	lxi	b,GOMBL		;return address to here
 FE03 C303F8    	jmp	INIT		;go install self-modifying I/O
                				;routines, and initialize all
                				;known ports. returns with e=0
                
                ;***Command Routine**********************************
                ;AL <0/1> (Boot from paper or cassette tape)
                ;   Go record ignored if parameter=0. Default to 1.
                ;Note: parameter is not bounds-checked, but
                ;nothing bad will happen with bogus values
                ;
                ;On Entry:
                ;  TP command has set up the Transfer Port
                ;  l=0 and carry set if no parameter typed
                ;  l=0 and carry clear if GO record should be ignored
                ;  l=1 if GO record should be obeyed
                ;****************************************************
 FE06 3E01      ALCMD:	mvi	a,1
 FE08 8D        	adc	l		;catch carry bit
 FE09 5F        	mov	e,a		;e = 1 or 2
                
                ;---------------------------------------------------
                ;Entry at GOMBL from cold-start at MBL:
                ;   e=0
                ;   nothing on stack
                ;Entry here from monitor call to ALCMD (AL command):
                ;  e = 1 if Go record should be ignored
                ;  e = 2 if Go record should be executed
                ;  bottom of stack = address of MAIN
                ;---------------------------------------------------
                
                ;Move the stack out of the way for the disk sector buffer
                ;which gets used here for the MBL RAM code
 FE0A C1                pop	b		;return address to MAIN
 FE0B CDE9FF    GOMBL:  call	FNDBUF		;hl=address of sector buffer
 FE0E F9        	sphl			;stack below buffer
 FE0F C5        	push	b		;return address to MAIN
                                                ;(not used if e=0)
                
                ;---------------------------------------------------------
                ;Relocate PROM image to the sector buffer in RAM.
                ;Run-time relocation of addresses is done by replacing any
                ;byte that matches the MSB of the org address with the MSB
                ;of the destination RAM address. this requires the value
                ;of the org MSB never to appear in the assembled code other
                ;than as the MSB of an address. (FE00 works for this.)
                ;On Entry:
                ;  hl = RAMBUF address (where to move code and execute it)
                ;  e = 0 if PROM may be disabled (cold-start at MBL)
                ;  e = 1 if Go record should be ignored
                ;  e = 2 if Go record should be executed
                ;  e = 3 if Go record should be executed and PROM disabled
                ;On 'ret' to the RAM code:
                ;  d = RAM execution page
                ;  e = unchanged
                ;  Z set if sense switches determine transfer port
                ;---------------------------------------------------------
 FE10 E5        	push	h		;RAM code execution address
                
 FE11 017BFE    	lxi	b,MRCODE	;source address
                
 FE14 0A        RELOOP:	ldax	b
 FE15 B8        	cmp	b		;relocatable address byte?
 FE16 C21AFE    	jnz	NOTADR
 FE19 7C        	mov	a,h		;Y: relocate this address
 FE1A 77        NOTADR:	mov	m,a
 FE1B 03        	inx	b
 FE1C 2C        	inr	l		;don't let h change at the end
 FE1D C214FE    	jnz	RELOOP		;run to the end of the page
                
                ;Set d=RAM execution page for overwrite detection during load
 FE20 54        	mov	d,h
                
                ;We will test the sense switches to get the transfer port if
                ;cold-start. Otherwise use transfer port as set up by Amon.
                
 FE21 1C        	inr	e		;e=1 if entry from amon
 FE22 1D        	dcr	e		;use switches? Z set if so
 FE23 C8        	rz			;execute the loaded code
                
 FE24 E1        	pop	h		;RAM code beginning address
                
                 if not EPROM32
                ;Go execute AL's RAM code, skipping the sense-switch read,
                ;using the transfer port as it is already set up.
                ;(Not enough code space for a thorough transfer port flush)
                	mvi	l,(SKPSW-MRCODE)+DSKBUF
                	pchl			;skip sense switch test
                 endif ;not EPROM32
                
                 if EPROM32
                ;Go do a thorough transfer port flush, then go execute
                ;AL's RAM code starting at SKPSWF
 FE25 C343F1    	jmp	TFLUSH		;(uses 8 stack bytes)
                 endif ;EPROM32
                
                ;==============================================================
                ; AMON Routines, occupying a hole in the PROM space
                ;==============================================================
                
                ;***Command Routine************************************
                ;IN <PORT> (Input from port)
                ;On Entry:
                ;  l=PORT
                ;Creates this routine on the stack, then executes it,
                ;then returns through PAHEX to print the value
                ;
                ;     NOP
                ;     IN   <PORT>
                ;     RET
                ;******************************************************
 FE28 113EFE    INCMD:	lxi	d,PCAHEX	;create return address
 FE2B D5        	push	d		;ret through PCAHEX
                
 FE2C 26C9      	mvi	h,RET		;Opcode
 FE2E E5        	push	h		;L=<PORT>
 FE2F 2100DB    	lxi	h,IN*256	;NOP,IN opcode
 FE32 E5        	push	h
 FE33 65        	mov	h,l		;hl=0
 FE34 39        	dad	sp		;hl points to routine
                
 FE35 D1        	pop	d		;fix stack
 FE36 D1        	pop	d
 FE37 E9        	pchl			;execute RAM routine
                
                ;***Subroutine***************
                ;Print hl as 4 hex digits
                ;On Entry:
                ;  b=0 for the console
                ;  b<>0 for the Transfer Port
                ;  c=checksum so far
                ;  hl=2 bytes to print
                ;On Exit:
                ;  c=updated checksum
                ;Trashes a
                ;Stack depth: 6
                ;****************************
 FE38 7C        PHLHEX:	mov	a,h		;h first
 FE39 CD40FE    	call	PAHEXC		;returns with Carry clear
 FE3C 7D        	mov	a,l		;then l
                
 FE3D FE        	db	CPI		;CPI opcode skips PCAHEX
                				;executing a NOP, and then
                				;..falling into PAHEX
                
                ;***Subroutine*********************
                ;Print a on console as 2 hex digits
                ;On Entry:
                ;  a=byte to print
                ;On Exit:
                ;  b=0
                ;Trashes a,c
                ;Stack depth: 4
                ;**********************************
 FE3E 0600      PCAHEX:	mvi	b,0		;print to console
                
                ;Fall into PAHEX
                
                ;***Subroutine******************************
                ;Print a as 2 hex digits and update checksum
                ;On Entry:
                ;  a=byte to print
                ;  b=0 for the console
                ;  b<>0 for the Transfer Port
                ;  c=checksum so far
                ;On Exit:
                ;  c=updated checksum
                ;Trashes a
                ;Stack depth: 4
                ;*******************************************
 FE40 F5        PAHEXC:	push	psw
 FE41 81        	add	c		;compute checksum
 FE42 4F        	mov	c,a
 FE43 F1        	pop	psw		;recover character
                
                ;Fall into PAHEX
                
                ;***Subroutine***************
                ;Print a as 2 hex digits
                ;On Entry:
                ;  a=byte to print
                ;  b=0 for the console
                ;  b<>0 for the Transfer Port
                ;Trashes a
                ;Stack depth: 4
                ;****************************
 FE44 F5        PAHEX:	push	psw		;save for low digit
                	
 FE45 0F        	rrc			;move the high four down
 FE46 0F        	rrc
 FE47 0F        	rrc
 FE48 0F        	rrc
 FE49 CD4DFE    	call	PNIBLE		;put them out
 FE4C F1        	pop	psw		;this time the low four
                
                ;Fall into PNIBLE
                
                ;---Local subroutine---------
                ;Print low nibble of a in hex
                ;On Entry:
                ;  b=0 for the console
                ;  b<>0 for the Transfer Port
                ;Trashes a
                ;Stack depth: 0
                ;----------------------------
 FE4D E60F      PNIBLE:	ani	0Fh		;four on the floor
 FE4F C630      	adi	'0'		;We work with ASCII here
 FE51 FE3A      	cpi	'9'+1		;0-9?
 FE53 DA58FE    	jc	PNIB1		;YUP: print & return
                
 FE56 C607      	adi	'A'-'9'-1	;make it a letter
                
 FE58 04        PNIB1:	inr	b		;which port?
 FE59 05        	dcr	b
 FE5A C293FB    	jnz	TPOUT		;print on Transfer Port
                
 FE5D C38BF8    	jmp	PRINTA		;exit from there
                
                ;***Subroutine*********************************
                ;Print hl in hex on the console,
                ;preceeded by CR,LF,space, and followed by ': '
                ;On Exit:
                ;   b=0
                ;Trashes a,c
                ;Stack depth: 8
                ;**********************************************
 FE60 CD56FD    PHLADR:	call	CILPRT		;CR LF space begins line
 FE63 A0        	db	' '+80h		;returns a=0
                
 FE64 47        	mov	b,a		;a=0: output to console
 FE65 CD01FD    	call	PHLCHX		;hl=address, b=0, trash c
                
 FE68 CD5BFD    	call	ILPRNT		;print colon space
 FE6B 3AA0      	db	':',' '+80h
 FE6D C9        	ret
                
                ;***Subroutine******************************
                ;Convert ASCII hex digit to binary
                ;On Entry:
                ;  a=character to convert
                ;On Exit:
                ;  a=binary result
                ;  Carry set if OK, clear if bogus character
                ;*******************************************
 FE6E D630      HEXCON:	sui	'0'		;Remove ASCII bias
 FE70 FE0A      	cpi	10
 FE72 D8        	rc			;If 0-9 then we're done
                
 FE73 D611      	sui	9+('A'-'9')	;Should be 0-5 now
 FE75 FE06      	cpi	6		;Gap chr or too high?
 FE77 D0        	rnc			;Error if so
                
 FE78 D6F6      	sui	0F6h		;Add 0AH, Set carry
 FE7A C9        	ret			;Ret with carry set
                
                
                ;===Assembly Check================================
                ; The above code must not overrun the next section
                ;=================================================
 FE7B =         H2END	equ	$
                
                 if (MRCODE - H2END)/256
                	ERROR: Code in Hole 2 is too big
                 endif
                
                ;=============================================================
                ; MBL RAM Execution Code
                ; All of the following code gets copied into the RAM Buffer
                ; (which is in the highest page of RAM that was discovered
                ; during initialization). this is in RAM because an IN from
                ; port FF (the front panel sense switches) optionally disables
                ; the PROM.
                ; On Entry:
                ;    d = RAM Execution page
                ; Entry at MRCODE:
                ;    e = 0 (PROM will be disabled by the upcoming IN FF)
                ; Entry at SKPSW:
                ;   Transfer Port already set up
                ;   PROM is still enabled
                ;   e = 1 if Go record should be ignored
                ;   e > 1 if Go record should be executed
                ; Entry at SKPSWF:
                ;   Transfer Port already set up
                ;   PROM is still enabled
                ;   c = leader character = loader length
                ;   e = 1 if Go record should be ignored
                ;   e > 1 if Go record should be executed
                ;=============================================================
 FE7B           	org MBLADR+DSKBUF	;force low address byte
                				;..to be the same
                
                ;----------------------------------------------------------
                ;This entry is only used when running directly from the MBL
                ;entry address, emulating the Altair MBL code. The transfer
                ;port is set up according to the sense switches, and no
                ;further execution from ROM is allowed, since the IN FF
                ;might disable the ROMs.
                ;----------------------------------------------------------
 FE7B DBFF      MRCODE:	in	SSWTCH		;N: read sense switches
                				;***This may disable ROM***
                
 FE7D E607      	ani	LDMASK		;bits specify load device
                
                ;	call	RSETP		;set up Transfer Port
 FE7F CD        	db	CALL		;call opcode
 FE80 00        	db	RSETP-RIOCOD+RAMCOD ;low address byte
 FE81 FE        	db	MRCODE/256	;high byte (gets relocated)
                SKPSW:
                
                ;----------------------------------------------
                ;Now that the transfer port code is installed,
                ;flush external data latches for e.g. the OP-80
                ;or flush garbage from UARTs
                ;On Entry & exit:
                ;  d = RAM execution page
                ;  e = 0 if PROM might be disabled
                ;  e = 1 if Go record should be ignored
                ;  e > 1 if Go record should be executed
                ;-----------------------------------------------
                ;	call	RTPIN
 FE82 CD        	db	CALL		;call opcode
 FE83 32        	db	RTPIN-RIOCOD+RAMCOD ;low address byte
 FE84 FE        	db	MRCODE/256	;high byte (gets relocated)
                
                ;-----------------------------------------
                ;The first byte read must be a leader byte
                ;-----------------------------------------
 FE85 CDF2FE    	call 	GETBYT		;get 1st byte
 FE88 4F        	mov	c,a		;number of bytes in leader
                
                ;-----------------------------------------------------------
                ;Skip over leader - a sequence of identical bytes, the value
                ;of which is the length of the checksum loader. If the value
                ;is  0, then there is no loader to skip.
                ;On Entry:
                ;  a=c=leader chr = loader length
                ;  c=0 means there is no loader
                ;  d = RAM Execution page
                ;  The ROM may already be disabled
                ;On Exit:
                ;  c = checksum loader length
                ;  d = RAM execution page
                ;  e = 0 if PROM may be disabled
                ;  e = 1 if Go record should be ignored
                ;  e > 1 if Go record should be executed
                ;  The 1st byte of the checksum loader has already been read
                ;-----------------------------------------------------------
 FE89 B7        SKPSWF:	ora	a		;null leader?
 FE8A CA9CFE    	jz	RCHUNT		;Y: bypass skipping the loader
                
 FE8D CDF2FE    LDSKIP:	call	GETBYT		;get another byte
 FE90 B9        	cmp	c
 FE91 CA8DFE    	jz	LDSKIP		;loop until different
                
                ;-----------------------------------------------------------
                ;Skip over checksum loader
                ;
                ;On Entry:
                ;  the 1st byte of the checksum loader has already been read
                ;  c=checksum loader length
                ;  d = RAM execution page
                ;  e = 0 if PROM may be disabled
                ;  e = 1 if Go record should be ignored
                ;  e > 1 if Go record should be executed
                ;-----------------------------------------------------------
 FE94 0D        	dcr	c		;since we got a byte already
                
 FE95 CDF2FE    CLSKIP:	call	GETBYT		;get a loader byte
 FE98 0D        	dcr	c
 FE99 C295FE    	jnz	CLSKIP
                
                ;----------------------------------------------------------
                ;Main record-loading loop
                ;
                ;Hunt for a sync character - either for another load record
                ;or for the Go record. ignore all else.
                ;On Entry:
                ;  d = RAM execution page
                ;  e = 0 if PROM may be disabled
                ;  e = 1 if Go record should be ignored
                ;  e > 1 if Go record should be executed
                ;----------------------------------------------------------
 FE9C CDF2FE    RCHUNT:	call	GETBYT		;hunt for sync character
                
                ;Note: can't use cpi opcode here because it is FEh
                
 FE9F EE3C      	xri	ALTPLR		;load record sync byte?
 FEA1 C2E0FE    	jnz	CHEKGO		;n: go see if it's a GO
                
                ;--------------------------------------------------------
                ;Load Record: Read and store data from a load record
                ;
                ;On Entry:
                ;  the load record sync byte has already been read
                ;  d = RAM execution page
                ;  e = 0 if PROM may be disabled
                ;  e = 1 if Go record should be ignored
                ;  e > 1 if Go record should be executed
                ;  RCHUNT's address is on the stack
                ;--------------------------------------------------------
 FEA4 CDF2FE    	call	GETBYT		;get record byte count
 FEA7 4F        	mov	c,a		;c counts data bytes
                
 FEA8 CDEEFE    	call	GETWRD		;get load address into a,l
 FEAB 67        	mov	h,a		;hl = record load address
                
 FEAC 85        	add	l		;initialize checksum
 FEAD 47        	mov	b,a
                	
                ;Loop to read c data bytes into memory at hl.
                ;Make sure data won't overwrite RAM Execution page.
 FEAE 7A        LRLOOP:	mov	a,d		;d=RAM Execution page
 FEAF BC        	cmp	h		;same page as load address?
 FEB0 3E4F      	mvi	a,OERMSG	;overwrite error message
 FEB2 CAD0FE    	jz	ERDONE		;error exit if overwrite
                
 FEB5 CDF2FE    	call	GETBYT		;get a data byte
                
 FEB8 77        	mov	m,a		;store data byte
 FEB9 BE        	cmp	m		;did it store correctly?
 FEBA C2CEFE    	jnz	MERDON		;error exit if mismatch
                
 FEBD 80        	add	b		;compute checksum
 FEBE 47        	mov	b,a
                
 FEBF 23        	inx	h		;bump dest pointer
 FEC0 0D        	dcr	c		;bump byte count
 FEC1 C2AEFE    	jnz	LRLOOP		;loop through all bytes
                
                ;Validate checksum, fail if it doesn't match
 FEC4 CDF2FE    	call	GETBYT		;test record's checksum
 FEC7 B8        	cmp	b
 FEC8 CA9CFE    	jz	RCHUNT		;match: get another record
                
 FECB 3E43      	mvi	a,CERMSG	;checksum error message
 FECD CA        	db	JZ		;skips 2 bytes
                
                ;Skip into ERDONE
                
 FECE 3E4D      MERDON:	mvi	a,MERMSG	;memory error message
                
                ;Fall into ERDONE
                
                ;------------------------------------------------------------
                ;Load Error:
                ; Turn the INTE light on as an error indicator. If the PROM
                ; has not been disabled (by a read from port FF), then report
                ; the error and return to the AMON monitor. If port FF has
                ; been read (to determine the load port), then save the error
                ; code and address at beginning of memory, and hang writing
                ; the error code forever to the console.
                ; On Entry:
                ;    a = error code
                ;    e = 0 if PROM may be disabled
                ;   hl = offending address
                ;------------------------------------------------------------
 FED0 1D        ERDONE:	dcr	e		;PROM disabled?
 FED1 F2D0FF    	jp	RPTERR		;N: report, return to monitor
                				;this routine not relocated
                
                ;PROM is possibly disabled. Report error the old way.
 FED4 320000    	sta	00000h		;PROM disabled: store err code
 FED7 220100    	shld	00001H		;Store offending address
                
 FEDA FB        	ei			;INTE light as error indicator
                
 FEDB D311      ERHANG:	out 	CONTXD		;Console output
 FEDD C3DBFE    	jmp 	ERHANG
                
                ;------------------
                ;Test for GO record
                ;------------------
 FEE0 EE44      CHEKGO:	xri	ALTGOR XOR ALTPLR ;EOF record sync byte?
 FEE2 C29CFE    	jnz	RCHUNT		;N: ignore
                
                ;Fall into GO record execution
                
                ;-------------------------------------------
                ;Go Record: get the GO address and go there
                ;
                ;On Entry:
                ;  e = 0 if PROM may be disabled
                ;  e = 1 if Go record should be ignored
                ;  e > 1 if Go record should be executed
                ;  GO-record sync byte has already been read
                ;-------------------------------------------
 FEE5 CDEEFE    	call	GETWRD		;get a,l=address
 FEE8 67        	mov	h,a		;high byte
                
 FEE9 1D        	dcr	e		;execute go record?
 FEEA CA01FD    	jz	PHLCHX		;n:print go address and quit	
                
 FEED E9        	pchl			;go to go address
                
                ;---Local Subroutine---------------
                ;Get 2-byte word from Transfer Port
                ;On Entry:
                ;  b=checksum so far
                ;On Exit:
                ;  l = next byte
                ;  a = subsequent byte
                ;  b := b+a+l
                ;----------------------------------
 FEEE CDF2FE    GETWRD:	call	GETBYT
 FEF1 6F        	mov	l,a
                
                ;Fall into GETBYT to get the high byte
                	
                ;---Local Subroutine----------------------
                ;Get a byte of data from the Transfer Port
                ;with user-abort opportunity
                ;On Entry:
                ;  e = 0 if AMON PROM may be disabled
                ;On Exit:
                ;  a = received character
                ;-----------------------------------------
                GETBYT:
                ;	call	RTPIS		;get transfer port status
 FEF2 CD        	db	CALL		;call opcode
 FEF3 2C        	db	RTPIS-RIOCOD+RAMCOD ;low address byte
 FEF4 FE        	db	MRCODE/256	;high byte (gets relocated)
                
                ;	jnz	RTPIN		;go get transfer port data byte
 FEF5 C2        	db	JNZ		;call opcode
 FEF6 32        	db	RTPIN-RIOCOD+RAMCOD ;low address byte
 FEF7 FE        	db	MRCODE/256	;high byte (gets relocated)
                
 FEF8 7B        	mov	a,e
 FEF9 B7        	ora	a		;PROM certainlty enabled?
 FEFA C46FFD    	cnz	CKABRT		;Y: user abort?
                
 FEFD C3F2FE    	jmp	GETBYT		;Wait for character
                
                ;===========================================
                ; End of MBL code copied into the RAM buffer
                ;===========================================
                MRCEND:
                
                ;===Assembly Check===============================
                ; MBL code must not overwrite the CDBL code below
                ;================================================
 FF00 =         SUBEND	equ	$
                
                 if (DBLADR - SUBEND)/256
                	ERROR: CDBL is overwriting prior code
                
                 endif
                
                ;==============================================================
                ;=         Combo Disk boot loader Subsystem (CDBL)            =
                ;=        for the Altair 88-DCDD 8" disk system and           =
                ;=            the Altair 88-MDS Minidisk system               =
                ;=                                                            =
                ;= CDBL loads software (e.g. Altair Disk BASIC) from an       =
                ;= Altair 88-DCDD 8" disk or an 88-MDS 5-1/4" minidisk,       =
                ;= automatically detecting which kind of drive is attached.   =
                ;==============================================================
                ;=                         NOTES                              =
                ;=                                                            =
                ;= Minidisks have 16 sectors/track, numbered 0 through 15.    =
                ;= 8" disks have 32 sectors/track, numbered 0 through 31.     =
                ;= CDBL figures out which kind of disk drive is attached,     =
                ;= based on the existance of sector number 16.                =
                ;=                                                            =
                ;=       Altair Disk Sector Format (FOR boot sectors)         =
                ;=                                                            =
                ;=   byte(s)     FUNCTION                buffer address       =
                ;=     0       Track number+80h (sync)     RAMADR+7Bh         =
                ;=     1       file size low byte          RAMADR+7Ch         =
                ;=     2       file size high byte         RAMADR+7Dh         =
                ;=   3-130     Sector data          RAMADR+7Eh to RAMADR+FDh  =
                ;=    131      marker byte (0FFh)          RAMADR+FEh         =
                ;=    132      checksum                    RAMADR+FFh         =
                ;=    133-136  Spare                        not read          =
                ;=                                                            =
                ;= Each sector header contains a 16-bit file-size value:      =
                ;= this many bytes (rounded up to an exact sector) are read   =
                ;= from the disk and written to RAM, starting at address 0.   =
                ;= when done (assuming no errors), CDBL then jumps to         =
                ;= address 0 (DMAADR) to execute the loaded code.             =
                ;=                                                            =
                ;= Sectors are interleaved 2:1. CDBL reads the even sectors   =
                ;= on each track first (starting with track 0, sector 0)      =
                ;= followed by the odd sectors (starting with sector 1),      =
                ;= continuing through the interleaved sectors of each track   =
                ;= until the specified number of bytes have been read.        =
                ;=                                                            =
                ;= CDBL first reads each sector (including the actual data    =
                ;= payload, as well as the 3 header and the first 2 trailer   =
                ;= bytes) from disk into the RAM buffer (DSKBUF). next, CDBL  =
                ;= checks to see if this sector would overwrite the RAM       =
                ;= portion of Cdbl, and aborts with an 'O' error if so. it    =
                ;= then copies the data payload portion from the buffer to    =
                ;= its final RAM location, calculating the checksum along the =
                ;= way. During the copy, each byte is read back, to verify    =
                ;= correct writes. any write-verify failure will immediately  =
                ;= abort the load with an 'M' error.                          =
                ;=                                                            =
                ;= Any disk read error (a checksum error or an incorrect      =
                ;= marker byte) will cause a retry of that sector read. after =
                ;= 16 retries on the same sector, CDBL will abort the load    =
                ;= with a 'C' error.                                          =
                ;=                                                            =
                ;= If the load aborts with any error, then the CDBL subsystem =
                ;= print an error message with the offending address, and     =
                ;= jump to the AMON main loop.                                =
                ;=                                                            =
                ;= The stack gets move to the DSTACK position, to make room   =
                ;= for the sector buffer above it. This restricts the stack   =
                ;= to only 16 bytes (8 pushes) deep.                          =
                ;==============================================================
                
 FF00           	org DBLADR
                
                ;==============================================================
                ; Entry here to execute CDBL directly, to boot from a floppy.
                ; This is the same address where MITS's DBL and MDBL start.
                ;==============================================================
 FF00 010AFF    CDBL:	lxi	b,GODBL		;return address
 FF03 C303F8    	jmp	INIT		;go find a real stack
                				;..with room for a sector
                				;and initialize ACIAs
                ;***Command Routine********
                ;BO (Boot from floppy disk)
                ;**************************
                BOCMD:
                
                ;Move the stack out of the way for the disk buffer
                ;We don't need to fix the return address to MAIN because
                ;a load error willcause a JMP to INIT2, not a RET.
 FF06 CDE9FF    	call	FNDBUF
 FF09 F9        	sphl
                
                GODBL:
                ;-----------------------------------------------------------
                ;Wait for user to insert a diskette into the drive 0, and
                ;then load that drive's head. Do this first so that the disk
                ;has plenty of time to settle. Note that a minidisk will
                ;always report that it is ready. Minidisks will hang (later
                ;on) waiting for sector 0F, until a few seconds after the
                ;user inserts a disk.
                ;-----------------------------------------------------------
 FF0A AF        WAITEN:	xra	a		;boot from disk 0
 FF0B D308      	out	DENABL		;..so enable disk 0
                
 FF0D CD73FD    	call	CHKKBD		;abort from user?
                
 FF10 DB08      	in	DSTAT		;Read drive status
 FF12 E608      	ani	DRVRDY		;Diskette in drive?
 FF14 C20AFF    	jnz	WAITEN		;no: wait for drive ready
                
 FF17 3E04      	mvi	a,HEDLOD	;load 8" disk head, or enable
 FF19 D309      	out	DCTRL		;..minidisk for 6.4 Sec
                
                ;-----------------------------------------------------------
                ;Step in once, then step out until track 0 is detected.
                ;The first time through, delay at least 25 ms to force a
                ;minimum 43 ms step wait instead of 10ms. This meets the 8"
                ; pec for changing seek direction. (Minidisk step time is
                ;always 50ms, enforced by the mninidsk conrtoller hardware.)
                ;See the 88-DCDD documentation for details. This loop ends
                ;with hl=0.
                ;-----------------------------------------------------------
 FF1B 212308    	lxi	h,25000/12	;25 mS delay 1st time thru
 FF1E 3E01      	mvi	a,STEPIN	;step in once first
                
 FF20 D309      SEEKT0:	out	DCTRL		;issue step command
                
 FF22 2C        	inr	l		;After 1st time, the following
                				;..loop goes 1 time.
                
 FF23 2B        T0DELY:	dcx	h		;(5)
 FF24 7C        	mov	a,h		;(5)
 FF25 B5        	ora	l		;(4)
 FF26 C223FF    	jnz	T0DELY		;(10)12 uS/pass
                
 FF29 DB08      WSTEP:	in	DSTAT		;wait for step to complete
 FF2B 0F        	rrc			;put MVHEAD bit in Carry
 FF2C 0F        	rrc			;is the servo stable?
 FF2D DA29FF    	jc	WSTEP		;no: wait for servo to settle
                
 FF30 E610      	ani	TRACK0/4	;Are we at track 00?
 FF32 3E02      	mvi	a,STEPOT	;Step-out command
 FF34 C220FF    	jnz	SEEKT0		;no: step out another track
                
                ;------------------------------------------------------
                ;Determine if this is an 8" disk or a minidisk, and set
                ;c to the correct sectors/track for the detected disk.
                ;an 8" disk has 20h sectors, numbered 0-1Fh. a minidisk
                ;has 10h sectors, numbered 0-0Fh.
                ;------------------------------------------------------
                
                ;wait for the highest minidisk sector, sector number 0Fh
 FF37 DB09      CKDSK1:	in	DSECTR		;Read the sector position
                
 FF39 E63F      	ani	SECMSK+SVALID	;mask sector bits, and hunt
 FF3B FE1E      	cpi	(MDSPT-1)*2	;..for minidisk last sector
 FF3D C237FF    	jnz	CKDSK1		;..only while SVALID is 0
                
                ;wait for this sector to pass
 FF40 DB09      CKDSK2:	in	DSECTR		;Read the sector position
 FF42 0F        	rrc			;wait for invalid sector
 FF43 D240FF    	jnc	CKDSK2	
                
                ;wait for and get the next sector number
 FF46 DB09      CKDSK3:	in	DSECTR		;Read the sector position
 FF48 0F        	rrc			;put SVALID in Carry
 FF49 DA46FF    	jc	CKDSK3		;wait for sector to be valid
                
                ;The next sector after sector 0Fh will be 0 for a minidisk,
                ;and 10h for an 8" disk. Adding MDSPT (10h) to that value
                ;will compute c=10h (for minidisks) or c=20h (for 8" disks).
 FF4C E61F      	ani	SECMSK/2	;mask sector bits
 FF4E C610      	adi	MDSPT		;compute SPT
 FF50 4F        	mov	c,a		;..and save SPT in c
                
                ;------------------------------------------
                ;Set up to load
                ;On Entry:
                ;  hl = 0 (DMA address & execution address)
                ;  c = SPT (for either minidisk or 8" disk)
                ;------------------------------------------
 FF51 E5        	push	h		;exec address = 0 onto stack
                
 FF52 CDE9FF    	call	FNDBUF		;find hl=buffer address,
                				;push DMA address = 0
 FF55 E3        	xthl			;push buffer address, recover
                				;DMA address = 0
                
 FF56 45        	mov	b,l		;initial sector number = 0
                
                ;------------------------------------------------------
                ;Read current sector over and over, until either the
                ;checksum is right, or there have been too many retries
                ;  b = current sector number
                ;  c = sectors/track for this kind of disk
                ;  hl = current DMA address
                ;  top-of-stack = buffer address
                ;  next on stack = execution address
                ;------------------------------------------------------
 FF57 3E10      NXTSEC:	mvi	a,RETRYS	;(7)Initialize sector retries
                
                ;-----------------------------------------
                ;Begin Sector Read
                ;  a = Remaining retries for this sector
                ;  b = Current sector number
                ;  c = Sectors/track for this kind of disk
                ;  hl = current DMA address
                ;  top-of-stack = DSKBUF address
                ;  next on stack = execution address = 0
                ;-----------------------------------------
 FF59 D1        RDSECT:	pop	d		;(10)get DSKBUF address
 FF5A D5        	push	d		;(11)keep it on the stack
 FF5B F5        	push	psw		;(11)Remaining retry count
                
                ;---------------------------------------------------
                ;Sector Read Step 1: hunt for sector specified in b.
                ;Data will become avaiable 250 uS after -SVALID goes
                ;low. -SVALID is low for 30 uS (nominal).
                ;---------------------------------------------------
 FF5C DB09      FNDSEC:	in	DSECTR		;(10)Read the sector position
                
 FF5E E63F      	ani	SECMSK+SVALID	;(7)yes: mask sector bits
                				;..along with -SVALID bit
 FF60 0F        	rrc			;(4)sector bits to bits <4:0>
 FF61 B8        	cmp	b		;(4)found the desired sector
                				;..with -SVALID low?
 FF62 C25CFF    	jnz	FNDSEC		;(10)no: wait for it
                
                ;-----------------------------------------------------------
                ;Test for DMA address that would overwrite the sector buffer
                ;or the stack. Do this here, while we have some time.
                ;-----------------------------------------------------------
 FF65 7C        	mov	a,h		;(5)high byte of DMA address
 FF66 BA        	cmp	d		;(4)high byte of RAM code addr
                
                ;Entry point for reporting an overrun error from HL command
                ;(Z flag is set on entry from HL.)
 FF67 3E4F      OVRERR:	mvi	a,OERMSG	;(7)overlay error message
 FF69 CAD0FF    	jz	RPTERR		;(10)report overlay error
                
                ;--------------------------------------
                ;Set up for the upcoming data move
                ;Do this here, while we have some time.
                ;--------------------------------------
 FF6C E5        	push	h		;(11)DMA address for retry
 FF6D C5        	push	b		;(11)Current sector & SPT
 FF6E 018000    	lxi	b,BPS		;(10)b= init checksum,
                				;c= byte count for movLUP
                
                ;-------------------------------------------------------
                ;Sector Read Step 2: Read sector data into DSKBUF at de.
                ;DSKBUF is positioned in memory such that e overflows
                ;exactly at the end of the buffer. Read data becomes
                ;available 250 uS after -SVALID becomes true (0).
                ;
                ;This loop must be << 32 uS per pass. 
                ;-------------------------------------------------------
 FF71 DB08      DATLUP:	in	DSTAT		;(10)Read the drive status
 FF73 07        	rlc			;(4)new Read data Available?
 FF74 DA71FF    	jc	DATLUP		;(10)no: wait for data
                
 FF77 DB0A      	in	DDATA		;(10)Read data byte
 FF79 12        	stax	d		;(7)store it in sector buffer
 FF7A 1C        	inr	e		;(5)Move to next buffer address
                				;..and test for end
 FF7B C271FF    	jnz	DATLUP		;(10)loop if more data
                
                ;------------------------------------------------
                ;Sector Read Step 3: Move sector data from DSKBUF
                ;into memory at hl. compute checksum as we go.
                ;
                ;8327 cycles for this section
                ;------------------------------------------------
 FF7E 1E7E      	mvi	e,SDATA		 ;(7)de= address of sector data
                				 ;..within the sector buffer
                
 FF80 1A        MOVLUP:	ldax	d		;(7)get sector buffer byte
 FF81 77        	mov	m,a		;(7)store it at the destination
 FF82 BE                cmp	m		;(7)Did it store correctly?
 FF83 C2CEFF    	jnz	MEMERR		;(10)no: abort w/ memory error
                
 FF86 80        	add	b		;(4)update checksum
 FF87 47        	mov	b,a		;(5)save the updated checksum
                
 FF88 13        	inx	d		;(5)bump sector buffer pointer
 FF89 23        	inx	h		;(5)bump DMA pointer
 FF8A 0D        	dcr	c		;(5)more data bytes to copy?
 FF8B C280FF    	jnz	MOVLUP		;(10)yes: loop
                
                ;----------------------------------------------------
                ;Sector Read Step 4: check marker byte and compare
                ;computed checksum against sector's checksum. Retry/
                ;abort if wrong marker byte or checksum mismatch.
                ;On Entry and Exit:
                ;  a=computed checksum
                ;134 cycles for for this section
                ;----------------------------------------------------
 FF8E EB        	xchg			;(4)hl=1st trailer byte address
                				;de=DMA address
 FF8F 4E        	mov	c,m		;(7)get marker, should be FFh
 FF90 0C        	inr	c		;(5)c should be 0 now
                
 FF91 23        	inx	h		;(5)(hl)=checksum byte
 FF92 AE        	xra	m		;(7)compare to computed cksum
 FF93 B1        	ora	c		;(4)..and test marker=ff
                
 FF94 C1        	pop	b		;(10)Current sector & SPT
 FF95 C2C1FF    	jnz	BADSEC		;(10)NZ: checksum error
                
                ;Compare next DMA address to the file byte count that came
                ;from the sector header. done of DMA address is greater.
 FF98 2E7C      	mvi	l,SFSIZE	;(7)hl=address of file size
 FF9A 7E        	mov	a,m		;(7)low byte
 FF9B 23        	inx	h		;(5)point to high byte
 FF9C 66        	mov	h,m		;(7)high byte
 FF9D 6F        	mov	l,a		;(5)hl=SFSIZE
                
 FF9E EB        	xchg			;(4)put DMA address back in hl
                				;..and file size into de
                
 FF9F 7D        	mov	a,l		;(4)16-bit subtraction
 FFA0 93        	sub	e		;(4)
 FFA1 7C        	mov	a,h		;(5)..throw away the result
 FFA2 9A        	sbb	d		;(4)..but keep Carry (borrow)
                
 FFA3 D1        	pop	d		;(10)chuck old DMA address
 FFA4 D1        	pop	d		;(10)chuck old retry count
                
 FFA5 D2B9FF    	jnc	FDEXEC		;(10)done loading if hl >= de
                
                ;------------------------------------------------------
                ;Next Sector: the sectors are interleaved by two.
                ;Read all the even sectors first, then the odd sectors.
                ;
                ;44 cycles for the next even or next odd sector
                ;------------------------------------------------------
 FFA8 1157FF    	lxi	d,NXTSEC	;(10)for compact jumps
 FFAB D5        	push	d		;(10)
                
 FFAC 04        	inr	b		;(5)sector = sector + 2
 FFAD 04        	inr	b		;(5)
                
 FFAE 78        	mov	a,b		;(5)even or odd sectors done?
 FFAF B9        	cmp	c		;(4)c=SPT
 FFB0 D8        	rc			;(5/11)no: go read next sector
                				;..at NXTSEC
                
                ;Total sector-to-sector = 28+8327+134+44=8533 cycles=4266.5 uS
                ;one 8" sector time = 5208 uS, so with 2:1 interleave, we will
                ;make the next sector, no problem.
 FFB1 0601      	mvi	b,01H		;1st odd sector number
 FFB3 C8        	rz			;Z: must read odd sectors now
                				;..at NXTSEC
                
                ;------------------------------------------------------------
                ;Next Track: Step in, and read again.
                ;Don't wait for the head to be ready (-MVHEAD), since we just
                ;read the entire previous track. Don't need to wait for this
                ;step-in to complete either, because we will definitely blow
                ;a revolution going from the track's last sector to sector 0.
                ;(One revolution takes 167 mS, and one step takes a maximum
                ;of 40 uS.) Note that NXTRAC will repair the stack.
                ;------------------------------------------------------------
 FFB4 78        	mov	a,b		;STEPIN happens to be 01h
 FFB5 D309      	out	DCTRL
                
 FFB7 05        	dcr	b		;start with b=0 for sector 0
 FFB8 C9        	ret			;go to NXTSEC
                
                ;-------------------------------------------------
                ;Execute successfully loaded code, after disabling
                ;the floppy drive and disabling the PROM
                ;On Entry:
                ;  Top of stack = DSKBUF address
                ;  Next on stack = execution address
                ;-------------------------------------------------
 FFB9 3E80      FDEXEC:	mvi	a,DDISBL	;Disable floppy controller
 FFBB D308      	out	DENABL
                
 FFBD D1        	pop	d		;chuck DSKBUF address
                				;..to expose exec address
                
 FFBE C37BFA    	jmp	EXECDP		;disable PROM and execute code
                
                ;***Error Routine********************************************
                ;Checksum error: attempt retry if not too many retries
                ;already. Otherwise, abort, reporting the error 
                ;On Entry:
                ;  Top of stack = adress for first byte of the failing sector
                ;  next on stack = retry count
                ;************************************************************
 FFC1 3E04      BADSEC:	mvi	a,HEDLOD	;Restart Minidisk 6.4 uS timer
 FFC3 D309      	out	DCTRL
                
 FFC5 E1        	pop	h		;Restore DMA address
 FFC6 F1        	pop	psw		;get retry count
 FFC7 3D        	dcr	a		;Any more retries left?
 FFC8 C259FF    	jnz	RDSECT		;yes: try reading it again
                
                ;----------------------------------------------------
                ;Irrecoverable error in one sector: too many retries.
                ;these errors may be either incorrect marker bytes,
                ;wrong checksums, or a combination of both.
                ;On Entry:
                ;  hl=RAM adress for first byte of the failing sector
                ;  sp = valid address in RAM page
                ;----------------------------------------------------
 FFCB 3E43      CSMERR:	mvi	a,CERMSG	;checksum error message
 FFCD 11        	db	11h		;'lxi d' opcode to skip
                				;..MEMERR and go to RPTERR
                
                ;Skip into RPTERR
                
                ;***Error Routine********************
                ;Memory error: memory readback failed
                ;On Entry:
                ;  hl = offending RAM address
                ;  sp = valid address in RAM page
                ;************************************
 FFCE 3E4D      MEMERR:	mvi	a,MERMSG	;memory error message
                
                ;Fall into RPTERR
                
                ;***CDBL (and MBL) Termination*************************
                ;Report an error: turn the disk controller off, report
                ;the error on the console, Turn on the INTE light, jump
                ;to the console loop.
                ;On Entry:
                ;  a = ASCII error code
                ;  hl = offending RAM address
                ;  sp = valid address in RAM page
                ;******************************************************
 FFD0 CD8BF8    RPTERR:	call	PRINTA		;print the ASCII error code
                
 FFD3 3E80      	mvi	a,DDISBL	;Disable floppy controller
 FFD5 D308      	out	DENABL
                
                ;Fall into HDERR
                
                ;***HDBL Termination***********************************
                ;Report an error: report the error on the console, Turn
                ;on the INTE light, jump to the console loop.
                ;On Entry:
                ;  a = error code
                ;  hl = offending RAM address or HDSK command
                ;  sp = valid address in RAM page
                ;******************************************************
 FFD7 CD5BFD    HDERR:	call	ILPRNT
 FFDA 206572726F	db	' error:',' '+80h
 FFE2 CD01FD    	call	PHLCHX		;print hl in hex on console
                
                ;Cool-start AMON code
 FFE5 FB        	ei			;INTE light on (indicate error)
 FFE6 C3B9F8    	jmp	INIT2		;go to monitor
                
                ;***Subroutine*******************
                ;Find the DSKBUF address
                ;On Entry:
                ;  sp = valid address in RAM page
                ;On Exit:
                ;  hl = RAM page item address
                ;  prior hl value is on the stack
                ;  Carry is clear
                ;Trashes a
                ;********************************
 FFE9 3E7B      FNDBUF:	mvi	a,DSKBUF
                
                ;Fall into HRMPAG
                
                ;***Subroutine**********************
                ;Set hl to location within RAM page
                ;On Entry:
                ;  a = address offset into RAM page
                ;  sp = valid address in RAM page
                ;On Exit:
                ;  hl = RAM page item address
                ;  prior hl value is on the stack
                ;  Carry is clear
                ;  other flags unafffected
                ;Stack depth: 2
                ;***********************************
 FFEB E3        HRMPAG:	xthl			;save hl, get return address
 FFEC E5        	push	h		;restore return address
                
                ;Fall into RAMPAG
                
                ;***Subroutine**********************
                ;Set hl to location within RAM page
                ;On Entry:
                ;  a = address offset into RAM page
                ;  sp = valid address in RAM page
                ;On Exit:
                ;  hl = RAM page item address
                ;  Carry is clear
                ;  other flags unafffected
                ;***********************************
 FFED 210000    RAMPAG:	lxi	h,0
 FFF0 39        	dad	sp		;get RAM page, clear carry
 FFF1 6F        	mov	l,a		;requested RAM address
 FFF2 C9        	ret
                
                ;***Subroutine*************************************
                ;Get a hex value from the line buffer
                ;Abort to CMDERR if none provided
                ;On Entry:
                ;  de=address of next item in the input line buffer
                ;On Exit:
                ;  hl=value
                ;  de advanced past character
                ;  top-of-stack = prior hl value
                ;  abort to CMDERR if no value found
                ;**************************************************
 FFF3 E3        GETHEX:	xthl			;save hl, put ret address in hl
 FFF4 CD18F9    	call	PHFHEX		;save hl, get hl=hex value
 FFF7 D0        	rnc
                
                ;Fall into CMDERR if no value
                
                ;*********************
                ;Commnd error handler
                ;**********************
 FFF8 CD56FD    CMDERR:	call	CILPRT		;returns Z flag cleared
 FFFB BF        	db	'?'+80h
                
 FFFC C3E0F8    	jmp	MAIN		;Repairs stack
                
                ;===Assembly Check================
                ; All of CDBL and the subsequent
                ; subroutines must fit in one page
                ;=================================
 FFFF =         DBLEND	equ	$
                
                 if (DBLEND - DBLADR)/256
                	ERROR: CDBL does not fit in a single page
                
                 endif
 FFFF           	end
