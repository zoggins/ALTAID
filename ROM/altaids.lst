                        ; Altaids ROM
                        ; (c) 2016-2018	David R. Hunter
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, version 3 of the License.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of 
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; alog with this program.  If not, see <https://www.gnu.org/licenses/>.
                        ;
                        ;
                        ; Included are three programs in the 8K EPROM of the Altaids Computer:
                        ;	1. TINY BASIC with a single line editor (ANSI Terminal) and XMODEM SAVE/LOAD
                        ;	2. Altair Turnkey Monitor (to recreate the "feel" of an Altair and terminal)
                        ;	3. 8085 Monitor with Intel Hex file load and single step trace capability
                        ;
                        ; This program source has a mix of "styles" because it is a 
                        ; combination of programs from different sources (see ACKNOWLEDGMENTS).
                        ; To be true to the authors of those programs, I tried to keep the style 
                        ; of the originals
                        ;  Dave Hunter
                        ;
                        ;
                        ; ACKNOWLEDGEMENTS:
                        ;
                        ; Developed with A85: 8085 Cross-Assembler Ver 0.1 by William C. Colley, III
                        ;   incorporating fixes for LCC/Windows by HRJ Dec 2013
                        ;
                        ; command line: A85 altaidsRom.asm -l altaids.lst -o altaids.hex
                        ;
                        ; The BASIC is adapted Palo Alto Tiny BASIC (PATB) by LiChen Wang DDJ June 1976
                        ; using features of the Sherry Brothers version
                        ;
                        ; GET$ AND PUT$ are adapted from DDJ Feb 1977, 
                        ; EXTENSIONS TO WANG'S PALO ALTO TINY BASIC by Russ Hayden
                        ;
                        ; RND is the 16-bit Random Number Generator from the web site:
                        ; www.map.grauw.nl/sources/external/z80bits.html#4.2
                        ; by Milos "Baze" Bazelides
                        ; and converted from Z-80 to 8080
                        ;
                        ; The ^C interrupt, editor, XMODEM routines and other enhancements to PATB
                        ; are by David Hunter 2016-2018
                        ;
                        ; The Altair monitor is adapted from TURMON by MITS (C)1977
                        ;
                        ; The 8085 monitor is by David Hunter March 2018
                        ;
                        ; The single step was adapted and modified from:
                        ; SINGLE STEPPING THE 8080 PROCESSOR
                        ; By Charles Sharp BYTE Magazine January 1979
                        ;
                        ; The 8085 disassembler is by David Hunter 2017
                        ;
                        ; The serial port routines are adapted from:
                        ; The MCS-80/85 Family User's Manual by Intel 1986 
                        ;
                        ;
                        ; The Altaids computer features:
                        ; 8K of E(E)PROM and 8K of RAM equivalent to a 16K Altair  
                        ; The serial port uses the SID/SOD pins of the 8085 as a software UART
                        ; There is one 8 bit I/O port which can be used for either input or output
                        ;
                        ; This is similar to the following configuration:
                        ;	Altair 8800b Turnkey Model w/ CPU board	
                        ; 	one 88-PMC8 8K ROM card
                        ;	two 88-4MCS 4K SRAM cards
                        ;	one 88-SIO serial I/O board
                        ;	one 88-PIO parallel I/O board
                        ;
                        ; Giving you a turnkey Altair with power supply and 6 cards in a mint tin!
                        ;
                        ; Hardware Memory Map:
                        ;	0000H - 0EFFH	EPROM: TINY BASIC
                        ;	0F00H - 0FFFH	EPROM: ALTAIR TURNKEY MONITOR
                        ;	1000H - 1BFFH	EPROM: 8085 MONITOR
                        ;	1C00H - 1FFFH	EPROM: unused
                        ;	2000H - 3FFFH	SRAM
                        ;	4000H - 5FFFH	unavailable
                        ;	6000H - 7FFFH	RESERVED (decoded with I/O)
                        ;	8000H - FFFFH	OPEN
                        ;
                        ;
                        ; I/O Map:
                        ;	00H - 5FH	unavailable
                        ;	60H - 7FH	external I/O port
                        ;	80H - FFH	unavailable
                        ;
                        ; Input Port:	60H
                        ; Output Port:	61H
                        ;
                        ; Serial interface: 2400 baud, 8N1, Flow control: None
                        ;
                        ; Because of processing of the serial data, sending text files from TeraTerm
                        ; requires delays for character and lines.  I found the following settings
                        ; very reliable:
                        ; Transmit delay =
                        ;	50 msec/char
                        ;	200 msec/line
                        ;
                        ;
                        	TITLE	"Altaids ROM VER 5"
                        ;
                        ;	06/14/16	D. Hunter - started project
                        ;	05/07/17	D. Hunter - editor and disassembler complete
                        ;	07/04/17	D. Hunter - added XMODEM Load/Save to Tiny BASIC
                        ;	03/15/18	D. Hunter - added Altair TURMON (modified)
                        ;				  - replaced monitor with my own version
                        ;	04/22/18	D. Hunter - added 1D arrays to Tiny BASIC
                        ;				  - added RANDOMIZE keyword to change random seed
                        ;
                        ;
                        ;
   3530                 VERS	EQU	'50'	; Version number (2 bytes)
                        ;			  BYTES REVERSED FOR DISPLAY ORDER
                        ;			  e.g. 20 == '0',' 2'
   0050                 BUFSIZ	EQU	80	; BUFFER SIZE
                        ;
                        ;*******************************************
                        ; CONSTANTS
                        ;
                        ; CONSTANTS FOR 2400 BAUD SERIAL I/O
                        ; USING A 4.9152MHZ CRYSTAL GIVES A 2.4576MHZ CLOCK
                        ; SEE THE INTEL MCS-80/85 FAMILY USER'S MANUAL PG A1-28
                        ; FOR DETAILS.  
   0026                 HALFBIT	EQU	38	
   0045                 FULLBIT	EQU	69	; true bit rate = 2388 bps
                        ;
                        ; HARDWARE GPIO PORTS
   0060                 GPI	EQU	60H	; INPUT PORT
   0061                 GPO	EQU	61H	; OUTPUT PORT
                        ;
                        ; ASCII CONSTANTS
   002a                 PROMPT	EQU	'*'	; MONITOR PROMPT CHARACTER
   002e                 APROMPT	EQU	'.'	; ALTAIR MONITOR PROMPT
   003e                 BPROMPT	EQU	'>'	; BASIC PROMPT 
   005d                 EPROMPT	EQU	']'	; EDITOR PROMPT
   0003                 CTRC	EQU	3	; ^C
   0004                 CTRD	EQU	4	; ^D
   0007                 BELL	EQU	7	; ^G BELL
   0008                 CTRH	EQU	8	; ^H BACKSPACE
   0009                 TAB	EQU	9	; ^I
   000f                 CTRO	EQU	15	; ^O TOGGLE OUTPUT
   0018                 CTRX	EQU	24	; ^X, ABORT
   0008                 BACKUP	EQU	CTRH	; BACKUP CHAR
   007f                 DEL	EQU	127	; RUBOUT
   001b                 ESC	EQU	27	; ESCAPE
   000d                 CR	EQU	13	; CARRIAGE RET
   000a                 LF	EQU	10	; LINE FEED
                        ;
   0010                 RLEN	EQU	16	; RECORD LENGTH FOR HEX DUMP
                        ;
                        ;
                        ; INTERRUPT ENABLE BIT FROM RIM INSTRUCTION
   0008                 IEFLG	EQU	08H	; SET IF INTERRUPTS ARE ENABLED
                        ;
                        ; XMODEM CONSTANTS
   0006                 ACK	EQU	06H		; ACKNOWLEDGE
   0015                 NAK	EQU	15H		; NO ACKNOWLEDGE
   0001                 SOH	EQU	01H		; START OF DATA
   0004                 EOT	EQU	04H		; END OF DATA
   0018                 CAN	EQU	18H		; CAN CHARACTER (^X)
   0080                 BLKSIZ	EQU	128		; NUMBER OF BYTES PER BLOCK
   60f8                 ONESEC	EQU	24824		; ONE SECOND TIME OUT FOR 2.4576MHZ CLOCK
   0003                 MAXTRY	EQU	3		; MAXIMUM RETRY COUNT
   000a                 MAXTIM	EQU	10		; MAXIMUM TIMEOUT COUNT (SECONDS)
                        ;
                        ;*******************************************
                        ; RESTART (RST) AREA
   0000                 	ORG	0	; RST 0
   0000   f3            ROMST:	DI		; START OF ROM, DISABLE INTERRUPTS
   0001   c3 00 10      	JMP	START	; GO TO THE MONITOR FIRST
   0004   57 41 4e 47   	DB	'WANG'
                        ;	
   0008                 	ORG	08H
   0008   e3            	XTHL		;*** TSTC OR RST 1 *** 
   0009   ef            	RST	5	;IGNORE BLANKS AND 
   000a   be            	CMP	M	;TEST CHARACTER
   000b   c3 c6 00      	JMP	TC1	;REST OF THIS IS AT TC1
                        ;
   000e   3e 0d         CRLF:	MVI	A,CR 	;*** CRLF ***
                        ;	
   0010                 	ORG	10H
   0010   f5            	PUSH	PSW	;*** OUTC OR RST 2 *** 
   0011   3a 01 20      	LDA	OCSW	;PRINT CHARACTER ONLY
   0014   b7            	ORA	A	;IF OCSW SWITCH IS ON
   0015   c3 c4 0d      	JMP	OC2	;REST OF THIS IS AT OC2
                        ;	
   0018                 	ORG	18H
   0018   cd e8 05      	CALL	EXPR2	;*** EXPR OR RST 3 *** 
   001b   e5            	PUSH	H	;EVALUATE AN EXPRESION 
   001c   c3 a4 05      	JMP	EXPR1	;REST OF IT IS AT EXPR1
   001f   45            	DB	'E' 
                        ;	
   0020                 	ORG	20H
   0020   7c            	MOV	A,H	;*** COMP OR RST 4 *** 
   0021   ba            	CMP	D	;COMPARE HL WITH DE
   0022   c0            	RNZ		;RETURN CORRECT CY AND
   0023   7d            	MOV	A,L	;Z FLAGS 
   0024   bb            	CMP	E	;BUT OLD A IS LOST 
   0025   c9            	RET
   0026   54 20         	DB	'T '
                        ;	
   0028                 	ORG	28H
   0028   1a            SS1:	LDAX	D	;*** IGNBLK/RST 5 ***
   0029   fe 20         	CPI	' '	;IGNORE BLANKS 
   002b   c0            	RNZ		;IN TEXT (WHERE DE->)
   002c   13            	INX	D	;AND RETURN THE FIRST
   002d   c3 28 00      	JMP	SS1	;NON-BLANK CHAR. IN A
                        ;	
   0030                 	ORG	30H
   0030   f1            	POP	PSW	;*** FINISH/RST 6 ***
   0031   cd 38 08      	CALL	FIN	;CHECK END OF COMMAND
   0034   c3 4b 08      	JMP	QWHAT	;PRINT "WHAT?" IF WRONG
   0037   41            	DB	'A' 
                        ;	
   0038                 	ORG	38H	;*** TSTV OR RST 7 *** 
   0038   c3 73 00      	JMP	TSTV0	;JUMP AROUND INTERRUPT
   003b   4c            	DB	'L'
                        ;	
                        ;*******************************************
                        ; SERIAL INTERRUPT
                        ; THIS ROUTINE LOOKS FOR A ^C CHARACTER AND
                        ; SETS THE ABORT FLAG IF ONE OCCURS
                        ;
                        ; ^C = 03H	= 00000011B
                        ; SERIAL DATA IS LSB FIRST, SO THE SEQUENCE
                        ; OF BITS ON THE INTERRUPT PIN IS:
                        ;  0:11000000:1
                        ;  S          P
                        ;  S = START, P = STOP
                        ;  THE TRANSISTION FROM START BIT TO BIT 0 
                        ;  CAUSES THE INTERRUPT.   BY LOOKING FOR THE
                        ;  CORRECT BIT SEQUENCE, A ^C CAN BE DETECTED
                        ;  THE INTERRUPT IS SIMILAR TO THE
                        ;  SERIAL INPUT ROUTINE IN THE MONITOR
                        ; 
                        ;
   003c                 	ORG	3CH	; RST 7.5 - SERIAL INTERRUPT
   003c   f5            INT75:	PUSH	PSW
   003d   c5            	PUSH	B
   003e   e5            	PUSH	H	; SAVE REGISTERS
   003f   01 80 08      	LXI	B,0880H	; B = 7BITS + STOP, C = FIRST BIT
                        ;
                        ; AT THIS POINT, WE ARE AT THE START OF THE FIRST DATA BIT
                        ;
   0042   2e 26         	MVI	L,HALFBIT 
   0044   2d            INT2:	DCR	L	; WAIT UNTIL THE MIDDLE OF THE FIRST BIT
   0045   c2 44 00      	JNZ	INT2
   0048   00            	NOP
                        ;
   0049   2e 45         INT3:	MVI	L,FULLBIT ; WAIT ONE BIT TIME
   004b   2d            INT4:	DCR	L
   004c   c2 4b 00      	JNZ	INT4
   004f   00            	NOP
   0050   00            	NOP
   0051   20            	RIM		; GET DATA BIT
   0052   17            	RAL
   0053   05            	DCR	B
   0054   ca 5e 00      	JZ	INT5
   0057   79            	MOV	A,C
   0058   1f            	RAR
   0059   4f            	MOV	C,A
   005a   00            	NOP		; NEEDED TO HAVE EQUAL # CLOCKS WITH COUT
   005b   c3 49 00      	JMP	INT3
                        ;
   005e   79            INT5:	MOV	A,C	; GET BYTE INTO ACC
   005f   ee 03         	XRI	CTRC	; CHECK IF ^C
   0061   c2 6b 00      	JNZ	INTX	; EXIT IF IT IS NOT
   0064   2f            	CMA		; SET ACC TO 0FFH
   0065   32 00 20      	STA	ABORTF	; SET ABORT FLAG
   0068   32 01 20      	STA	OCSW	; TURN OFF OUTPUT SO IT DOESN'T PRINT GARBAGE
   006b   e1            INTX:	POP	H
   006c   c1            	POP	B
   006d   3e 10         	MVI	A,10H	; CLEAR THE RST7.5 FLIP FLOP
   006f   30            	SIM		; THAT WAS SET BY THE STOP BIT
   0070   f1            	POP	PSW
   0071   fb            	EI
   0072   c9            	RET
                        ;
                        ; END - SERIAL INTERRUPT
                        ;*******************************************
                        ;
                        ;
   0073   ef            TSTV0:	RST	5
   0074   d6 40         	SUI	'@'	;TEST VARIABLES
   0076   d8            	RC		;CY:NOT A VARIABLE
   0077   c2 93 00      TSTV1:	JNZ	TV1	;NOT "@" ARRAY 
   007a   13            	INX	D	;IT IS THE "@" ARRAY 
   007b   cd a2 06      	CALL	PARN	;@ SHOULD BE FOLLOWED
   007e   29            	DAD	H	;BY (EXPR) AS ITS INDEX
   007f   da fd 00      	JC	QHOW	;IS INDEX TOO BIG? 
   0082   d5            	PUSH	D	;WILL IT OVERWRITE 
   0083   eb            	XCHG		;TEXT? 
   0084   cd f3 06      	CALL	SIZE	;FIND SIZE OF FREE 
   0087   e7            	RST	4	;AND CHECK THAT
   0088   da 79 08      	JC	ASORRY	;IF SO, SAY "SORRY"
   008b   21 00 3e      SS1A:	LXI	H,VARBGN  ;IF NOT, GET ADDRESS 
   008e   cd 07 08      	CALL	SUBDE	;OF @(EXPR) AND PUT IT 
   0091   d1            	POP	D	;IN HL 
   0092   c9            	RET		;C FLAG IS CLEARED
                        ;	
   0093   fe 1b         TV1:	CPI	33Q	;NOT @, IS IT A TO Z?
   0095   3f            	CMC		;IF NOT RETURN C FLAG
   0096   d8            	RC 
   0097   13            	INX	D	;IF A THROUGH Z
   0098   21 00 3e      	LXI	H,VARBGN  ;COMPUTE ADDRESS OF
   009b   07            	RLC		;THAT VARIABLE 
   009c   85            	ADD	L	;AND RETURN IT IN HL 
   009d   6f            	MOV	L,A	;WITH C FLAG CLEARED 
   009e   3e 00         	MVI	A,0 
   00a0   8c            	ADC	H 
   00a1   67            	MOV	H,A
   00a2   1a            	LDAX	D	;LOOK AT NEXT CHARACTER
   00a3   fe 28         	CPI	'('	;ARRAY REFERENCE?
   00a5   ca ab 00      	JZ	TV2	;YES, HANDLE REFERENCE
   00a8   37            	STC	
   00a9   3f            	CMC		;NO, CLEAR CARRY
   00aa   c9            	RET		;EXIT
                        ;* ARRAY REFERENCE
   00ab   c5            TV2:	PUSH	B	;SAVE BC
   00ac   e5            	PUSH	H	;SAVE VARIABLE ADDRESS ON STACK
   00ad   cd a2 06      	CALL	PARN	;GET ARRAY OFFSET
   00b0   7d            	MOV	A,L
   00b1   b4            	ORA	H
   00b2   ca fd 00      	JZ	QHOW	;ERROR IF OFFSET IS 0
   00b5   2b            	DCX	H	;CONVERT FROM 1 TO N OFFSET TO 0 TO N-1 OFFSET
   00b6   29            	DAD	H	;CONVERT TO BYTE OFFSET
   00b7   da fd 00      	JC	QHOW	;INDEX IS WAY TOO BIG
   00ba   4d            	MOV	C,L
   00bb   44            	MOV	B,H	;BC = OFFSET
   00bc   e1            	POP	H	;GET VARIABLE ADDRESS BACK
   00bd   d5            	PUSH	D	;SAVE TEXT POINTER
   00be   5e            	MOV	E,M	;READ ARRAY ADDRESS
   00bf   23            	INX	H
   00c0   56            	MOV	D,M	;DE = ARRAY START
   00c1   eb            	XCHG		;POINT TO ARRAY
   00c2   09            	DAD	B	;ARRAY LOCATION IN HL, CARRY CLEAR
   00c3   d1            	POP	D
   00c4   c1            	POP	B
   00c5   c9            	RET
                        ;* 
                        ;*	TSTC	XCH  HL,(SP)   ;*** TSTC OR RST 1 *** 
                        ;*	IGNBLK		THIS IS AT LOC. 8 
                        ;*	CMP	M	AND THEN JMP HERE 
   00c6   23            TC1:	INX	H	;COMPARE THE BYTE THAT 
   00c7   ca d1 00      	JZ	TC2	;FOLLOWS THE RST INST. 
   00ca   c5            	PUSH	B	;WITH THE TEXT (DE->)
   00cb   4e            	MOV	C,M	;IF NOT =, ADD THE 2ND 
   00cc   06 00         	MVI	B,0	;BYTE THAT FOLLOWS THE 
   00ce   09            	DAD	B	;RST TO THE OLD PC 
   00cf   c1            	POP	B	;I.E., DO A RELATIVE 
   00d0   1b            	DCX	D	;JUMP IF NOT = 
   00d1   13            TC2:	INX	D	;IF =, SKIP THOSE BYTES
   00d2   23            	INX	H	;AND CONTINUE
   00d3   e3            	XTHL 
   00d4   c9            	RET
                        ;* 
   00d5   21 00 00      TSTNUM:	LXI	H,0	;*** TSTNUM ***
   00d8   44            	MOV	B,H	;TEST IF THE TEXT IS 
   00d9   ef            	RST	5	;A NUMBER
   00da   fe 30         TN1:	CPI	'0'	;IF NOT, RETURN 0 IN 
   00dc   d8            	RC		;B AND HL
   00dd   fe 3a         	CPI	72Q	;IF NUMBERS, CONVERT 
   00df   d0            	RNC		;TO BINARY IN HL AND 
   00e0   3e f0         	MVI	A,360Q	;SET A TO # OF DIGITS
   00e2   a4            	ANA	H	;IF H>255, THERE IS NO 
   00e3   c2 fd 00      	JNZ	QHOW	;ROOM FOR NEXT DIGIT 
   00e6   04            	INR	B	;B COUNTS # OF DIGITS
   00e7   c5            	PUSH	B 
   00e8   44            	MOV	B,H	;HL=10;*HL+(NEW DIGIT)
   00e9   4d            	MOV	C,L 
   00ea   29            	DAD	H	;WHERE 10;* IS DONE BY
   00eb   29            	DAD	H	;SHIFT AND ADD 
   00ec   09            	DAD	B 
   00ed   29            	DAD	H 
   00ee   1a            	LDAX	D	;AND (DIGIT) IS FROM 
   00ef   13            	INX	D	;STRIPPING THE ASCII 
   00f0   e6 0f         	ANI	17Q	;CODE
   00f2   85            	ADD	L 
   00f3   6f            	MOV	L,A 
   00f4   3e 00         	MVI	A,0 
   00f6   8c            	ADC	H 
   00f7   67            	MOV	H,A 
   00f8   c1            	POP	B 
   00f9   1a            	LDAX	D	;DO THIS DIGIT AFTER 
   00fa   f2 da 00      	JP	TN1	;DIGIT. S SAYS OVERFLOW
                        ;
                        ; ERROR MESSAGES
   00fd   d5            QHOW:	PUSH	D	;*** ERROR: "HOW?" *** 
   00fe   11 04 01      AHOW:	LXI	D,HOW 
   0101   c3 4f 08      	JMP	ERRORB
   0104   48 4f 57 3f   HOW:	DB	'HOW?',CR 
   0108   0d            
   0109   4f 4b 0d      OK:	DB	'OK',CR 
   010c   57 48 41 54   WHAT:	DB	'WHAT?',CR
   0110   3f 0d         
   0112   53 4f 52 52   SORRY:	DB	'SORRY',CR
   0116   59 0d         
                        ;
                        ; TINY BASIC SIGN ON MESSAGE
   0118   50 41 4c 4f   MSG1:	DB	'PALO ALTAIDS TINY BASIC VER 1.0',CR
   011c   20 41 4c 54   
   0120   41 49 44 53   
   0124   20 54 49 4e   
   0128   59 20 42 41   
   012c   53 49 43 20   
   0130   56 45 52 20   
   0134   31 2e 30 0d   
                        ;
   0138   53 45 4e 44   XSMSG:	DB	'SENDING FILE',CR
   013c   49 4e 47 20   
   0140   46 49 4c 45   
   0144   0d            
   0145   52 45 41 44   XLMSG:	DB	'READY FOR FILE',CR
   0149   59 20 46 4f   
   014d   52 20 46 49   
   0151   4c 45 0d      
                        ;
                        ; ANSI TERMINAL COMMANDS
                        ;
   0154   1b            CSI:	DB	ESC	; CONTROL SEQUENCE INITIATOR
   0155   5b 00         	DB	'[',0
                        ;
   0157   1b            CLSCR:	DB	ESC	; CLEAR SCREEN
   0158   5b 32 4a      	DB	'[2J'	; CONTINUE WITH HOME
   015b   1b            CHOME:	DB	ESC
   015c   5b 48 00      	DB	'[H',0	; CURSOR HOME TO UPPER LEFT
   015f   1b            CUP:	DB	ESC	; CURSOR COMMANDS
   0160   5b 41 00      	DB	'[A',0
   0163   1b            CDN:	DB	ESC
   0164   5b 42 00      	DB	'[B',0
   0167   1b            CRIGHT:	DB	ESC
   0168   5b 43 00      	DB	'[C',0
   016b   1b            CLEFT:	DB	ESC
   016c   5b 44 00      	DB	'[D',0
   016f   1b            CEEOL:	DB	ESC	; ERASE TO END OF LINE
   0170   5b 4b 00      	DB	'[K',0
   0173   1b            CELN:	DB	ESC	; ERASE LINE
   0174   5b 32 4b 00   	DB	'[2K',0
   0178   1b            CSAV:	DB	ESC	; SAVE CURSOR
   0179   5b 73 00      	DB	'[s',0
   017c   1b            CUSAV:	DB	ESC	; UNSAVE CURSOR
   017d   5b 75 00      	DB	'[u',0
   0180   1b            CQERY:	DB	ESC	; QUERY CURSOR
   0181   5b 36 6e 00   	DB	'[6n',0	
                        ;
                        ;* 
                        ;**************************************************************
                        ;* 
                        ;* *** MAIN ***
                        ;* 
                        ;* THIS IS THE MAIN LOOP THAT COLLECTS THE TINY BASIC PROGRAM
                        ;* AND STORES IT IN THE MEMORY.
                        ;* 
                        ;* AT START, IT PRINTS OUT "(CR)OK(CR)", AND INITIALIZES THE 
                        ;* STACK AND SOME OTHER INTERNAL VARIABLES.  THEN IT PROMPTS 
                        ;* ">" AND READS A LINE.  IF THE LINE STARTS WITH A NON-ZERO 
                        ;* NUMBER, THIS NUMBER IS THE LINE NUMBER.  THE LINE NUMBER
                        ;* (IN 16 BIT BINARY) AND THE REST OF THE LINE (INCLUDING CR)
                        ;* IS STORED IN THE MEMORY.  IF A LINE WITH THE SAME LINE
                        ;* NUMBER IS ALREDY THERE, IT IS REPLACED BY THE NEW ONE.  IF
                        ;* THE REST OF THE LINE CONSISTS OF A CR ONLY, IT IS NOT STORED
                        ;* AND ANY EXISTING LINE WITH THE SAME LINE NUMBER IS DELETED. 
                        ;* 
                        ;* AFTER A LINE IS INSERTED, REPLACED, OR DELETED, THE PROGRAM 
                        ;* LOOPS BACK AND ASKS FOR ANOTHER LINE.  THIS LOOP WILL BE 
                        ;* TERMINATED WHEN IT READS A LINE WITH ZERO OR NO LINE
                        ;* NUMBER; AND CONTROL IS TRANSFERED TO "DIRECT".
                        ;* 
                        ;* TINY BASIC PROGRAM SAVE AREA STARTS AT THE MEMORY LOCATION
                        ;* LABELED "TXTBGN" AND ENDED AT "ARRUNF".  WE ALWAYS FILL THIS
                        ;* AREA STARTING AT "TXTBGN", THE UNFILLED PORTION IS POINTED
                        ;* BY THE CONTENT OF A MEMORY LOCATION LABELED "TXTUNF". 
                        ;*
                        ;* ARRUNF POINTS TO UNFILLED ARRAY SPACE WHICH STARTS AT TXTEND-1
                        ;* AND MOVES DOWN IN MEMORY.  THEREFORE, ARRAY SPACE REDUCES
                        ;* PROGRAM SPACE.
                        ;* 
                        ;* THE MEMORY LOCATION "CURRNT" POINTS TO THE LINE NUMBER
                        ;* THAT IS CURRENTLY BEING INTERPRETED.  WHILE WE ARE IN 
                        ;* THIS LOOP OR WHILE WE ARE INTERPRETING A DIRECT COMMAND 
                        ;* (SEE NEXT SECTION), "CURRNT" SHOULD POINT TO A 0. 
                        ;* 
                        ; INITIALIZE THE VARIABLES
                        ;
   0185   31 a0 3f      BASIC:	LXI	SP,STACK ;COLD START OF BASIC
   0188   3e 0b         	MVI	A,0BH	;ENABLE INTERRUPT 7.5, DISABLE OTHERS
   018a   30            	SIM
   018b   11 18 01      	LXI	D,MSG1	;GET SIGNON MESSAGE
   018e   97            	SUB	A	;CLEAR A
   018f   cd 31 09      	CALL	PRTSTG	;SEND MSG
                        ; INITIALIZE VARIABLES
   0192   21 85 01      	LXI	H,BASIC
   0195   22 14 20      	SHLD	SEED	;INITIALIZE RANDOM SEED
   0198   21 1a 20      	LXI	H,TXTBGN
   019b   22 18 20      	SHLD	TXTUNF	;INITIALIZE UNFILLED TEXT POINTER
                        ;*	
   019e   f3            RSTART:	DI		; WARM START
   019f   21 ff 3d      	LXI	H,TXTEND-1
   01a2   22 16 20      	SHLD	ARRUNF	;INITIALIZE UNFILLED ARRAY POINTER
                        ;*
   01a5   31 a0 3f      	LXI	SP,STACK ;RESET THE STACK ON A RESTART	
   01a8   97            	SUB	A
   01a9   32 00 20      	STA	ABORTF	;CLEAR THE ABORT FLAG
   01ac   3e ff         	MVI	A,0FFH
   01ae   32 01 20      	STA	OCSW	;TURN ON THE OUTPUT SWITCH
   01b1   3e 10         	MVI	A,10H	;RESET THE INTERRUPT 7.5 FLIP FLOP
   01b3   30            	SIM
   01b4   cd 0e 00      ST1:	CALL	CRLF
   01b7   11 09 01      	LXI	D,OK	;DE->STRING
   01ba   97            	SUB	A	;A=0
   01bb   cd 31 09      	CALL	PRTSTG	;PRINT STRING UNTIL CR 
   01be   21 c5 01      	LXI	H,ST2+1	;POINTER TO 0 VALUE
   01c1   22 02 20      	SHLD	CURRNT	;CURRNT->LINE # = 0
   01c4   21 00 00      ST2:	LXI	H,0
   01c7   22 0a 20      	SHLD	LOPVAR
   01ca   22 04 20      	SHLD	STKGOS
   01cd   3e 3e         ST3:	MVI	A,BPROMPT ;PROMPT AND
   01cf   cd 7f 08      	CALL	GETLN	;READ A LINE
   01d2   d5            	PUSH	D	;DE->END OF LINE+1
                        ;*
   01d3   11 38 3e      STORLN:	LXI	D,BUFFER ;DE->BEGINNING OF LINE,[SP]->END OF LINE+1
   01d6   cd d5 00      	CALL	TSTNUM	;TEST IF IT IS A NUMBER
   01d9   ef            	RST	5 	;IGNBLK
   01da   7c            	MOV	A,H	;HL=VALUE OF THE # OR
   01db   b5            	ORA	L	;0 IF NO # WAS FOUND 
   01dc   c1            	POP	B	;BC->END OF LINE+1
   01dd   ca 17 03      	JZ	DIRECT
   01e0   1b            	DCX	D	;BACKUP DE AND SAVE
   01e1   7c            	MOV	A,H	;VALUE OF LINE # THERE 
   01e2   12            	STAX	D 
   01e3   1b            	DCX	D 
   01e4   7d            	MOV	A,L 
   01e5   12            	STAX	D 
   01e6   c5            	PUSH	B	;DE->BEGIN, BC->END 
   01e7   d5            	PUSH	D 
   01e8   79            	MOV	A,C 
   01e9   93            	SUB	E 
   01ea   f5            	PUSH	PSW	;A=# OF BYTES IN LINE
   01eb   cd 08 09      	CALL	FNDLN	;FIND THIS LINE IN SAVE
   01ee   d5            	PUSH	D	;AREA, DE->SAVE AREA 
   01ef   c2 02 02      	JNZ	ST4	;NZ:NOT FOUND, INSERT
   01f2   d5            	PUSH	D	;Z:FOUND, DELETE IT
   01f3   cd 24 09      	CALL	FNDNXT	;FIND NEXT LINE
                        ;*                       DE->NEXT LINE 
   01f6   c1            	POP	B	;BC->LINE TO BE DELETED
   01f7   2a 18 20      	LHLD	TXTUNF	;HL->UNFILLED SAVE AREA
   01fa   cd b3 09      	CALL	MVUP	;MOVE UP TO DELETE 
   01fd   60            	MOV	H,B	;TXTUNF->UNFILLED AREA 
   01fe   69            	MOV	L,C 
   01ff   22 18 20      	SHLD	TXTUNF	;UPDATE
   0202   c1            ST4:	POP	B	;GET READY TO INSERT 
   0203   2a 18 20      	LHLD	TXTUNF	;BUT FIRT CHECK IF
   0206   f1            	POP	PSW	;THE LENGTH OF NEW LINE
   0207   e5            	PUSH	H	;IS 3 (LINE # AND CR)
   0208   fe 03         	CPI	3	;THEN DO NOT INSERT
   020a   ca 9e 01      	JZ	RSTART	;MUST CLEAR THE STACK
   020d   85            	ADD	L	;COMPUTE NEW TXTUNF
   020e   6f            	MOV	L,A 
   020f   3e 00         	MVI	A,0 
   0211   8c            	ADC	H 
   0212   67            	MOV	H,A	;HL->NEW UNFILLED AREA 
   0213   11 00 3e      ST4A:	LXI	D,TXTEND  ;CHECK TO SEE IF THERE 
   0216   e7            	RST	4	;IS ENOUGH SPACE 
   0217   d2 78 08      	JNC	QSORRY	;SORRY, NO ROOM FOR IT 
   021a   22 18 20      	SHLD	TXTUNF	;OK, UPDATE TXTUNF 
   021d   d1            	POP	D	;DE->OLD UNFILLED AREA 
   021e   cd bc 09      	CALL	MVDOWN
   0221   d1            	POP	D	;DE->BEGIN, HL->END
   0222   e1            	POP	H 
   0223   cd b3 09      	CALL	MVUP	;MOVE NEW LINE TO SAVE 
   0226   c3 cd 01      	JMP	ST3	;AREA
                        ;*
                        ;* 
                        ;**************************************************************
                        ;* 
                        ;* *** TABLES *** DIRECT *** & EXEC ***
                        ;* 
                        ;* THIS SECTION OF THE CODE TESTS A STRING AGAINST A TABLE.
                        ;* WHEN A MATCH IS FOUND, CONTROL IS TRANSFERED TO THE SECTION 
                        ;* OF CODE ACCORDING TO THE TABLE. 
                        ;* 
                        ;* AT 'EXEC', DE SHOULD POINT TO THE STRING AND HL SHOULD POINT
                        ;* TO THE TABLE-1.  AT 'DIRECT', DE SHOULD POINT TO THE STRING,
                        ;* HL WILL BE SET UP TO POINT TO TAB1-1, WHICH IS THE TABLE OF 
                        ;* ALL DIRECT AND STATEMENT COMMANDS.
                        ;* 
                        ;* A '.' IN THE STRING WILL TERMINATE THE TEST AND THE PARTIAL 
                        ;* MATCH WILL BE CONSIDERED AS A MATCH.  E.G., 'P.', 'PR.',
                        ;* 'PRI.', 'PRIN.', OR 'PRINT' WILL ALL MATCH 'PRINT'. 
                        ;* 
                        ;* THE TABLE CONSISTS OF ANY NUMBER OF ITEMS.  EACH ITEM 
                        ;* IS A STRING OF CHARACTERS WITH BIT 7 SET TO 0 AND 
                        ;* A JUMP ADDRESS STORED HI-LOW WITH BIT 7 OF THE HIGH 
                        ;* BYTE SET TO 1.   THEREFORE, THE ADDRESS < 8000H
                        ;* 
                        ;* END OF TABLE IS AN ITEM WITH A JUMP ADDRESS ONLY.  IF THE 
                        ;* STRING DOES NOT MATCH ANY OF THE OTHER ITEMS, IT WILL 
                        ;* MATCH THIS NULL ITEM AS DEFAULT.
                        ;* 
   0229                 TAB1:	EQU	$	;DIRECT COMMANDS 
   0229   4c 49 53 54   	DB	'LIST'
   022d   83 ce         	DB	LIST SHR 8 + 128,LIST AND 0FFH
   022f   52 55 4e      	DB	'RUN'
   0232   83 57         	DB	RUN SHR 8 + 128,RUN AND 255
   0234   4e 45 57      	DB	'NEW'
   0237   83 48         	DB	NEW SHR 8 + 128,NEW AND 255
   0239   45 44 49 54   	DB	'EDIT'
   023d   84 30         	DB	EDIT SHR 8 + 128,EDIT AND 255
   023f   58 4c 4f 41   	DB	'XLOAD'
   0243   44            
   0244   83 a9         	DB	XLOAD SHR 8 + 128,XLOAD AND 255
   0246   58 53 41 56   	DB	'XSAVE'
   024a   45            
   024b   83 b9         	DB	XSAVE SHR 8 + 128,XSAVE AND 255
   024d   42 59 45      	DB	'BYE'	;GO BACK TO THE MONITOR
   0250   80 00         	DB	ROMST SHR 8 + 128,ROMST AND 255
   0252                 TAB2:	EQU	$	;DIRECT/STATEMENT
   0252   4e 45 58 54   	DB	'NEXT'
   0256   84 da         	DB	NEXT SHR 8 + 128,NEXT AND 255
   0258   4c 45 54      	DB	'LET'
   025b   85 9a         	DB	LET SHR 8 + 128,LET AND 255
   025d   4f 55 54      	DB	'OUT'
   0260   87 47         	DB	OUTCMD SHR 8 + 128,OUTCMD AND 255
   0262   47 45 54 24   	DB	'GET$'
   0266   87 0d         	DB	GETST SHR 8 + 128, GETST AND 255
   0268   50 55 54 24   	DB	'PUT$'
   026c   87 04         	DB	PUTST SHR 8 + 128, PUTST AND 255
   026e   50 4f 4b 45   	DB	'POKE'
   0272   87 5c         	DB	POKE SHR 8 + 128,POKE AND 255
   0274   49 46         	DB	'IF'
   0276   85 2b         	DB	IFF SHR 8 + 128,IFF AND 255
   0278   47 4f 54 4f   	DB	'GOTO'
   027c   83 7c         	DB	GOTO SHR 8 + 128,GOTO AND 255
   027e   47 4f 53 55   	DB	'GOSUB'
   0282   42            
   0283   84 42         	DB	GOSUB SHR 8 + 128,GOSUB AND 255
   0285   52 45 54 55   	DB	'RETURN'
   0289   52 4e         
   028b   84 62         	DB	RETURN SHR 8 + 128,RETURN AND 255
   028d   52 45 4d      	DB	'REM'
   0290   85 27         	DB	REM SHR 8 + 128,REM AND 255
   0292   46 4f 52      	DB	'FOR'
   0295   84 7b         	DB	FOR SHR 8 + 128,FOR AND 255
   0297   49 4e 50 55   	DB	'INPUT'
   029b   54            
   029c   85 44         	DB	INPUT SHR 8 + 128,INPUT AND 255
   029e   50 52 49 4e   	DB	'PRINT'
   02a2   54            
   02a3   83 ed         	DB	PRINT SHR 8 + 128,PRINT AND 255
   02a5   53 54 4f 50   	DB	'STOP'
   02a9   83 51         	DB	STOP SHR 8 + 128,STOP AND 255
   02ab   45 4e 44      	DB	'END'	; END IS THE SAME AS STOP
   02ae   83 51         	DB	STOP SHR 8 + 128,STOP AND 255
   02b0   43 4c 53      	DB	'CLS'
   02b3   83 8b         	DB	CLS SHR 8 + 128,CLS AND 255
   02b5   44 49 4d      	DB	'DIM'
   02b8   87 92         	DB	DIM SHR 8 + 128,DIM AND 255
   02ba   52 41 4e 44   	DB	'RANDOMIZE'
   02be   4f 4d 49 5a   
   02c2   45            
   02c3   83 95         	DB	RNDMZ SHR 8 + 128,RNDMZ AND 255
                        ;*	ADD MORE COMMANDS HERE
   02c5   85 94         	DB	DEFLT SHR 8 + 128,DEFLT AND 255
   02c7                 TAB4:	EQU	$	;FUNCTIONS (THOSE THAT RETURN VALUES)
   02c7   52 4e 44      	DB	'RND'
   02ca   86 ad         	DB	RND SHR 8 + 128,RND AND 255
   02cc   49 4e 50      	DB	'INP'
   02cf   87 51         	DB	INCMD SHR 8 + 128,INCMD AND 255
   02d1   50 45 45 4b   	DB	'PEEK'
   02d5   87 66         	DB	PEEK SHR 8 + 128,PEEK AND 255
   02d7   55 53 52      	DB	'USR'
   02da   87 6d         	DB	USR SHR 8 + 128,USR AND 255
   02dc   41 42 53      	DB	'ABS'
   02df   86 e7         	DB	ABS SHR 8 + 128,ABS AND 255
   02e1   53 49 5a 45   	DB	'SIZE'	; AMOUNT OF FREE MEMORY
   02e5   86 f3         	DB	SIZE SHR 8 + 128,SIZE AND 255
   02e7   46 52 45 45   	DB	'FREE'	; FIRST FREE MEMORY ADDRESS
   02eb   87 00         	DB	FREE SHR 8 + 128,FREE AND 255
   02ed   22            	DB	'"'
   02ee   87 3b         	DB	SCHAR SHR 8 + 128,SCHAR AND 255
                        ;*	ADD MORE FUNCTIONS HERE
   02f0   86 93         	DB	XP40 SHR 8 + 128,XP40 AND 255
   02f2                 TAB5:	EQU	$	;"TO" IN "FOR" 
   02f2   54 4f         	DB	'TO'
   02f4   84 8b         	DB	FR1 SHR 8 + 128,FR1 AND 255
   02f6   88 4b         	DB	QWHAT SHR 8 + 128,QWHAT AND 255
   02f8                 TAB6:	EQU	$	;"STEP" IN "FOR" 
   02f8   53 54 45 50   	DB	'STEP'
   02fc   84 95         	DB	FR2 SHR 8 + 128,FR2 AND 255
   02fe   84 99         	DB	FR3 SHR 8 + 128,FR3 AND 255
   0300                 TAB8:	EQU	$	;RELATION OPERATORS
   0300   3e 3d         	DB	'>='
   0302   85 aa         	DB	XP11 SHR 8 + 128,XP11 AND 255
   0304   3c 3e         	DB	'<>'
   0306   85 b0         	DB	XP12 SHR 8 + 128,XP12 AND 255
   0308   3e            	DB	'>'
   0309   85 b6         	DB	XP13 SHR 8 + 128,XP13 AND 255
   030b   3d            	DB	'='
   030c   85 c5         	DB	XP15 SHR 8 + 128,XP15 AND 255
   030e   3c 3d         	DB	'<='
   0310   85 bd         	DB	XP14 SHR 8 + 128,XP14 AND 255
   0312   3c            	DB	'<'
   0313   85 cb         	DB	XP16 SHR 8 + 128,XP16 AND 255
   0315   85 d1         	DB	XP17 SHR 8 + 128,XP17 AND 255
                        ;* 
   0317   21 28 02      DIRECT:	LXI	H,TAB1-1 ;*** DIRECT ***
                        ;* 
   031a                 EXEC:	EQU	$	;*** EXEC ***
   031a   ef            EX0:	RST	5	;IGNORE LEADING BLANKS 
   031b   d5            	PUSH	D	;SAVE POINTER
   031c   1a            EX1:	LDAX	D	;IF FOUND '.' IN STRING
   031d   13            	INX	D	;BEFORE ANY MISMATCH 
   031e   fe 2e         	CPI	'.'	;WE DECLARE A MATCH
   0320   ca 39 03      	JZ	EX3 
   0323   23            	INX	H	;HL->TABLE 
   0324   be            	CMP	M	;IF MATCH, TEST NEXT 
   0325   ca 1c 03      	JZ	EX1 
   0328   3e 7f         	MVI	A,177Q	;ELSE, SEE IF BIT 7
   032a   1b            	DCX	D	;OF TABLE IS SET, WHICH
   032b   be            	CMP	M	;IS THE JUMP ADDR. (HI)
   032c   da 40 03      	JC	EX5	;C:YES, MATCHED
   032f   23            EX2:	INX	H	;NC:NO, FIND JUMP ADDR.
   0330   be            	CMP	M 
   0331   d2 2f 03      	JNC	EX2 
   0334   23            	INX	H	;BUMP TO NEXT TAB. ITEM
   0335   d1            	POP	D	;RESTORE STRING POINTER
   0336   c3 1a 03      	JMP	EX0	;TEST AGAINST NEXT ITEM
   0339   3e 7f         EX3:	MVI	A,177Q	;PARTIAL MATCH, FIND 
   033b   23            EX4:	INX	H	;JUMP ADDR., WHICH IS
   033c   be            	CMP	M	;FLAGGED BY BIT 7
   033d   d2 3b 03      	JNC	EX4 
   0340   7e            EX5:	MOV	A,M	;LOAD HL WITH THE JUMP 
   0341   23            	INX	H	;ADDRESS FROM THE TABLE
   0342   6e            	MOV	L,M 
   0343   e6 7f         	ANI	177Q	;MASK OFF BIT 7
   0345   67            	MOV	H,A 
   0346   f1            	POP	PSW	;CLEAN UP THE GARBAGE 
   0347   e9            	PCHL		;AND WE GO DO IT 
                        ;* 
                        ;**************************************************************
                        ;* 
                        ;* WHAT FOLLOWS IS THE CODE TO EXECUTE DIRECT AND STATEMENT
                        ;* COMMANDS.  CONTROL IS TRANSFERED TO THESE POINTS VIA THE
                        ;* COMMAND TABLE LOOKUP CODE OF 'DIRECT' AND 'EXEC' IN LAST
                        ;* SECTION.  AFTER THE COMMAND IS EXECUTED, CONTROL IS 
                        ;* TANSFERED TO OTHER SECTIONS AS FOLLOWS:
                        ;* 
                        ;* FOR 'LIST', 'NEW', AND 'STOP': GO BACK TO 'RSTART'
                        ;* FOR 'RUN': GO EXECUTE THE FIRST STORED LINE IF ANY; ELSE
                        ;* GO BACK TO 'RSTART'.
                        ;* FOR 'GOTO' AND 'GOSUB': GO EXECUTE THE TARGET LINE. 
                        ;* FOR 'RETURN' AND 'NEXT': GO BACK TO SAVED RETURN LINE.
                        ;* FOR ALL OTHERS: IF 'CURRNT' -> 0, GO TO 'RSTART', ELSE
                        ;* GO EXECUTE NEXT COMMAND.  (THIS IS DONE IN 'FINISH'.) 
                        ;* 
                        ;**************************************************************
                        ;* 
                        ;* *** NEW *** STOP *** RUN (& FRIENDS) *** & GOTO *** CLS *** 
                        ;* *** RNDMZ *** XSAVE *** XLOAD ***
                        ;* 
                        ;* 'NEW(CR)' SETS 'TXTUNF' TO POINT TO 'TXTBGN'
                        ;* 
                        ;* 'STOP(CR)' GOES BACK TO 'RSTART'
                        ;* 
                        ;* 'RUN(CR)' FINDS THE FIRST STORED LINE, STORES ITS ADDRESS (IN
                        ;* 'CURRNT'), AND STARTS TO EXECUTE IT.  NOTE THAT ONLY THOSE
                        ;* COMMANDS IN TAB2 ARE LEGAL FOR STORED PROGRAM.
                        ;* 
                        ;* THERE ARE 3 MORE ENTRIES IN 'RUN':
                        ;* 'RUNNXL' FINDS NEXT LINE, STORES ITS ADDR. AND EXECUTES IT. 
                        ;* 'RUNTSL' STORES THE ADDRESS OF THIS LINE AND EXECUTES IT. 
                        ;* 'RUNSML' CONTINUES THE EXECUTION ON SAME LINE.
                        ;* 
                        ;* 'GOTO EXPR(CR)' EVALUATES THE EXPRESSION, FIND THE TARGET 
                        ;* LINE, AND JUMP TO 'RUNTSL' TO DO IT.
                        ;* 
                        ;* 'CLS(CR)' SENDS AN ANSI TERMINAL CLEAR SCREEN AND HOME COMMAND
                        ;* TO CLEAR THE SCREEN
                        ;*
                        ;* 'RNDMZ(CR)' RANDOMIZES THE RANDOM NUMBER SEED USING RANDOM COUNTER
                        ;*
                        ;* 'XSAVE' WILL SAVE A PROGRAM ONTO ANOTHER COMPUTER USING XMODEM
                        ;*
                        ;* 'XLOAD' WILL LOAD A PROGRAM FROM ANOTHER COMPUTER USING XMODEM
                        ;*
                        ;* THE ORIGINAL XMODEM PROTOCOL WITH 128 BYTE PACKETS AND ARITHMETIC
                        ;* CHECKSUM IS USED.  
                        ;* SEE:
                        ;* 	http://techheap.packetizer.com/communication/modems/xmodem.html
                        ;* FOR MORE INFORMATION
                        ;*
   0348   cd 47 08      NEW:	CALL	ENDCHK	;*** NEW(CR) *** 
   034b   21 1a 20      	LXI	H,TXTBGN
   034e   22 18 20      	SHLD	TXTUNF
                        ;* 
   0351   cd 47 08      STOP:	CALL	ENDCHK	;*** STOP(CR) ***
   0354   c3 9e 01      	JMP	RSTART
                        ;* 
   0357   cd 47 08      RUN:	CALL	ENDCHK	;*** RUN(CR) ***
   035a   f5            	PUSH	PSW	;SAVE ACC
   035b   3e 10         	MVI	A,10H
   035d   30            	SIM		;CLEAR RST7.5 FF
   035e   fb            	EI		;ENABLE INTERRUPTS
   035f   f1            	POP	PSW
   0360   11 1a 20      	LXI	D,TXTBGN ;FIRST SAVED LINE
                        ;* 
   0363   21 00 00      RUNNXL:	LXI	H,0	;*** RUNNXL ***
   0366   cd 10 09      	CALL	FNDLNP	;FIND WHATEVER LINE #
   0369   da 9e 01      	JC	RSTART	;C:PASSED TXTUNF, QUIT 
                        ;* 
   036c   eb            RUNTSL:	XCHG		;*** RUNTSL ***
   036d   22 02 20      	SHLD	CURRNT	;SET 'CURRNT'->LINE #
   0370   eb            	XCHG 
   0371   13            	INX	D	;BUMP PASS LINE #
   0372   13            	INX	D 
                        ;* 
   0373                 RUNSML:	
   0373   cd e8 0d      	CALL	CKABRT	;*** RUNSML ***
   0376   21 51 02      	LXI	H,TAB2-1 ;FIND COMMAND IN TAB2
   0379   c3 1a 03      	JMP	EXEC	;AND EXECUTE IT
                        ;* 
   037c   df            GOTO:	RST	3	;*** GOTO EXPR *** 
   037d   d5            	PUSH	D	;SAVE FOR ERROR ROUTINE
   037e   cd 47 08      	CALL	ENDCHK	;MUST FIND A CR 
   0381   cd 08 09      	CALL	FNDLN	;FIND THE TARGET LINE
   0384   c2 fe 00      	JNZ	AHOW	;NO SUCH LINE #
   0387   f1            	POP	PSW	;CLEAR THE "PUSH DE" 
   0388   c3 6c 03      	JMP	RUNTSL	;GO DO IT
                        ;*
   038b   d5            CLS:	PUSH	D	;SAVE POINTER
   038c   af            	XRA	A
   038d   11 57 01      	LXI	D,CLSCR	;GET CLEAR SCREEN SEQUENCE
   0390   cd 31 09      	CALL	PRTSTG	;SEND IT
   0393   d1            	POP	D	;RESTORE POINTER
   0394   f7            	RST	6	;FINISH
                        ;*
   0395   d5            RNDMZ:	PUSH	D	;SAVE POINTER
   0396   2a b2 3f      	LHLD	RANDOM	;GET RANDOMIZED VALUE
   0399   eb            	XCHG
   039a   2a 14 20      	LHLD	SEED	;GET RANDOM SEED
   039d   19            	DAD	D	;ADD TOGETHER TO GET A RANDOMIZED SEED
   039e   7d            	MOV	A,L
   039f   b4            	ORA	H	;CHECK IF 0 (INVALID SEED)
   03a0   c2 a4 03      	JNZ	RNDMZ1
   03a3   2b            	DCX	H	;YES, HAPPENS TO BE 0, CHANGE TO FFFF
   03a4   22 14 20      RNDMZ1:	SHLD	SEED
   03a7   d1            	POP	D
   03a8   f7            	RST	6
                        ;*
   03a9   11 45 01      XLOAD:	LXI	D,XLMSG	;INDICATE READY FOR FILE
   03ac   97            	SUB	A
   03ad   cd 31 09      	CALL	PRTSTG	;SEND IT
   03b0   21 1a 20      	LXI	H,TXTBGN ;POINT TO THE START OF THE PROGRAM
   03b3   cd db 0c      	CALL	XRECV	;GET THE FILE
   03b6   c3 9e 01      	JMP	RSTART	;AND RETURN
                        ;*
   03b9   11 38 01      XSAVE:	LXI	D,XSMSG	;INDICATE FILE IS BEING SENT
   03bc   97            	SUB	A
   03bd   cd 31 09      	CALL	PRTSTG	;SEND IT
   03c0   2a 18 20      	LHLD	TXTUNF	;GET THE FREE POINTER
   03c3   2b            	DCX	H	;POINT TO LAST BYTE IN PROGRAM
   03c4   eb            	XCHG		;PUT IN D,E
   03c5   21 1a 20      	LXI	H,TXTBGN ;POINT  TO THE START OF THE PROGRAM
   03c8   cd 43 0c      	CALL	XSEND	;SEND THE FILE
   03cb   c3 9e 01      	JMP	RSTART	;AND RETURN
                        ;* 
                        ;************************************************************* 
                        ;* 
                        ;* *** LIST *** PRINT *** EDIT ***
                        ;* 
                        ;* LIST HAS TWO FORMS: 
                        ;* 'LIST(CR)' LISTS ALL SAVED LINES
                        ;* 'LIST #(CR)' START LIST AT THIS LINE #
                        ;* YOU CAN STOP THE LISTING WITH CONTROL-C
                        ;* 
                        ;* PRINT COMMAND IS 'PRINT ....:' OR 'PRINT ....(CR)'
                        ;* WHERE '....' IS A LIST OF EXPRESIONS, FORMATS, UNDERSCORES
                        ;* AND STRINGS.  THESE ITEMS ARE SEPARATED BY COMMAS.
                        ;* 
                        ;* A FORMAT IS A POUND SIGN (#) FOLLOWED BY A NUMBER.  IT CONTROLS
                        ;* THE NUMBER OF SPACES THE VALUE OF A EXPRESSION IS GOING TO 
                        ;* BE PRINTED.  IT STAYS EFFECTIVE FOR THE REST OF THE PRINT
                        ;* COMMAND UNLESS CHANGED BY ANOTHER FORMAT.  IF NO FORMAT IS
                        ;* SPECIFIED, 6 POSITIONS WILL BE USED.
                        ;*
                        ;* A '$' PROCEDING AN EXPRESSION INDICATES PRINT THE CHARACTER
                        ;* WHOSE VALUE IS DETERMINED BY THE EXPRESSION [LIKE CHR$()]
                        ;* 
                        ;* A STRING IS QUOTED IN A PAIR OF SINGLE QUOTES OR A PAIR OF
                        ;* DOUBLE QUOTES.  A BACKSLASH ALONE MEANS GENERATE
                        ;* A (CR) WITHOUT A (LF) 
                        ;* 
                        ;* A (CR/LF) IS GENERATED AFTER THE ENTIRE LIST HAS BEEN
                        ;* PRINTED OR IF THE LIST IS A NULL LIST.  HOWEVER IF THE LIST 
                        ;* ENDS WITH A COMMA, NO (CR/LF) IS GENERATED. 
                        ;*
                        ;* EDIT #(CR)  EDIT LINE #
                        ;* 
   03ce   3e 10         LIST:	MVI	A,10H
   03d0   30            	SIM		;CLEAR RST7.5 FF
   03d1   cd d5 00      	CALL	TSTNUM	;TEST IF THERE IS A #
   03d4   cd 47 08      	CALL	ENDCHK	;IF NO # WE GET A 0	
   03d7   cd 08 09      	CALL	FNDLN	;FIND THIS OR NEXT LINE
   03da   da 9e 01      	JC	RSTART	;C:PASSED TXTUNF 
   03dd   fb            	EI		;ENABLE INTERRUPTS
   03de   cd a0 09      LS1:	CALL	PRTLN	;PRINT THE LINE
   03e1   cd e8 0d      	CALL	CKABRT	;STOP IF HIT CONTROL-C
   03e4   cd 10 09      	CALL	FNDLNP	;FIND NEXT LINE
   03e7   da 9e 01      	JC	RSTART	;C:PASSED TXTUNF 
   03ea   c3 de 03      	JMP	LS1	;AND LOOP BACK 
                        ;* 
   03ed   0e 06         PRINT:	MVI	C,6	;C = # OF SPACES 
   03ef   cf            	RST	1	;IF NULL LIST & ":"
   03f0   3a            	DB	':'
   03f1   06            	DB	PR2 - $ - 1
   03f2   cd 0e 00      	CALL	CRLF	;GIVE CR-LF AND
   03f5   c3 73 03      	JMP	RUNSML	;CONTINUE RUNNING THE SAME LINE
   03f8   cf            PR2:	RST	1	;IF NULL LIST (CR) 
   03f9   0d            	DB	CR 
   03fa   06            	DB	PR0 - $ - 1
   03fb   cd 0e 00      	CALL	CRLF	;ALSO GIVE CR-LF AND 
   03fe   c3 63 03      	JMP	RUNNXL	;GO TO NEXT LINE 
   0401   cf            PR0:	RST	1	;ELSE IS IT FORMAT?
   0402   23            	DB	'#' 
   0403   05            	DB	PR1 - $ - 1
   0404   df            	RST	3	;YES, EVALUATE EXPR. 
   0405   4d            	MOV	C,L	;AND SAVE IT IN C
   0406   c3 1a 04      	JMP	PR3	;LOOK FOR MORE TO PRINT
   0409   cf            PR1:	RST	1	;PRINT ASCII VALUE?
   040a   24            	DB	'$'
   040b   08            	DB	PR4 - $ - 1
   040c   df            	RST	3	;EVALUE THE EXPR
   040d   7d            	MOV	A,L	;GET LOWER BYTE
   040e   cd 06 10      	CALL	COUT	;SEND THE CHARACTER
   0411   c3 1a 04      	JMP	PR3
   0414   cd 3d 09      PR4:	CALL	QTSTG	;OR IS IT A STRING?
   0417   c3 27 04      	JMP	PR8	;IF NOT, MUST BE EXPR. 
   041a   cf            PR3:	RST	1	;IF ",", GO FIND NEXT
   041b   2c            	DB	',' 
   041c   06            	DB 	PR6 - $ - 1
   041d   cd 38 08      	CALL	FIN	;IN THE LIST.
   0420   c3 01 04      	JMP	PR0	;LIST CONTINUES
   0423   cd 0e 00      PR6:	CALL	CRLF	;LIST ENDS 
   0426   f7            	RST	6 
   0427   df            PR8:	RST	3	;EVALUATE THE EXPR 
   0428   c5            	PUSH	B 
   0429   cd 64 09      	CALL	PRTNUM	;PRINT THE VALUE 
   042c   c1            	POP	B 
   042d   c3 1a 04      	JMP	PR3	;MORE TO PRINT?
                        ;*
   0430   cd d5 00      EDIT:	CALL	TSTNUM	;TEST IF THERE IS A #
   0433   cd 47 08      	CALL	ENDCHK	;IF NO # WE GET A 0	
   0436   cd 08 09      	CALL	FNDLN	;FIND THIS OR NEXT LINE (D = LINE #)
   0439   da fd 00      	JC	QHOW	;C:PASSED TXTUNF 
   043c   c2 4b 08      	JNZ	QWHAT	;NO SUCH LINE #
   043f   c3 10 0a      	JMP	EDITOR	;EDIT THE LINE
                        	
                        ;* 
                        ;**************************************************************
                        ;* 
                        ;* *** GOSUB *** & RETURN ***
                        ;* 
                        ;* 'GOSUB EXPR;' OR 'GOSUB EXPR (CR)' IS LIKE THE 'GOTO' 
                        ;* COMMAND, EXCEPT THAT THE CURRENT TEXT POINTER, STACK POINTER
                        ;* ETC. ARE SAVED SO THAT EXECUTION CAN BE CONTINUED AFTER THE
                        ;* SUBROUTINE 'RETURN'.  IN ORDER THAT 'GOSUB' CAN BE NESTED 
                        ;* (AND EVEN RECURSIVE), THE SAVE AREA MUST BE STACKED.
                        ;* THE STACK POINTER IS SAVED IN 'STKGOS'. THE OLD 'STKGOS' IS 
                        ;* SAVED IN THE STACK.  IF WE ARE IN THE MAIN ROUTINE, 'STKGOS'
                        ;* IS ZERO (THIS WAS DONE BY THE "MAIN" SECTION OF THE CODE),
                        ;* BUT WE STILL SAVE IT AS A FLAG FORr NO FURTHER 'RETURN'S.
                        ;* 
                        ;* 'RETURN(CR)' UNDOES EVERYTHING THAT 'GOSUB' DID, AND THUS
                        ;* RETURN THE EXECUTION TO THE COMMAND AFTER THE MOST RECENT
                        ;* 'GOSUB'.  IF 'STKGOS' IS ZERO, IT INDICATES THAT WE 
                        ;* NEVER HAD A 'GOSUB' AND IS THUS AN ERROR. 
                        ;* 
   0442   cd e7 09      GOSUB:	CALL	PUSHA	;SAVE THE CURRENT "FOR"
   0445   df            	RST	3	;PARAMETERS
   0446   d5            	PUSH	D	;AND TEXT POINTER
   0447   cd 08 09      	CALL	FNDLN	;FIND THE TARGET LINE
   044a   c2 fe 00      	JNZ	AHOW	;NOT THERE. SAY "HOW?" 
   044d   2a 02 20      	LHLD	CURRNT	;FOUND IT, SAVE OLD
   0450   e5            	PUSH	H	;'CURRNT' OLD 'STKGOS' 
   0451   2a 04 20      	LHLD	STKGOS
   0454   e5            	PUSH	H 
   0455   21 00 00      	LXI	H,0	;AND LOAD NEW ONES 
   0458   22 0a 20      	SHLD	LOPVAR
   045b   39            	DAD	SP
   045c   22 04 20      	SHLD	STKGOS
   045f   c3 6c 03      	JMP	RUNTSL	;THEN RUN THAT LINE
                        ;*
   0462   cd 47 08      RETURN:	CALL	ENDCHK	;THERE MUST BE A CR 
   0465   2a 04 20      	LHLD	STKGOS	;OLD STACK POINTER 
   0468   7c            	MOV	A,H	;0 MEANS NOT EXIST 
   0469   b5            	ORA	L 
   046a   ca 4b 08      	JZ	QWHAT	;SO, WE SAY: "WHAT?" 
   046d   f9            	SPHL		;ELSE, RESTORE IT
   046e   e1            	POP	H 
   046f   22 04 20      	SHLD	STKGOS	;AND THE OLD 'STKGOS'
   0472   e1            	POP	H 
   0473   22 02 20      	SHLD	CURRNT	;AND THE OLD 'CURRNT'
   0476   d1            	POP	D	;OLD TEXT POINTER
   0477   cd cb 09      	CALL	POPA	;OLD "FOR" PARAMETERS
   047a   f7            	RST	6	;AND WE ARE BACK HOME
                        ;* 
                        ;**************************************************************
                        ;* 
                        ;* *** FOR *** & NEXT ***
                        ;* 
                        ;* 'FOR' HAS TWO FORMS:
                        ;* 'FOR VAR=EXP1 TO EXP2 STEP EXP1' AND 'FOR VAR=EXP1 TO EXP2' 
                        ;* THE SECOND FORM MEANS THE SAME THING AS THE FIRST FORM WITH 
                        ;* EXP1=1.  (I.E., WITH A STEP OF +1.) 
                        ;* TBI WILL FIND THE VARIABLE VAR. AND SET ITS VALUE TO THE
                        ;* CURRENT VALUE OF EXP1.  IT ALSO EVALUATES EXPR2 AND EXP1
                        ;* AND SAVES ALL THESE TOGETHER WITH THE TEXT POINTER ETC. IN 
                        ;* THE 'FOR' SAVE AREA, WHICH CONSISTS OF 'LOPVAR', 'LOPINC',
                        ;* 'LOPLMT', 'LOPLN', AND 'LOPPT'.  IF THERE IS ALREADY SOME-
                        ;* THING IN THE SAVE AREA (THIS IS INDICATED BY A NON-ZERO 
                        ;* 'LOPVAR'), THEN THE OLD SAVE AREA IS SAVED IN THE STACK 
                        ;* BEFORE THE NEW ONE OVERWRITES IT. 
                        ;* TBI WILL THEN DIG IN THE STACK AND FIND OUT IF THIS SAME
                        ;* VARIABLE WAS USED IN ANOTHER CURRENTLY ACTIVE 'FOR' LOOP. 
                        ;* IF THAT IS THE CASE THEN THE OLD 'FOR' LOOP IS DEACTIVATED.
                        ;* (PURGED FROM THE STACK..) 
                        ;* 
                        ;* 'NEXT VAR' SERVES AS THE LOGICAL (NOT NECESSARILLY PHYSICAL)
                        ;* END OF THE 'FOR' LOOP.  THE CONTROL VARIABLE VAR. IS CHECKED
                        ;* WITH THE 'LOPVAR'.  IF THEY ARE NOT THE SAME, TBI DIGS IN 
                        ;* THE STACK TO FIND THE RIGHT ONE AND PURGES ALL THOSE THAT 
                        ;* DID NOT MATCH.  EITHER WAY, TBI THEN ADDS THE 'STEP' TO 
                        ;* THAT VARIABLE AND CHECKS THE RESULT WITH THE LIMIT.  IF IT 
                        ;* IS WITHIN THE LIMIT, CONTROL LOOPS BACK TO THE COMMAND
                        ;* FOLLOWING THE 'FOR'.  IF OUTSIDE THE LIMIT, THE SAVE AREA 
                        ;* IS PURGED AND EXECUTION CONTINUES.
                        ;* 
   047b   cd e7 09      FOR:	CALL	PUSHA	;SAVE THE OLD SAVE AREA
   047e   cd 25 08      	CALL	SETVAL	;SET THE CONTROL VAR.
   0481   2b            	DCX	H	;HL IS ITS ADDRESS 
   0482   22 0a 20      	SHLD	LOPVAR	;SAVE THAT 
   0485   21 f1 02      	LXI	H,TAB5-1 ;USE 'EXEC' TO LOOK
   0488   c3 1a 03      	JMP	EXEC	;FOR THE WORD 'TO' 
   048b   df            FR1:	RST	3	;EVALUATE THE LIMIT
   048c   22 0e 20      	SHLD	LOPLMT	;SAVE THAT 
   048f   21 f7 02      	LXI	H,TAB6-1  ;USE 'EXEC' TO LOOK
   0492   c3 1a 03      	JMP	EXEC	;FOR THE WORD 'STEP'
   0495   df            FR2:	RST	3	;FOUND IT, GET STEP
   0496   c3 9c 04      	JMP	FR4 
   0499   21 01 00      FR3:	LXI	H,1	;NOT FOUND, SET TO 1 
   049c   22 0c 20      FR4:	SHLD	LOPINC	;SAVE THAT TOO 
   049f   2a 02 20      FR5:	LHLD	CURRNT	;SAVE CURRENT LINE # 
   04a2   22 10 20      	SHLD	LOPLN 
   04a5   eb            	XCHG		;AND TEXT POINTER
   04a6   22 12 20      	SHLD	LOPPT 
   04a9   01 0a 00      	LXI	B,10	;DIG INTO STACK TO 
   04ac   2a 0a 20      	LHLD	LOPVAR	;FIND 'LOPVAR' 
   04af   eb            	XCHG 
   04b0   60            	MOV	H,B 
   04b1   68            	MOV	L,B	;HL=0 NOW
   04b2   39            	DAD	SP	;HERE IS THE STACK 
   04b3   3e            	DB	76Q 	; MVI A, TRICK (SKIP)
   04b4   09            FR7:	DAD	B	;EACH LEVEL IS 10 DEEP 
   04b5   7e            	MOV	A,M	;GET THAT OLD 'LOPVAR' 
   04b6   23            	INX	H 
   04b7   b6            	ORA	M 
   04b8   ca d5 04      	JZ	FR8	;0 SAYS NO MORE IN IT
   04bb   7e            	MOV	A,M 
   04bc   2b            	DCX	H 
   04bd   ba            	CMP	D	;SAME AS THIS ONE? 
   04be   c2 b4 04      	JNZ	FR7 
   04c1   7e            	MOV	A,M	;THE OTHER HALF? 
   04c2   bb            	CMP	E 
   04c3   c2 b4 04      	JNZ	FR7 
   04c6   eb            	XCHG		;YES, FOUND ONE
   04c7   21 00 00      	LXI	H,0
   04ca   39            	DAD	SP	;TRY TO MOVE SP
   04cb   44            	MOV	B,H 
   04cc   4d            	MOV	C,L 
   04cd   21 0a 00      	LXI	H,10 
   04d0   19            	DAD	D 
   04d1   cd bc 09      	CALL	MVDOWN	;AND PURGE 10 WORDS
   04d4   f9            	SPHL		;IN THE STACK
   04d5   2a 12 20      FR8:	LHLD	LOPPT	;JOB DONE, RESTORE DE
   04d8   eb            	XCHG 
   04d9   f7            	RST	6	;AND CONTINUE
                        ;* 
   04da   ff            NEXT:	RST	7	;GET ADDRESS OF VAR. 
   04db   da 4b 08      	JC	QWHAT	;NO VARIABLE, "WHAT?"
   04de   22 06 20      	SHLD	VARNXT	;YES, SAVE IT
   04e1   d5            NX0:	PUSH	D	;SAVE TEXT POINTER 
   04e2   eb            	XCHG 
   04e3   2a 0a 20      	LHLD	LOPVAR	;GET VAR. IN 'FOR' 
   04e6   7c            	MOV	A,H 
   04e7   b5            	ORA	L	;0 SAYS NEVER HAD ONE
   04e8   ca 4c 08      	JZ	AWHAT	;SO WE ASK: "WHAT?"
   04eb   e7            	RST	4	;ELSE WE CHECK THEM
   04ec   ca f9 04      	JZ	NX3	;OK, THEY AGREE
   04ef   d1            	POP	D	;NO, LET'S SEE 
   04f0   cd cb 09      	CALL	POPA	;PURGE CURRENT LOOP
   04f3   2a 06 20      	LHLD	VARNXT	;AND POP ONE LEVEL 
   04f6   c3 e1 04      	JMP	NX0	;GO CHECK AGAIN
   04f9   5e            NX3:	MOV	E,M	;COME HERE WHEN AGREED 
   04fa   23            	INX	H 
   04fb   56            	MOV	D,M	;DE=VALUE OF VAR.
   04fc   2a 0c 20      	LHLD	LOPINC
   04ff   e5            	PUSH	H 
   0500   19            	DAD	D	;ADD ONE STEP
   0501   eb            	XCHG 
   0502   2a 0a 20      	LHLD	LOPVAR	;PUT IT BACK 
   0505   73            	MOV	M,E 
   0506   23            	INX	H 
   0507   72            	MOV	M,D 
   0508   2a 0e 20      	LHLD	LOPLMT	;HL->LIMIT 
   050b   f1            	POP	PSW	;OLD HL
   050c   b7            	ORA	A 
   050d   f2 11 05      	JP	NX1	;STEP > 0
   0510   eb            	XCHG 
   0511   cd 1d 08      NX1:	CALL	CKHLDE	;COMPARE WITH LIMIT
   0514   d1            	POP	D	;RESTORE TEXT POINTER
   0515   da 23 05      	JC	NX2	;OUTSIDE LIMIT 
   0518   2a 10 20      	LHLD	LOPLN	;WITHIN LIMIT, GO
   051b   22 02 20      	SHLD	CURRNT	;BACK TO THE SAVED 
   051e   2a 12 20      	LHLD	LOPPT	;'CURRNT' AND TEXT 
   0521   eb            	XCHG		;POINTER 
   0522   f7            	RST	6 
   0523   cd cb 09      NX2:	CALL	POPA	;PURGE THIS LOOP 
   0526   f7            	RST	6 
                        ;* 
                        ;**************************************************************
                        ;* 
                        ;* *** REM *** IF *** INPUT *** & LET (& DEFLT) ***
                        ;* 
                        ;* 'REM' CAN BE FOLLOWED BY ANYTHING AND IS IGNORED BY TBI.
                        ;* TBI TREATS IT LIKE AN 'IF' WITH A FALSE CONDITION.
                        ;* 
                        ;* 'IF' IS FOLLOWED BY AN EXPR. AS A CONDITION AND ONE OR MORE 
                        ;* COMMANDS (INCLUDING OTHER 'IF'S) SEPERATED BY SEMI-COLONS. 
                        ;* NOTE THAT THE WORD 'THEN' IS NOT USED.  TBI EVALUATES THE 
                        ;* EXPR. IF IT IS NON-ZERO, EXECUTION CONTINUES.  IF THE 
                        ;* EXPR. IS ZERO, THE COMMANDS THAT FOLLOWS ARE IGNORED AND
                        ;* EXECUTION CONTINUES AT THE NEXT LINE. 
                        ;* 
                        ;* 'INPUT' COMMAND IS LIKE THE 'PRINT' COMMAND, AND IS FOLLOWED
                        ;* BY A LIST OF ITEMS.  IF THE ITEM IS A STRING IN SINGLE OR 
                        ;* DOUBLE QUOTES, OR IS A BACK-ARROW, IT HAS THE SAME EFFECT AS
                        ;* IN 'PRINT'.  IF AN ITEM IS A VARIABLE, THIS VARIABLE NAME IS
                        ;* PRINTED OUT FOLLOWED BY A COLON.  THEN TBI WAITS FOR AN 
                        ;* EXPR. TO BE TYPED IN.  THE VARIABLE IS THEN SET TO THE
                        ;* VALUE OF THIS EXPR.  IF THE VARIABLE IS PROCEDED BY A STRING
                        ;* (AGAIN IN SINGLE OR DOUBLE QUOTES), THE STRING WILL BE
                        ;* PRINTED FOLLOWED BY A COLON.  TBI THEN WAITS FOR INPUT EXPR.
                        ;* AND SETS THE VARIABLE TO THE VALUE OF THE EXPR.
                        ;* 
                        ;* IF THE INPUT EXPR. IS INVALID, TBI WILL PRINT "WHAT?",
                        ;* "HOW?" OR "SORRY" AND REPRINT THE PROMPT AND REDO THE INPUT.
                        ;* THE EXECUTION WILL NOT TERMINATE UNLESS YOU TYPE CONTROL-C. 
                        ;* THIS IS HANDLED IN 'INPERR'.
                        ;* 
                        ;* 'LET' IS FOLLOWED BY A LIST OF ITEMS SEPERATED BY COMMAS. 
                        ;* EACH ITEM CONSISTS OF A VARIABLE, AN EQUAL SIGN, AND AN EXPR. 
                        ;* TBI EVALUATES THE EXPR. AND SETS THE VARIBLE TO THAT VALUE.
                        ;* TB WILL ALSO HANDLE 'LET' COMMAND WITHOUT THE WORD 'LET'.
                        ;* THIS IS DONE BY 'DEFLT'.
                        ;* 
   0527   21 00 00      REM:	LXI	H,0	;*** REM *** 
   052a   3e            	DB	76Q 	; SKIP RST 3
                        ;* 
   052b   df            IFF:	RST	3	;*** IFF ***
   052c   7c            	MOV	A,H	;IS THE EXPR.=0? 
   052d   b5            	ORA	L 
   052e   c2 73 03      	JNZ	RUNSML	;NO, CONTINUE
   0531   cd 26 09      	CALL	FNDSKP	;YES, SKIP REST OF LINE
   0534   d2 6c 03      	JNC	RUNTSL	;SAVE AND RUN
   0537   c3 9e 01      	JMP	RSTART	;NO, NEXT, RESTART
                        ;* 
   053a   2a 08 20      INPERR:	LHLD	STKINP	;*** INPERR ***
   053d   f9            	SPHL		;RESTORE OLD SP
   053e   e1            	POP	H	;AND OLD 'CURRNT'
   053f   22 02 20      	SHLD	CURRNT
   0542   d1            	POP	D	;AND OLD TEXT POINTER
   0543   d1            	POP	D	;REDO INPUT
                        ;* 
   0544                 INPUT:	EQU	$	;*** INPUT *** 
   0544   d5            IP1:	PUSH	D	;SAVE IN CASE OF ERROR 
   0545   cd 3d 09      	CALL	QTSTG	;IS NEXT ITEM A STRING?
   0548   c3 52 05      	JMP	IP2	;NO  (YES, SKIPPED BY QTSTG)
   054b   ff            	RST	7	;YES. BUT FOLLOWED BY A
   054c   da 8c 05      	JC	IP4	;VARIABLE?   NO. 
   054f   c3 62 05      	JMP	IP3	;YES.  INPUT VARIABLE
   0552   d5            IP2:	PUSH	D	;SAVE FOR 'PRTSTG' 
   0553   ff            	RST	7	;MUST BE VARIABLE NOW
   0554   da 4b 08      	JC	QWHAT	;"WHAT?" IT IS NOT?
   0557   1a            	LDAX	D	;GET READY FOR 'PRTSTG'
   0558   4f            	MOV	C,A 
   0559   97            	SUB	A 
   055a   12            	STAX	D 
   055b   d1            	POP	D 
   055c   cd 31 09      	CALL	PRTSTG	;PRINT STRING AS PROMPT
   055f   79            	MOV	A,C	;RESTORE TEXT
   0560   1b            	DCX	D 
   0561   12            	STAX	D 
   0562   d5            IP3:	PUSH	D	;SAVE IN CASE OF ERROR 
   0563   eb            	XCHG 
   0564   2a 02 20      	LHLD	CURRNT	;ALSO SAVE 'CURRNT'
   0567   e5            	PUSH	H 
   0568   21 44 05      	LXI	H,IP1	;A NEGATIVE NUMBER 
   056b   22 02 20      	SHLD	CURRNT	;AS A FLAG 
   056e   21 00 00      	LXI	H,0Q	;SAVE SP TOO 
   0571   39            	DAD	SP
   0572   22 08 20      	SHLD	STKINP
   0575   d5            	PUSH	D	;OLD HL
   0576   3e 3a         	MVI	A,':'	;PRINT THIS TOO
   0578   cd 7f 08      	CALL	GETLN	;AND GET A LINE
   057b   11 38 3e      IP3A:	LXI	D,BUFFER ;POINTS TO BUFFER
   057e   df            	RST	3	;EVALUATE INPUT
   057f   00            	NOP		;CAN BE 'CALL ENDCHK'
   0580   00            	NOP
   0581   00            	NOP
   0582   d1            	POP	D	;OK, GET OLD HL
   0583   eb            	XCHG 
   0584   73            	MOV	M,E	;SAVE VALUE IN VAR.
   0585   23            	INX	H 
   0586   72            	MOV	M,D 
   0587   e1            	POP	H	;GET OLD 'CURRNT'
   0588   22 02 20      	SHLD	CURRNT
   058b   d1            	POP	D	;AND OLD TEXT POINTER
   058c   f1            IP4:	POP	PSW	;PURGE JUNK IN STACK 
   058d   cf            	RST	1	;IS NEXT CH. ','?
   058e   2c            	DB	',' 
   058f   03            	DB	IP5 - $ - 1
   0590   c3 44 05      	JMP	IP1	;YES, MORE ITEMS.
   0593   f7            IP5:	RST	6 
                        ;* 
   0594   1a            DEFLT:	LDAX	D	;*** DEFLT *** 
   0595   fe 0d         	CPI	CR 	;EMPTY LINE IS OK
   0597   ca a3 05      	JZ	LT1	;ELSE IT IS 'LET'
                        ;* 
   059a   cd 25 08      LET:	CALL	SETVAL	;*** LET *** 
   059d   cf            	RST	1	;SET VALUE TO VAR. 
   059e   2c            	DB	',' 
   059f   03            	DB	LT1 - $ - 1
   05a0   c3 9a 05      	JMP	LET	;ITEM BY ITEM
   05a3   f7            LT1:	RST	6	;UNTIL FINISH
                        ;* 
                        ;**************************************************************
                        ;* 
                        ;* *** EXPR ***
                        ;* 
                        ;* 'EXPR' EVALUATES ARITHMETICAL OR LOGICAL EXPRESSIONS. 
                        ;* <EXPR>::=<EXPR2>
                        ;*          <EXPR2><REL.OP.><EXPR2>
                        ;* WHERE <REL.OP.> IS ONE OF THE OPERATORSs IN TAB8 AND THE 
                        ;* RESULT OF THESE OPERATIONS IS 1 IF TRUE AND 0 IF FALSE. 
                        ;* <EXPR2>::=(+ OR -)<EXPR3>(+ OR -<EXPR3>)(....)
                        ;* WHERE () ARE OPTIONAL AND (....) ARE OPTIONAL REPEATS.
                        ;* <EXPR3>::=<EXPR4>(<* OR / OR %><EXPR4>)(....)
                        ;* <EXPR4>::=<VARIABLE>
                        ;*           <FUNCTION>
                        ;*           (<EXPR>)
                        ;* <EXPR> IS RECURSIVE SO THAT VARIABLE '@' CAN HAVE AN <EXPR> 
                        ;* AS INDEX, FUNCTIONS CAN HAVE AN <EXPR> AS ARGUMENTS, AND
                        ;* <EXPR4> CAN BE AN <EXPR> IN PARENTHESES. 
                        ;* 
                        ;* EXPR CALL EXPR2     THIS IS AT LOC. 18
                        ;*      PUSH HL        SAVE <EXPR2> VALUE
   05a4   21 ff 02      EXPR1:	LXI	H,TAB8-1 ;LOOKUP REL.OP.
   05a7   c3 1a 03      	JMP	EXEC	;GO DO IT
   05aa   cd d3 05      XP11:	CALL	XP18	;REL.OP.">=" 
   05ad   d8            	RC		;NO, RETURN HL=0 
   05ae   6f            	MOV	L,A	;YES, RETURN HL=1
   05af   c9            	RET
   05b0   cd d3 05      XP12:	CALL	XP18	;REL.OP."<>"
   05b3   c8            	RZ		;FALSE, RETURN HL=0
   05b4   6f            	MOV	L,A	;TRUE, RETURN HL=1 
   05b5   c9            	RET
   05b6   cd d3 05      XP13:	CALL	XP18	;REL.OP.">"
   05b9   c8            	RZ		;FALSE 
   05ba   d8            	RC		;ALSO FALSE, HL=0
   05bb   6f            	MOV	L,A	;TRUE, HL=1
   05bc   c9            	RET
   05bd   cd d3 05      XP14:	CALL	XP18	;REL.OP."<=" 
   05c0   6f            	MOV	L,A	;SET HL=1
   05c1   c8            	RZ		;REL. TRUE, RETURN 
   05c2   d8            	RC 
   05c3   6c            	MOV	L,H	;ELSE SET HL=0 
   05c4   c9            	RET
   05c5   cd d3 05      XP15:	CALL 	XP18	;REL.OP."="
   05c8   c0            	RNZ		;FALSE, RETRUN HL=0
   05c9   6f            	MOV	L,A	;ELSE SET HL=1 
   05ca   c9            	RET
   05cb   cd d3 05      XP16:	CALL	XP18	;REL.OP."<"
   05ce   d0            	RNC		;FALSE, RETURN HL=0
   05cf   6f            	MOV	L,A	;ELSE SET HL=1 
   05d0   c9            	RET
   05d1   e1            XP17:	POP	H	;NOT REL.OP. 
   05d2   c9            	RET		;RETURN HL=<EXPR2> 
   05d3   79            XP18:	MOV	A,C	;SUBROUTINE FOR ALL
   05d4   e1            	POP	H	;REL.OP.'S 
   05d5   c1            	POP	B 
   05d6   e5            	PUSH	H	;REVERSE TOP OF STACK
   05d7   c5            	PUSH	B 
   05d8   4f            	MOV	C,A 
   05d9   cd e8 05      	CALL	EXPR2	;GET 2ND <EXPR2> 
   05dc   eb            	XCHG		;VALUE IN DE NOW 
   05dd   e3            	XTHL		;1ST <EXPR2> IN HL 
   05de   cd 1d 08      	CALL	CKHLDE	;COMPARE 1ST WITH 2ND
   05e1   d1            	POP	D	;RESTORE TEXT POINTER
   05e2   21 00 00      	LXI	H,0Q	;SET HL=0, A=1 
   05e5   3e 01         	MVI	A,1 
   05e7   c9            	RET
                        ;* 
   05e8   cf            EXPR2:	RST	1	;NEGATIVE SIGN?
   05e9   2d            	DB	'-' 
   05ea   06            	DB	XP21 - $ - 1
   05eb   21 00 00      	LXI	H,0Q	;YES, FAKE '0-'
   05ee   c3 12 06      	JMP	XP26	;TREAT LIKE SUBTRACT 
   05f1   cf            XP21:	RST	1	;POSITIVE SIGN?  IGNORE
   05f2   2b            	DB	'+' 
   05f3   00            	DB	XP22 - $ - 1
   05f4   cd 1c 06      XP22:	CALL	EXPR3	;1ST <EXPR3> 
   05f7   cf            XP23:	RST	1	;ADD?
   05f8   2b            	DB	'+' 
   05f9   15            	DB	XP25 - $ - 1
   05fa   e5            	PUSH	H	;YES, SAVE VALUE 
   05fb   cd 1c 06      	CALL	EXPR3	;GET 2ND<EXPR3> 
   05fe   eb            XP24:	XCHG		;2ND IN DE 
   05ff   e3            	XTHL		;1ST IN HL 
   0600   7c            	MOV	A,H	;COMPARE SIGN
   0601   aa            	XRA	D 
   0602   7a            	MOV	A,D 
   0603   19            	DAD	D 
   0604   d1            	POP	D	;RESTORE TEXT POINTER
   0605   fa f7 05      	JM	XP23	;1ST 2ND SIGN DIFFER 
   0608   ac            	XRA	H	;1ST 2ND SIGN EQUAL
   0609   f2 f7 05      	JP	XP23	;SO IS RESULT
   060c   c3 fd 00      	JMP	QHOW	;ELSE WE HAVE OVERFLOW 
   060f   cf            XP25:	RST	1	;SUBTRACT? 
   0610   2d            	DB	'-' 
   0611   97            	DB	XP42 - $ - 1
   0612   e5            XP26:	PUSH	H	;YES, SAVE 1ST <EXPR3> 
   0613   cd 1c 06      	CALL	EXPR3	;GET 2ND <EXPR3> 
   0616   cd 11 08      	CALL	CHGSGN	;NEGATE
   0619   c3 fe 05      	JMP	XP24	;AND ADD THEM
                        ;* 
   061c   cd 8d 06      EXPR3:	CALL	EXPR4	;GET 1ST <EXPR4> 
   061f   cf            XP31:	RST	1	;MULTIPLY? 
   0620   2a            	DB	'*' 
   0621   22            	DB	XP34 - $ - 1
   0622   e5            	PUSH	H	;YES, SAVE 1ST 
   0623   cd 8d 06      	CALL	EXPR4	;AND GET 2ND <EXPR4> 
   0626   06 00         	MVI	B,0Q	;CLEAR B FOR SIGN
   0628   cd 0e 08      	CALL	CHKSGN	;CHECK SIGN
   062b   eb            	XCHG		;2ND IN DE NOW 
   062c   e3            	XTHL		;1ST IN HL 
   062d   cd 0e 08      	CALL	CHKSGN	;CHECK SIGN OF 1ST 
   0630   7c            	MOV	A,H	;IS HL > 255 ? 
   0631   b7            	ORA	A 
   0632   ca 3b 06      	JZ	XP32	;NO
   0635   7a            	MOV	A,D	;YES, HOW ABOUT DE 
   0636   b2            	ORA	D 
   0637   eb            	XCHG		;PUT SMALLER IN HL 
   0638   c2 fe 00      	JNZ	AHOW	;ALSO >, WILL OVERFLOW 
   063b   cd de 07      XP32:	CALL	MULTPY	;HL = E * L
   063e   da fe 00      	JC	AHOW	;OVERFLOW
                        ;*
                        ;* ORIGINAL MULTIPLY LOOP
                        ;XP32:	MOV	A,L	;THIS IS DUMB
                        ;	LXI	H,0Q	;CLEAR RESULT
                        ;	ORA	A	;ADD AND COUNT 
                        ;	JZ	XP35
                        ;XP33:	DAD	D 
                        ;	JC	AHOW	;OVERFLOW
                        ;	DCR	A 
                        ;	JNZ	XP33
                        ;*
   0641   c3 7f 06      	JMP	XP35	;FINISHED
                        ;*
   0644   cf            XP34:	RST	1	;DIVIDE? 
   0645   2f            	DB	'/' 
   0646   1d            	DB	XP34A - $ - 1
   0647   e5            	PUSH	H	;YES, SAVE 1ST <EXPR4> 
   0648   cd 8d 06      	CALL	EXPR4	;AND GET 2ND ONE 
   064b   06 00         	MVI	B,0Q	;CLEAR B FOR SIGN
   064d   cd 0e 08      	CALL	CHKSGN	;CHECK SIGN OF 2ND 
   0650   eb            	XCHG		;PUT 2ND IN DE 
   0651   e3            	XTHL		;GET 1ST IN HL 
   0652   cd 0e 08      	CALL	CHKSGN	;CHECK SIGN OF 1ST 
   0655   7a            	MOV	A,D	;DIVIDE BY 0?
   0656   b3            	ORA	E 
   0657   ca fe 00      	JZ	AHOW	;SAY "HOW?"
   065a   c5            	PUSH	B	;ELSE SAVE SIGN
   065b   cd f1 07      	CALL	DIVIDE	;USE SUBROUTINE
   065e   60            	MOV	H,B	;PUT RESULT IN HL
   065f   69            	MOV	L,C 
   0660   c1            	POP	B	;GET SIGN BACK 
   0661   c3 7f 06      	JMP	XP35	;FINISHED
                        ;*	
   0664   cf            XP34A:	RST	1	;MODULO?
   0665   25            	DB	'%'
   0666   42            	DB	XP42 - $ - 1
   0667   e5            	PUSH	H	;YES, SAVE 1ST <EXPR4> 
   0668   cd 8d 06      	CALL	EXPR4	;AND GET 2ND ONE 
   066b   cd 0e 08      	CALL	CHKSGN	;CHECK SIGN OF 2ND 
   066e   eb            	XCHG		;PUT 2ND IN DE 
   066f   e3            	XTHL		;GET 1ST IN HL 
   0670   cd 0e 08      	CALL	CHKSGN	;CHECK SIGN OF 1ST 
   0673   7a            	MOV	A,D	;DIVIDE BY 0?
   0674   b3            	ORA	E 
   0675   ca fe 00      	JZ	AHOW	;SAY "HOW?"
   0678   06 00         	MVI	B,0Q	;CLEAR B FOR POSITIVE SIGN
   067a   c5            	PUSH	B	;SAVE C
   067b   cd f1 07      	CALL	DIVIDE	;USE SUBROUTINE
   067e   c1            	POP	B
                        			;REMAINDER IN HL
                        			;MODULO IS ALWAYS POSITIVE
   067f   d1            XP35:	POP	D	;RESTORE TEXT POINTER
   0680   7c            	MOV	A,H	;HL MUST BE +
   0681   b7            	ORA	A 
   0682   fa fd 00      	JM	QHOW	;ELSE IT IS OVERFLOW 
   0685   78            	MOV	A,B 
   0686   b7            	ORA	A 
   0687   fc 11 08      	CM	CHGSGN	;CHANGE SIGN IF NEEDED 
   068a   c3 1f 06      	JMP	XP31	;LOOK OR MORE TERMS 
                        ;* 
   068d   21 c6 02      EXPR4:	LXI	H,TAB4-1 ;FIND FUNCTION IN TAB4 
   0690   c3 1a 03      	JMP	EXEC	;AND GO DO IT
   0693   ff            XP40:	RST	7	;NO, NOT A FUNCTION
   0694   da 9c 06      	JC	XP41	;NOR A VARIABLE
   0697   7e            	MOV	A,M	;VARIABLE
   0698   23            	INX	H 
   0699   66            	MOV	H,M	;VALUE IN HL 
   069a   6f            	MOV	L,A 
   069b   c9            	RET
   069c   cd d5 00      XP41:	CALL	TSTNUM	;OR IS IT A NUMBER 
   069f   78            	MOV	A,B	;# OF DIGIT
   06a0   b7            	ORA	A 
   06a1   c0            	RNZ		;OK
   06a2   cf            PARN:	RST	1	;NO DIGIT, MUST BE 
   06a3   28            	DB	'(' 
   06a4   05            	DB	XP43 - $ - 1
   06a5   df            	RST	3	;"(EXPR)"
   06a6   cf            	RST	1 
   06a7   29            	DB	')' 
   06a8   01            	DB	XP43 - $ - 1
   06a9   c9            XP42:	RET
   06aa   c3 4b 08      XP43:	JMP	QWHAT	;ELSE SAY: "WHAT?" 
                        ;*
                        ;*
                        ;*********************************************************
                        ;*
                        ;*   *** RND *** ABS *** SIZE *** FREE 
                        ;*
                        ;*  RND(X)
                        ;*  RETURNS A RANDOM NUMBER BETWEEN 1 AND X (INCLUSIVE)
                        ;*
                        ;*  ABS(X)
                        ;*  RETURNS THE ABSOLUTE VALUE OF X
                        ;*
                        ;*  SIZE 
                        ;*  RETURNS THE NUMBER OF BYTES LEFT UNUSED BY THE PROGRAM
                        ;*
                        ;*  FREE
                        ;*  RETURNS THE ADDRESS OF THE FIRST BYTE OF FREE MEMORY
                        ;*
                        ;*
                        ;************************************************************
                        ;*
   06ad   cd a2 06      RND:	CALL	PARN	;*** RND(EXPR) *** 
   06b0   7c            	MOV	A,H	;EXPR MUST BE +
   06b1   b7            	ORA	A 
   06b2   fa fd 00      	JM	QHOW
   06b5   b5            	ORA	L	;AND NON-ZERO
   06b6   ca fd 00      	JZ	QHOW
   06b9   c5            	PUSH	B 
   06ba   d5            	PUSH	D	;SAVE BOTH 
   06bb   e5            	PUSH	H 	;SAVE EXPR (N)
                        ;* REPLACEMENT RANDOM NUMBER GENERATOR
   06bc   2a 14 20      	LHLD	SEED
   06bf   eb            	XCHG		;SEED IN DE
   06c0   7a            	MOV	A,D
   06c1   63            	MOV	H,E
   06c2   2e fd         	MVI	L,253
   06c4   b7            	ORA	A	;CLEAR CY
   06c5   47            	MOV	B,A	;SAVE A
   06c6   cd 07 08      	CALL	SUBDE	;HL = HL - DE
   06c9   78            	MOV	A,B	;RESTORE A
   06ca   de 00         	SBI	0	;SUBTRACT CARRY
   06cc   47            	MOV	B,A	;SAVE A
   06cd   cd 07 08      	CALL	SUBDE
   06d0   78            	MOV	A,B	;RESTORE A
   06d1   16 00         	MVI	D,0
   06d3   9a            	SBB	D
   06d4   5f            	MOV	E,A
   06d5   cd 07 08      	CALL	SUBDE
   06d8   d2 dc 06      	JNC	RA1
   06db   23            	INX	H
   06dc   22 14 20      RA1:	SHLD	SEED	;SAVE NEW SEED
                        ;*	
   06df   d1            	POP	D	;BRING "N" BACK
   06e0   cd f1 07      	CALL	DIVIDE	;RND(N)=MOD(M,N)+1 
   06e3   d1            	POP	D 
   06e4   c1            	POP	B 
   06e5   23            	INX	H 	;RND(N) IN HL
   06e6   c9            	RET
                        ;* 
   06e7   cd a2 06      ABS:	CALL	PARN	;*** ABS(EXPR) *** 
   06ea   cd 0e 08      	CALL	CHKSGN	;CHECK SIGN
   06ed   7c            	MOV	A,H	;NOTE THAT -32768
   06ee   b4            	ORA	H	;CANNOT CHANGE SIGN
   06ef   fa fd 00      	JM	QHOW	;SO SAY: "HOW?"
   06f2   c9            	RET
                        ;*
   06f3   2a 18 20      SIZE:	LHLD	TXTUNF	;*** SIZE ***
   06f6   d5            	PUSH	D	;GET THE NUMBER OF FREE
   06f7   eb            	XCHG		;BYTES BETWEEN 'TXTUNF'
   06f8   2a 16 20      SIZEA:	LHLD	ARRUNF	;AND START OF ARRAY MEMORY
   06fb   cd 07 08      	CALL	SUBDE 	; HL = HL  - DE
   06fe   d1            	POP	D 
   06ff   c9            	RET
                        ;*
   0700   2a 18 20      FREE:	LHLD	TXTUNF	;*** FREE ***
   0703   c9            	RET		;RETURN FIRST FREE ADDRESS
                        ;
                        ;*
                        ;*********************************************************
                        ;*
                        ;*   *** PUT$ *** GET$ *** "<CHAR>" ***
                        ;*
                        ;*  PUT$ X
                        ;*  OUTPUTS A STRING (NULL TERM) STARTING FROM ADDRESS X
                        ;*
                        ;*  GET$ X
                        ;*  INPUTS A STRING FROM THE KEYBOARD TO SUCCESSIVE MEMORY
                        ;*  LOCATIONS STARTING AT X TERMINATED WITH A NULL
                        ;*  THE LENGTH OF THE STRING INCLUDING THE NULL IS RETURNED
                        ;*  IN VARIABLE Z
                        ;*
                        ;*  "<CHAR>"  (SCHAR)
                        ;*  RETURN THE ASCII VALUE OF A CHARACTER BETWEEN QUOTES
                        ;*
                        ;*
                        ;************************************************************
                        ;*
   0704   df            PUTST:	RST	3	; (EXPR) GET ADDRESS OF STRING
   0705   d5            	PUSH	D	; SAVE TEXT POINTER
   0706   eb            	XCHG		; DE IS NOW ADDRESS OF STRING
   0707   af            	XRA	A
   0708   cd 31 09      	CALL	PRTSTG	; PRINT UNTIL NULL
   070b   d1            	POP	D	; RESTORE POINTER
   070c   f7            	RST	6	; FINISH
                        ;*
   070d   df            GETST:	RST	3	; (EXPR) GET ADDRESS TO STORE STRING
   070e   d5            	PUSH	D	; SAVE POINTER
   070f   eb            	XCHG
   0710   2a 18 20      	LHLD	TXTUNF	; GET LOW LIMIT TO DE
   0713   eb            	XCHG
   0714   e7            	RST	4	; COMPARE (HL-DE)
   0715   da 79 08      	JC	ASORRY	; IF HL < LIMIT, NO INPUT
   0718   cd 80 08      	CALL	GL0	; INPUT TO BUFFER (NO PROMPT)
   071b   44            	MOV	B,H
   071c   4d            	MOV	C,L	; BC IS ADDR TO MOVE STRING TO
   071d   eb            	XCHG		; HL IS LAST CHR + 1
   071e   2b            	DCX	H	; NOW POINTS TO LAST CHR (CR)
   071f   11 38 3e      	LXI	D,BUFFER ; DE IS FIRST CHAR
   0722   d5            	PUSH	D	; SAVE TO COMPUTE LENGTH
   0723   cd b3 09      	CALL	MVUP	; MOVE (DE) TO (BC) UNTIL DE = HL
   0726   af            	XRA	A
   0727   02            	STAX	B	; REPLACE CR WITH NULL AT END OF STRING
   0728   d1            	POP	D	; FIRST CHAR
   0729   23            	INX	H	; LAST CHAR + 1
   072a   cd 07 08      	CALL	SUBDE	; HL = HL-DE (LENGTH OF STRING)
   072d   eb            	XCHG		; PUT IN DE
   072e   21 34 3e      	LXI	H,VARBGN + (26*2) ; STORE LENGTH IN VARIABLE Z
   0731   73            	MOV	M,E
   0732   23            	INX	H
   0733   72            	MOV	M,D
   0734   d1            	POP	D	; RESTORE POINTER
   0735   cd 38 08      	CALL	FIN	; GO ON IF STORED STATEMENT
   0738   c3 9e 01      	JMP	RSTART	; OTHERWISE INPUT ZAPPED DIRECT COMMAND, RESTART
                        ;*
   073b   1a            SCHAR:	LDAX	D	; GET TEXT CHAR AFTER QUOTE ("")
   073c   13            	INX	D
   073d   6f            	MOV	L,A	; ASCII VALUE IN HL
   073e   26 00         	MVI	H,0
   0740   cf            	RST	1	; TSTC,'"',ASC1
   0741   22            	DB	'"'
   0742   01            	DB 	ASC1 - $ - 1
   0743   c9            	RET		; CHAR FOLLOWED BY QUOTE, RETURN
   0744   c3 4b 08      ASC1:	JMP	QWHAT	; NO, ERROR
                        ;*
                        ;*********************************************************
                        ;*
                        ;*   *** OUT *** INP *** POKE *** PEEK *** USR ***
                        ;*
                        ;*  OUT I,J
                        ;*  OUTPUTS EXPRESSION 'J' TO PORT 'I'
                        ;*  USES THE MONITOR I/O COMMANDS
                        ;*
                        ;*  INP (I)
                        ;*  THIS FUNCTION RETURNS DATA READ FROM INPUT PORT 'I' AS
                        ;*  IT'S VALUE.
                        ;*  USES THE MONITOR I/O COMMANDS
                        ;*
                        ;*  POKE I,J
                        ;*  THIS COMMAND WORKS LIKE OUT EXCEPT THAT IT PUTS DATA 'J'
                        ;*  INTO MEMORY LOCATION 'I'.
                        ;*
                        ;*  PEEK (I)
                        ;*  THIS FUNCTION WORKS LIKE INP EXCEPT IT GETS IT'S VALUE
                        ;*  FROM MEMORY LOCATION 'I'.
                        ;*
                        ;*  USR (I(,J))
                        ;*  USR CALLS A MACHINE LANGUAGE SUBROUTINE AT LOCATION 'I'
                        ;*  IF THE OPTIONAL PARAMETER 'J' IS USED ITS VALUE IS PASSED
                        ;*  IN H&L.  THE VALUE OF THE FUNCTION SHOULD BE RETURNED IN H&L.
                        ;*
                        ;*
                        ;************************************************************
                        ;*
   0747   df            OUTCMD:	RST	3 	; EXPR
   0748   4d            	MOV	C,L	; C = PORT NUMBER
   0749   cf            	RST	1	; TSTC,',',IOMERR
   074a   2c            	DB	','
   074b   43            	DB	IOMERR - $ - 1
   074c   df            	RST	3	; EXPR, L = OUTPUT BYTE
   074d   cd 1b 10      	CALL	POUT	; OUTPUT BYTE TO PORT
   0750   f7            	RST	6	; FINISH
                        ;*
   0751   cd a2 06      INCMD:	CALL	PARN
   0754   4d            	MOV	C,L	; C = PORT NUMBER
   0755   cd 18 10      	CALL	PIN	; READ FROM PORT
   0758   6f            	MOV	L,A
   0759   26 00         	MVI	H,0	; PUT BYTE IN HL
   075b   c9            	RET
                        ;*
   075c   df            POKE:	RST	3	; EXPR
   075d   e5            	PUSH	H	; SAVE POKE ADDRESS ON STACK
   075e   cf            	RST	1	; TEST,',',IIOMERR
   075f   2c            	DB	','
   0760   2e            	DB	IOMERR - $ - 1
   0761   df            	RST	3	; EXPR
   0762   7d            	MOV	A,L	; BYTE TO A
   0763   e1            	POP	H	; GET ADDRESS
   0764   77            	MOV	M,A	; POKE BYTE TO ADDRESS
   0765   f7            	RST	6	; FINISH
                        ;*
   0766   cd a2 06      PEEK:	CALL	PARN	; GET ADDRESS
   0769   6e            	MOV	L,M	; READ BYTE
   076a   26 00         	MVI	H,0
   076c   c9            	RET
                        ;*
   076d   c5            USR:	PUSH	B	; SAVE B
   076e   cf            	RST	1	; TSTC,'(',IOMERR
   076f   28            	DB	'('
   0770   1e            	DB	IOMERR - $ - 1 ;QWHAT
   0771   df            	RST	3	;EXPR
   0772   cf            	RST	1
   0773   29            	DB	')'
   0774   07            	DB	PASPRM - $ - 1 ;PASPRM
   0775   d5            	PUSH	D	; SAVE D
   0776   11 8c 07      	LXI	D,USRET
   0779   d5            	PUSH	D	; SET RETURN ADDRESS FROM USER CALL
   077a   e5            	PUSH	H	; PUT SUBROUTINE ADDRESS ON STACK
   077b   c9            	RET		; CALL USR ROUTINE WITHOUT PARAMETER
                        ;
   077c   cf            PASPRM:	RST	1	; TSTC,',',IOMERR
   077d   2c            	DB	','
   077e   0d            	DB	USRET - $ - 1
   077f   e5            	PUSH	H	; SAVE ADDRESS ON STACK
   0780   df            	RST	3	; EXPR
   0781   cf            	RST	1	; TSTC,')',USRRET
   0782   29            	DB	')'
   0783   09            	DB	USRET + 1 - $ - 1 ; (SKIP POP D)
   0784   c1            	POP	B	; GET ADDRESS IN B
   0785   d5            	PUSH	D	; SAVE D
   0786   11 8c 07      	LXI	D,USRET
   0789   d5            	PUSH	D	; SET RETURN ADDRESS FROM USER CALL
   078a   c5            	PUSH	B	; PUT SUBROUTINE ADDRESS ON STACK
   078b   c9            	RET		;CALL USR ROUTINE
   078c   d1            USRET:	POP	D
   078d   c1            	POP	B
   078e   c9            	RET
                        ;*	
   078f   c3 4b 08      IOMERR:	JMP	QWHAT	; I/O OR MEMORY ERROR
                        ;*
                        ;*********************************************************
                        ;*
                        ;*   *** DIM ***
                        ;*
                        ;*  DIM <VAR>(<SIZE>)
                        ;*  ALLOCATES MEMORY FOR 1-D ARRAY
                        ;*
                        ;*  VARIABLE <VAR> HOLDS ARRAY ADDRESS
                        ;* 
                        ;************************************************************
                        ;*
   0792   ef            DIM:	RST	5	; IGNBLK, A=VARIABLE NAME
   0793   d6 40         	SUI	'@'	; CONVERT ASCII TO VARIABLE OFFSET
   0795   da d0 07      	JC	DIMERR	; NOT A VARIABLE
   0798   ca d0 07      	JZ	DIMERR	; ERROR IF '@' WHICH IS ALREADY AN ARRAY
   079b   fe 1b         	CPI	1BH	; 'A' TO 'Z'?
   079d   d2 d0 07      	JNC	DIMERR	; NOT A VARIABLE
   07a0   13            	INX	D	; MOVE TEXT POINTER
   07a1   21 00 3e      	LXI	H,VARBGN ; COMPUTE ADDRESS OF VARIABLE
   07a4   07            	RLC		; CREATE BYTE OFFSET, CLEAR CARRY
   07a5   85            	ADD	L	; AND PUT VARIABLE ADDRESS IN H,L
   07a6   6f            	MOV	L,A
   07a7   3e 00         	MVI	A,0
   07a9   8c            	ADC	H
   07aa   67            	MOV	H,A
   07ab   22 b0 3f      	SHLD	VADDR	; SAVE VARIABLE ADDRESS
   07ae   cd a2 06      	CALL	PARN	; GET ARRAY SIZE (# WORDS)
   07b1   29            	DAD	H	; CONVERT SIZE TO BYTES
   07b2   da 78 08      	JC	QSORRY	; ERROR IF TOO BIG
   07b5   d5            	PUSH	D	; SAVE TEXT POINTER
   07b6   eb            	XCHG		; ARRAY SIZE (IN BYTES) IN D,E
                        ;*
                        ;* ZERO ARRAY MOVING DOWN IN MEMORY
                        ;* STORE LAST ADDRESS IN VARIABLE (LOWEST MEMORY LOCATION)
                        ;*
   07b7   2a 16 20      CLRARY:	LHLD	ARRUNF	; GET NEXT ARRAY FREE ADDRESS
   07ba   af            CLR1:	XRA	A	; CLEAR A
   07bb   77            	MOV	M,A	; INITIALIZE ARRAY TO ZERO
   07bc   2b            	DCX	H	; MOVING DOWN IN MEMORY FROM ARRUNF
   07bd   1b            	DCX	D	; DECREMENT COUNT
   07be   7b            	MOV	A,E
   07bf   b2            	ORA	D	; DONE?
   07c0   c2 ba 07      	JNZ	CLR1
   07c3   22 16 20      	SHLD	ARRUNF	; SET NEW FREE ADDRESS
   07c6   23            	INX	H	; POINT BACK TO FIRST BYTE IN ARRAY
   07c7   eb            	XCHG		; PUT IN DE
   07c8   2a b0 3f      	LHLD	VADDR	; GET VARIABLE ADDRESS
   07cb   73            	MOV	M,E	; STORE ARRAY ADDRESS IN VARIABLE
   07cc   23            	INX	H
   07cd   72            	MOV	M,D	
   07ce   d1            	POP	D	; RESTORE TEXT POINTER
   07cf   f7            	RST	6	; FINISH
                        ;*	
   07d0   c3 4b 08      DIMERR:	JMP	QWHAT	; ERROR
                        ;*
                        ;**************************************************************
                        ;* 
                        ;* *** MULTPY *** DIVIDE *** SUBDE *** CHKSGN *** CHGSGN *** & CKHLDE *** 
                        ;* 
                        ;* 'MULTPY' MULTIPLIES DE BY L, (H = 0) RESULT IN HL
                        ;*
                        ;* 'DIVIDE' DIVIDES HL BY DE, RESULT IN BC, REMAINDER IN HL
                        ;* 
                        ;* 'SUBDE' SUBTRACTS DE FROM HL
                        ;* 
                        ;* 'CHKSGN' CHECKS SIGN OF HL.  IF +, NO CHANGE.  IF -, CHANGE 
                        ;* SIGN AND FLIP SIGN OF B.
                        ;* 
                        ;* 'CHGSGN' CHANGES SIGN OF HL AND B UNCONDITIONALLY. 
                        ;* 
                        ;* 'CKHLDE' CHECKS SIGN OF HL AND DE.  IF DIFFERENT, HL AND DE 
                        ;* ARE INTERCHANGED.  IF SAME SIGN, NOT INTERCHANGED.  EITHER
                        ;* CASE, HL DE ARE THEN COMPARED TO SET THE FLAGS. 
                        ;* 
                        ;*
                        ;*
   07d3   7c            MPY:	MOV	A,H	;IS HL > 255 ? 
   07d4   b7            	ORA	A 
   07d5   ca de 07      	JZ	MULTPY	;NO
   07d8   7a            	MOV	A,D	;YES, HOW ABOUT DE 
   07d9   b2            	ORA	D 
   07da   eb            	XCHG		;PUT SMALLER IN HL 
   07db   c2 fd 00      	JNZ	QHOW	;ALSO >, WILL OVERFLOW 
   07de   c5            MULTPY:	PUSH	B
   07df   06 08         	MVI	B,8	; BIT COUNT IN B
   07e1   7d            	MOV	A,L	; MULTIPLIER IN A
   07e2   21 00 00      	LXI	H,0	; PRODUCT = 0
   07e5   29            MULT:	DAD	H	; SHIFT PRODUCT
   07e6   17            	RAL		; SHIFT MULTIPLIER
   07e7   d2 eb 07      	JNC	CHCNT
   07ea   19            	DAD	D	; PRODUCT = PRODUCT * MULTIPLICAND
   07eb   05            CHCNT:	DCR	B
   07ec   c2 e5 07      	JNZ	MULT
   07ef   c1            	POP	B
   07f0   c9            	RET
                        ;*
   07f1   e5            DIVIDE:	PUSH	H	;*** DIVIDE ***
   07f2   6c            	MOV	L,H	;DIVIDE H BY DE
   07f3   26 00         	MVI	H,0 
   07f5   cd fc 07      	CALL	DV1 
   07f8   41            	MOV	B,C	;SAVE RESULT IN B
   07f9   7d            	MOV	A,L	;(REMAINDER+L)/DE
   07fa   e1            	POP	H 
   07fb   67            	MOV	H,A 
   07fc   0e ff         DV1:	MVI	C,-1	;RESULT IN C 
   07fe   0c            DV2:	INR	C	;DUMB ROUTINE
   07ff   cd 07 08      	CALL	SUBDE	;DIVIDE BY SUBTRACT
   0802   d2 fe 07      	JNC	DV2	;AND COUNT 
   0805   19            	DAD	D 
   0806   c9            	RET
                        ;* 
   0807   7d            SUBDE:	MOV	A,L	;*** SUBDE *** 
   0808   93            	SUB	E	;SUBTRACT DE FROM
   0809   6f            	MOV	L,A	;HL
   080a   7c            	MOV	A,H 
   080b   9a            	SBB	D 
   080c   67            	MOV	H,A 
   080d   c9            	RET
                        ;* 
   080e   7c            CHKSGN:	MOV	A,H	;*** CHKSGN ***
   080f   b7            	ORA	A	;CHECK SIGN OF HL
   0810   f0            	RP		;IF -, CHANGE SIGN 
                        ;* 
   0811   7c            CHGSGN:	MOV	A,H	;*** CHGSGN ***
   0812   2f            	CMA		;CHANGE SIGN OF HL 
   0813   67            	MOV	H,A 
   0814   7d            	MOV	A,L 
   0815   2f            	CMA
   0816   6f            	MOV	L,A 
   0817   23            	INX	H 
   0818   78            	MOV	A,B	;AND ALSO FLIP B 
   0819   ee 80         	XRI	80H
   081b   47            	MOV	B,A 
   081c   c9            	RET
                        ;* 
   081d   7c            CKHLDE:	MOV	A,H 
   081e   aa            	XRA	D	;SAME SIGN?
   081f   f2 23 08      	JP	CK1	;YES, COMPARE
   0822   eb            	XCHG		;NO, XCH AND COMP
   0823   e7            CK1:	RST	4 	;COMPARE
   0824   c9            	RET       
                        ;* 
                        ;**************************************************************
                        ;* 
                        ;* *** SETVAL *** FIN *** ENDCHK *** & ERROR (& FRIENDS) *** 
                        ;* 
                        ;* "SETVAL" EXPECTS A VARIABLE, FOLLOWED BY AN EQUAL SIGN AND
                        ;* THEN AN EXPR.  IT EVALUATES THE EXPR. AND SET THE VARIABLE
                        ;* TO THAT VALUE.
                        ;* 
                        ;* "FIN" CHECKS THE END OF A COMMAND.  IF IT ENDED WITH ":", 
                        ;* EXECUTION CONTINUES.  IF IT ENDED WITH A CR, IT FINDS THE 
                        ;* NEXT LINE AND CONTINUE FROM THERE.
                        ;* 
                        ;* "ENDCHK" CHECKS IF A COMMAND IS ENDED WITH CR.  THIS IS 
                        ;* REQUIRED IN CERTAIN COMMANDS. (GOTO, RETURN, AND STOP ETC.) 
                        ;* 
                        ;* "ERROR" PRINTS THE STRING POINTED BY DE (AND ENDS WITH CR). 
                        ;* IT THEN PRINTS THE LINE POINTED BY 'CURRNT' WITH A "?"
                        ;* INSERTED AT WHERE THE OLD TEXT POINTER (SHOULD BE ON TOP
                        ;* OF THE STACK) POINTS TO.  EXECUTION OF TBI IS STOPPED
                        ;* AND TBI IS RESTARTED.  HOWEVER, IF 'CURRNT' -> ZERO 
                        ;* (INDICATING A DIRECT COMMAND), THE DIRECT COMMAND IS NOT
                        ;*  PRINTED.  AND IF 'CURRNT' -> NEGATIVE # (INDICATING 'INPUT'
                        ;* COMMAND, THE INPUT LINE IS NOT PRINTED AND EXECUTION IS 
                        ;* NOT TERMINATED BUT CONTINUED AT 'INPERR'. 
                        ;* 
                        ;* RELATED TO 'ERROR' ARE THE FOLLOWING: 
                        ;* 'QWHAT' SAVES TEXT POINTER IN STACK AND GET MESSAGE "WHAT?" 
                        ;* 'AWHAT' JUST GET MESSAGE "WHAT?" AND JUMP TO 'ERROR'. 
                        ;* 'QSORRY' AND 'ASORRY' DO SAME KIND OF THING.
                        ;* 'QHOW' AND 'AHOW' IN THE ZERO PAGE SECTION ALSO DO THIS 
                        ;* 
   0825   ff            SETVAL:	RST	7	;*** SETVAL ***
   0826   da 4b 08      	JC	QWHAT	;"WHAT?" NO VARIABLE 
   0829   e5            	PUSH	H	;SAVE ADDRESS OF VAR.
   082a   cf            	RST	1	;PASS "=" SIGN 
   082b   3d            	DB	'=' 
   082c   08            	DB	SV1 - $ - 1
   082d   df            	RST	3	;EVALUATE EXPR.
   082e   44            	MOV	B,H	;VALUE IN BC NOW 
   082f   4d            	MOV	C,L 
   0830   e1            	POP	H	;GET ADDRESS 
   0831   71            	MOV	M,C	;SAVE VALUE
   0832   23            	INX	H 
   0833   70            	MOV	M,B 
   0834   c9            	RET
   0835   c3 4b 08      SV1:	JMP	QWHAT	;NO "=" SIGN 
                        ;* 
   0838   cf            FIN:	RST	1	;*** FIN *** 
   0839   3a            	DB	':' 
   083a   04            	DB	FI1 - $ - 1
   083b   f1            	POP	PSW	;":", PURGE RET ADDR.
   083c   c3 73 03      	JMP	RUNSML	;CONTINUE SAME LINE
   083f   cf            FI1:	RST	1	;NOT ":", IS IT CR?
   0840   0d            	DB	CR 
   0841   04            	DB	FI2 - $ - 1
   0842   f1            	POP	PSW	;YES, PURGE RET ADDR.
   0843   c3 63 03      	JMP	RUNNXL	;RUN NEXT LINE 
   0846   c9            FI2:	RET		;ELSE RETURN TO CALLER 
                        ;* 
   0847   ef            ENDCHK:	RST	5	;*** ENDCHK ***
   0848   fe 0d         	CPI	CR 	;END WITH CR?
   084a   c8            	RZ		;OK, ELSE SAY: "WHAT?" 
                        ;* 
   084b   d5            QWHAT:	PUSH	D	;*** QWHAT *** 
   084c   11 0c 01      AWHAT:	LXI	D,WHAT	;*** AWHAT *** 
   084f   97            ERRORB:	SUB	A	;*** ERROR *** 
   0850   cd 31 09      	CALL	PRTSTG	;PRINT 'WHAT?', 'HOW?' 
   0853   d1            	POP	D	;OR 'SORRY'
   0854   1a            	LDAX	D	;SAVE THE CHARACTER
   0855   f5            	PUSH	PSW	;AT WHERE OLD DE ->
   0856   97            	SUB	A	;AND PUT A 0 THERE 
   0857   12            	STAX	D 
   0858   2a 02 20      	LHLD	CURRNT	;GET CURRENT LINE #
   085b   e5            	PUSH	H 
   085c   7e            	MOV	A,M	;CHECK THE VALUE 
   085d   23            	INX	H 
   085e   b6            	ORA	M 
   085f   d1            	POP	D 
   0860   ca 9e 01      	JZ	RSTART	;IF ZERO, JUST RESTART
   0863   7e            	MOV	A,M	;IF NEGATIVE,
   0864   b7            	ORA	A 
   0865   fa 3a 05      	JM	INPERR	;REDO INPUT
   0868   cd a0 09      	CALL	PRTLN	;ELSE PRINT THE LINE 
   086b   1b            	DCX	D	;UPTO WHERE THE 0 IS 
   086c   f1            	POP	PSW	;RESTORE THE CHARACTER 
   086d   12            	STAX	D 
   086e   3e 3f         	MVI	A,'?'	;PRINT A "?" 
   0870   d7            	RST	2 	;OUTC
   0871   97            	SUB	A	;AND THE REST OF THE 
   0872   cd 31 09      	CALL	PRTSTG	;LINE
   0875   c3 9e 01      	JMP	RSTART
                        ;*
   0878   d5            QSORRY:	PUSH	D	;*** QSORRY ***
   0879   11 12 01      ASORRY:	LXI	D,SORRY	;*** ASORRY ***
   087c   c3 4f 08      	JMP	ERRORB 
                        ;* 
                        ;**************************************************************
                        ;* 
                        ;* *** GETLN *** FNDLN (& FRIENDS) *** 
                        ;* 
                        ;* 'GETLN' READS A INPUT LINE INTO 'BUFFER'.  IT FIRST PROMPT
                        ;* THE CHARACTER IN A (GIVEN BY THE CALLER), THEN IT FILLS THE 
                        ;* THE BUFFER AND ECHOS.  LOWER CASE IS CONVERTED TO UPPER.
                        ;*
                        ;* BACKSPACE OR RUB-OUT IS USED TO CAUSE IT TO DELETE 
                        ;* THE LAST CHARACTER (IF THERE IS ONE), AND ^D IS USED TO 
                        ;* CAUSE IT TO DELETE THE WHOLE LINE AND START IT ALL OVER.
                        ;* CR SIGNALS THE END OF A LINE, AND CAUSES 'GETLN' TO RETURN.
                        ;* 
                        ;* 'FNDLN' FINDS A LINE WITH A GIVEN LINE # (IN HL) IN THE 
                        ;* TEXT SAVE AREA.  DE IS USED AS THE TEXT POINTER.  IF THE
                        ;* LINE IS FOUND, DE WILL POINT TO THE BEGINNING OF THAT LINE
                        ;* (I.E., THE LOW BYTE OF THE LINE #), AND FLAGS ARE NC & Z. 
                        ;* IF THAT LINE IS NOT THERE AND A LINE WITH A HIGHER LINE # 
                        ;* IS FOUND, DE POINTS TO THERE AND FLAGS ARE NC & NZ.  IF 
                        ;* WE REACHED THE END OF TEXT SAVE ARE AND CANNOT FIND THE 
                        ;* LINE, FLAGS ARE C & NZ. 
                        ;* 'FNDLN' WILL INITIALIZE DE TO THE BEGINNING OF THE TEXT SAVE
                        ;* AREA TO START THE SEARCH.  SOME OTHER ENTRIES OF THIS 
                        ;* ROUTINE WILL NOT INITIALIZE DE AND DO THE SEARCH. 
                        ;* 'FNDLNP' WILL START WITH DE AND SEARCH FOR THE LINE #.
                        ;* 'FNDNXT' WILL BUMP DE BY 2, FIND A CR AND THEN START SEARCH.
                        ;* 'FNDSKP' USE DE TO FIND A CR, AND THEN START SEARCH. 
                        ;* 
   087f   d7            GETLN:	RST	2	;*** GETLN *** 
   0880   11 38 3e      GL0:	LXI	D,BUFFER ;PROMPT AND INIT
                        ;*
   0883   cd d8 0d      GL1:	CALL	CHKIO	;CONSOLE CHAR
   0886   fe 20         	CPI	' '	;CONTROL?
   0888   da ae 08      	JC	GL4	;YES
   088b   fe 7f         	CPI	DEL	;DELETE?
   088d   ca cc 08      	JZ	GL5	;YES
   0890   fe 61         	CPI	'a'	;LOWER CASE?
   0892   da 9c 08      	JC	GL2	;NO, SKIP
   0895   fe 7b         	CPI	'z'+1
   0897   d2 9c 08      	JNC	GL2	;NO, SKIP
   089a   e6 5f         	ANI	5FH	;YES, CONVERT
                        ;*
   089c   12            GL2:	STAX	D	;SAVE INPUT IN BUFFER
   089d   13            	INX	D	;AND BUMP POINTER
   089e   d7            	RST	2	;ELSE, ECHO THE CHARACTER
                        ;*
                        ;* CHECK FOR END OF BUFFER
                        ;*
   089f   7b            GL3:	MOV	A,E	;MORE FREE ROOM?
   08a0   fe 88         	CPI	BUFEND AND 0FFH
   08a2   c2 83 08      	JNZ	GL1	;YES, GET NEXT INPUT
                        ;*
                        ;* SEND ERROR BEEP AT THE END OF THE BUFFER
                        ;*
   08a5   3e 07         	MVI	A,BELL
   08a7   cd 06 10      	CALL	COUT
   08aa   3e 0d         	MVI	A,CR
   08ac   12            	STAX	D	;TERMINATE WITH A CR AND EXIT
   08ad   c9            	RET
                        ;*
                        ;* PROCESS CONTROL CHARACTER
                        ;*
   08ae   fe 03         GL4:	CPI	CTRC	;^C?
   08b0   ca 9e 01      	JZ	RSTART	;YES, RESTART
   08b3   fe 08         	CPI	CTRH	;^H?
   08b5   ca cc 08      	JZ	GL5	;YES, DELETE CHAR
   08b8   fe 04         	CPI	CTRD	;^D?
   08ba   ca e5 08      	JZ	GL6	;YES, DELETE LINE
   08bd   fe 0f         	CPI	CTRO	;^O?
   08bf   ca fe 08      	JZ	GL7	;YES, TOGGLE OUTPUT SWITCH
   08c2   fe 0d         	CPI	CR	;RETURN?
   08c4   c2 83 08      	JNZ	GL1	;NO, IGNORE THE CONTROL CHARACTER
   08c7   12            	STAX	D	;YES, SAVE CR
   08c8   13            	INX	D	;BUMP POINTER
   08c9   c3 0e 00      	JMP	CRLF	;AND EXIT WITH A NEW LINE	
                        ;*
                        ;* DELETE PRIOR CHARACTER IF ANY
                        ;*
   08cc   7b            GL5:	MOV	A,E	;DELETE LAST CHARACTER 
   08cd   fe 38         	CPI	BUFFER AND 0FFH    ;BUT DO WE HAVE ANY? 
   08cf   ca 83 08      	JZ	GL1	;NO, GET THE NEXT CHARACTER
                        ;*
   08d2   1b            	DCX	D	;YES, BACKUP POINTER 
   08d3   3e 08         	MVI	A,CTRH	;AND ECHO A BACK-SPACE, SPACE, BACK-SPACE
   08d5   cd 06 10      	CALL	COUT	;TO DELETE THE CHARACTER
   08d8   3e 20         	MVI	A,' '
   08da   cd 06 10      	CALL	COUT
   08dd   3e 08         	MVI	A,CTRH
   08df   cd 06 10      	CALL 	COUT
   08e2   c3 83 08      	JMP	GL1	;GO GET NEXT INPUT
                        ;*
                        ;* DELETE LINE BY DELETING THE CHARACTERS ONE AT A TIME
                        ;*
   08e5   7b            GL6:	MOV	A,E
   08e6   fe 38         	CPI	BUFFER AND 0FFH	;AT BEGINNING OF BUFFER?
   08e8   ca 83 08      	JZ	GL1	;YES, START AGAIN
   08eb   1b            	DCX	D	;NO, BACKUP POINTER 
   08ec   3e 08         	MVI	A,CTRH	;AND ECHO A BACK-SPACE, SPACE, BACK-SPACE
   08ee   cd 06 10      	CALL	COUT	;TO DELETE THE CHARACTER
   08f1   3e 20         	MVI	A,' '
   08f3   cd 06 10      	CALL	COUT
   08f6   3e 08         	MVI	A,CTRH
   08f8   cd 06 10      	CALL 	COUT
   08fb   c3 e5 08      	JMP	GL6	;GO DELETE NEXT CHARACTER
                        ;*
                        ;* TOGGLE THE OUTPUT SWITCH
                        ;*
   08fe   3a 01 20      GL7:	LDA	OCSW	;YES, TOGGLE OCSW
   0901   2f            	CMA		;ON TO OFF OR OFF TO ON
   0902   32 01 20      	STA	OCSW	;AND PUT IT BACK
   0905   c3 83 08      	JMP	GL1	;AND GET ANOTHER CHARACTER
                        ;*
                        ;* FIND A LINE BY THE LINE NUMBER
                        ;*
   0908   7c            FNDLN:	MOV	A,H	;*** FNDLN *** 
   0909   b7            	ORA	A	;CHECK SIGN OF HL
   090a   fa fd 00      	JM	QHOW	;IT CANNOT BE -
   090d   11 1a 20      	LXI	D,TXTBGN  ;INIT. TEXT POINTER
                        ;* 
   0910                 FNDLNP:	EQU	$	;*** FNDLNP ***
   0910   e5            FL1:	PUSH	H	;SAVE LINE # 
   0911   2a 18 20      	LHLD	TXTUNF	;CHECK IF WE PASSED END
   0914   2b            	DCX	H 
   0915   e7            	RST	4 	;COMPARE DE WITH HL
   0916   e1            	POP	H	;GET LINE # BACK 
   0917   d8            	RC		;CY,NZ PASSED END 
   0918   1a            	LDAX	D	;WE DID NOT, GET BYTE 1
   0919   95            	SUB	L	;IS THIS THE LINE? 
   091a   47            	MOV	B,A	;COMPARE LOW ORDER 
   091b   13            	INX	D 
   091c   1a            	LDAX	D	;GET BYTE 2
   091d   9c            	SBB	H	;COMPARE HIGH ORDER
   091e   da 25 09      	JC	FL2	;NO, NOT THERE YET 
   0921   1b            	DCX	D	;ELSE WE EITHER FOUND
   0922   b0            	ORA	B	;IT, OR IT IS NOT THERE
   0923   c9            	RET		;NC,Z:FOUND; NC,NZ:NOT FOUND
                        ;* 
   0924                 FNDNXT:	EQU	$	;*** FNDNXT ***
   0924   13            	INX	D	;FIND NEXT LINE
   0925   13            FL2:	INX	D	;JUST PASSED BYTE 1 & 2
                        ;* 
   0926   1a            FNDSKP:	LDAX	D	;*** FNDSKP ***
   0927   fe 0d         	CPI	CR 	;TRY TO FIND CR 
   0929   c2 25 09      	JNZ	FL2	;KEEP LOOKING
   092c   13            	INX	D	;FOUND CR, SKIP OVER 
   092d   c3 10 09      	JMP	FL1	;CHECK IF END OF TEXT
                        ;* 
                        ;*************************************************************
                        ;* 
                        ;* *** PRTSTG *** QTSTG *** PRTNUM *** & PRTLN *** 
                        ;* 
                        ;* 'PRTSTG' PRINTS A STRING POINTED BY DE.  IT STOPS PRINTING
                        ;* AND RETURNS TO CALLER WHEN EITHER A CR  IS PRINTED OR WHEN 
                        ;* THE NEXT BYTE IS THE SAME AS WHAT WAS IN A (GIVEN BY THE
                        ;* CALLER).  OLD A IS STORED IN B, OLD B IS LOST.
                        ;* 
                        ;* 'QTSTG' LOOKS FOR A BACK-SLASH, SINGLE QUOTE, OR DOUBLE 
                        ;* QUOTE.  IF NONE OF THESE, RETURN TO CALLER.  IF BACK-SLASH, 
                        ;* OUTPUT A CR WITHOUT A LF.  IF SINGLE OR DOUBLE QUOTE, PRINT 
                        ;* THE STRING IN THE QUOTE AND DEMANDS A MATCHING UNQUOTE. 
                        ;* AFTER THE PRINTING, THE NEXT 3 BYTES OF THE CALLER IS SKIPPED
                        ;* OVER (USUALLY A JUMP INSTRUCTION).
                        ;* 
                        ;* 'PRTNUM' PRINTS THE NUMBER IN HL.  LEADING BLANKS ARE ADDED 
                        ;* IF NEEDED TO PAD THE NUMBER OF SPACES TO THE NUMBER IN C. 
                        ;* HOWEVER, IF THE NUMBER OF DIGITS IS LARGER THAN THE # IN
                        ;* C, ALL DIGITS ARE PRINTED ANYWAY.  NEGATIVE SIGN IS ALSO
                        ;* PRINTED AND COUNTED IN, POSITIVE SIGN IS NOT. 
                        ;* 
                        ;* 'PRTLN' PRINTS A SAVED TEXT LINE WITH LINE # AND ALL. 
                        ;*
   0930   af            PRTSTZ:	XRA	A	;CLEAR A, TO STOP AT NULL
   0931   47            PRTSTG:	MOV	B,A	;*** PRTSTG ***
   0932   1a            PS1:	LDAX	D	;GET A CHARACTER 
   0933   13            	INX	D	;BUMP POINTER
   0934   b8            	CMP	B	;SAME AS OLD A?
   0935   c8            	RZ		;YES, RETURN 
   0936   d7            	RST	2	;ELSE PRINT IT 
   0937   fe 0d         	CPI	CR	;WAS IT A CR?
   0939   c2 32 09      	JNZ	PS1	;NO, NEXT
   093c   c9            	RET		;YES, RETURN 
                        ;* 
   093d   cf            QTSTG:  RST	1	;*** QTSTG *** 
   093e   22            	DB	'"' 
   093f   0f            	DB	QT3 - $ - 1
   0940   3e 22         	MVI	A,'"'	;IT IS A " 
   0942   cd 31 09      QT1:	CALL	PRTSTG	;PRINT UNTIL ANOTHER 
   0945   fe 0d         	CPI	CR	;WAS LAST ONE A CR?
   0947   e1            	POP	H	;RETURN ADDRESS
   0948   ca 63 03      	JZ	RUNNXL	;WAS CR, RUN NEXT LINE 
   094b   23            QT2:	INX	H	;SKIP 3 BYTES ON RETURN
   094c   23            	INX	H 
   094d   23            	INX	H 
   094e   e9            	PCHL		;RETURN
   094f   cf            QT3:	RST	1	;IS IT A ' ? 
   0950   27            	DB	27H 
   0951   05            	DB	QT4 - $ - 1
   0952   3e 27         	MVI	A,27H	;YES, DO SAME
   0954   c3 42 09      	JMP	QT1	;AS IN " 
   0957   cf            QT4:	RST	1	;IS IT BACK-SLASH? 
   0958   5c            	DB	'\'
   0959   09            	DB	QT5 - $ - 1
   095a   3e 0d         	MVI	A,CR	;YES, CR  WITHOUT LF!!
   095c   cd 06 10      	CALL	COUT
   095f   e1            	POP	H	;RETURN ADDRESS
   0960   c3 4b 09      	JMP	QT2 
   0963   c9            QT5:	RET		;NONE OF ABOVE 
                        ;* 
   0964   d5            PRTNUM:	PUSH	D	;*** PRTNUM ***
   0965   11 0a 00      	LXI	D,10	;DECIMAL 
   0968   d5            	PUSH	D	;SAVE AS A FLAG
   0969   42            	MOV	B,D	;B=SIGN
   096a   0d            	DCR	C	;C=SPACES
   096b   cd 0e 08      	CALL	CHKSGN	;CHECK SIGN
   096e   f2 74 09      	JP	PN1	;NO SIGN 
   0971   06 2d         	MVI	B,'-'	;B=SIGN
   0973   0d            	DCR	C	;'-' TAKES SPACE 
   0974   c5            PN1:	PUSH	B	;SAVE SIGN & SPACE 
   0975   cd f1 07      PN2:	CALL	DIVIDE	;DIVIDE HL BY 10 
   0978   78            	MOV	A,B	;RESULT 0? 
   0979   b1            	ORA	C 
   097a   ca 85 09      	JZ	PN3	;YES, WE GOT ALL 
   097d   e3            	XTHL		;NO, SAVE REMAINDER
   097e   2d            	DCR	L	;AND COUNT SPACE 
   097f   e5            	PUSH	H	;HL IS OLD BC
   0980   60            	MOV	H,B	;MOVE RESULT TO BC 
   0981   69            	MOV	L,C 
   0982   c3 75 09      	JMP	PN2	;AND DIVIDE BY 10
   0985   c1            PN3:	POP	B	;WE GOT ALL DIGITS IN
   0986   0d            PN4:	DCR	C	;THE STACK 
   0987   79            	MOV	A,C	;LOOK AT SPACE COUNT 
   0988   b7            	ORA	A 
   0989   fa 92 09      	JM	PN5	;NO LEADING BLANKS 
   098c   3e 20         	MVI	A,' '	;LEADING BLANKS
   098e   d7            	RST	2 	;OUTC
   098f   c3 86 09      	JMP	PN4	;MORE? 
   0992   78            PN5:	MOV	A,B	;PRINT SIGN
   0993   d7            	RST	2	;MAYBE - OR NULL 
   0994   5d            	MOV	E,L	;LAST REMAINDER IN E 
   0995   7b            PN6:	MOV	A,E	;CHECK DIGIT IN E
   0996   fe 0a         	CPI	10	;10 IS FLAG FOR NO MORE
   0998   d1            	POP	D 
   0999   c8            	RZ		;IF SO, RETURN 
   099a   c6 30         	ADI	'0'	;ELSE CONVERT TO ASCII
   099c   d7            	RST	2	;AND PRINT THE DIGIT 
   099d   c3 95 09      	JMP	PN6	;GO BACK FOR MORE
                        ;* 
   09a0   1a            PRTLN:	LDAX	D	;*** PRTLN *** 
   09a1   6f            	MOV	L,A	;LOW ORDER LINE #
   09a2   13            	INX	D 
   09a3   1a            	LDAX	D	;HIGH ORDER
   09a4   67            	MOV	H,A 
   09a5   13            	INX	D 
   09a6   0e 04         	MVI	C,4	;PRINT 4 DIGIT LINE #
   09a8   cd 64 09      	CALL	PRTNUM
   09ab   3e 20         	MVI	A,' '	;FOLLOWED BY A BLANK 
   09ad   d7            	RST	2 
   09ae   97            	SUB	A	;AND THEN THE TEXT 
   09af   cd 31 09      	CALL	PRTSTG
   09b2   c9            	RET
                        ;* 
                        ;**************************************************************
                        ;* 
                        ;* *** MVUP *** MVDOWN *** POPA *** & PUSHA ***
                        ;* 
                        ;* 'MVUP' MOVES A BLOCK UP FROM WHERE DE-> TO WHERE BC-> UNTIL 
                        ;* DE = HL 
                        ;* 
                        ;* 'MVDOWN' MOVES A BLOCK DOWN FROM WHERE DE-> TO WHERE HL-> 
                        ;* UNTIL DE = BC 
                        ;* 
                        ;* 'POPA' RESTORES THE 'FOR' LOOP VARIABLE SAVE AREA FROM THE
                        ;* STACK 
                        ;* 
                        ;* 'PUSHA' STACKS THE 'FOR' LOOP VARIABLE SAVE AREA INTO THE 
                        ;* STACK 
                        ;* 
   09b3   e7            MVUP:	RST	4	;*** MVUP ***
   09b4   c8            	RZ		;DE = HL, RETURN 
   09b5   1a            	LDAX	D	;GET ONE BYTE
   09b6   02            	STAX	B	;MOVE IT 
   09b7   13            	INX	D	;INCREASE BOTH POINTERS
   09b8   03            	INX	B 
   09b9   c3 b3 09      	JMP	MVUP	;UNTIL DONE
                        ;* 
   09bc   78            MVDOWN: MOV	A,B	;*** MVDOWN ***
   09bd   92            	SUB	D	;TEST IF DE = BC 
   09be   c2 c4 09      	JNZ	MD1	;NO, GO MOVE 
   09c1   79            	MOV	A,C	;MAYBE, OTHER BYTE?
   09c2   93            	SUB	E 
   09c3   c8            	RZ		;YES, RETURN 
   09c4   1b            MD1:	DCX	D	;ELSE MOVE A BYTE
   09c5   2b            	DCX	H	;BUT FIRST DECREASE
   09c6   1a            	LDAX	D	;BOTH POINTERS AND 
   09c7   77            	MOV	M,A	;THEN DO IT
   09c8   c3 bc 09      	JMP	MVDOWN	;LOOP BACK 
                        ;* 
   09cb   c1            POPA:	POP	B	;BC = RETURN ADDR. 
   09cc   e1            	POP	H	;RESTORE LOPVAR, BUT 
   09cd   22 0a 20      	SHLD	LOPVAR	;=0 MEANS NO MORE
   09d0   7c            	MOV	A,H 
   09d1   b5            	ORA	L 
   09d2   ca e5 09      	JZ	PP1	;YEP, GO RETURN
   09d5   e1            	POP	H	;NOP, RESTORE OTHERS 
   09d6   22 0c 20      	SHLD	LOPINC
   09d9   e1            	POP	H 
   09da   22 0e 20      	SHLD	LOPLMT
   09dd   e1            	POP	H 
   09de   22 10 20      	SHLD	LOPLN 
   09e1   e1            	POP	H 
   09e2   22 12 20      	SHLD	LOPPT 
   09e5   c5            PP1:	PUSH	B	;BC = RETURN ADDR. 
   09e6   c9            	RET
                        ;* 
   09e7   21 92 3e      PUSHA:	LXI	H,STKLMT	;*** PUSHA *** 
   09ea   cd 11 08      	CALL	CHGSGN
   09ed   c1            	POP	B	;BC=RETURN ADDRESS 
   09ee   39            	DAD	SP	;OUT OF STACK SPACE?
   09ef   d2 78 08      	JNC	QSORRY	;YES, SORRY FOR THAT.
   09f2   2a 0a 20      	LHLD	LOPVAR	;ELSE SAVE LOOP VAR.S
   09f5   7c            	MOV	A,H	;BUT IF LOPVAR IS 0
   09f6   b5            	ORA	L	;THAT WILL BE ALL
   09f7   ca 0d 0a      	JZ	PU1 
   09fa   2a 12 20      	LHLD	LOPPT	;ELSE, MORE TO SAVE
   09fd   e5            	PUSH	H 
   09fe   2a 10 20      	LHLD	LOPLN 
   0a01   e5            	PUSH	H 
   0a02   2a 0e 20      	LHLD	LOPLMT
   0a05   e5            	PUSH	H 
   0a06   2a 0c 20      	LHLD	LOPINC
   0a09   e5            	PUSH	H 
   0a0a   2a 0a 20      	LHLD	LOPVAR
   0a0d   e5            PU1:	PUSH	H 
   0a0e   c5            	PUSH	B	;BC = RETURN ADDR. 
   0a0f   c9            	RET
                        ;* 
                        ;**************************************************************
                        ;* 
                        ;* *** EDITOR *** 
                        ;* 
                        ;* (C) 2017 DAVID HUNTER
                        ;*
                        ;* 'EDITOR' ALLOWS FOR A LINE TO BE EDITED USING AN ANSI TERMINAL (OR EMULATOR)
                        ;* IT HANDLES LEFT & RIGHT ARROWS, BACKSPACE AND CHARACTER INSERTS/DELETES.
                        ;* <F1> (CODE: <ESC>[11~) EXITS THE EDITOR
                        ;* <CR> TERMINATES THE LINE AND EXITS
                        ;* IT IS BASICALLY A ONE LINE "SCREEN EDITOR"
                        ;*
                        ;* TO USE, TYPE "EDIT #" AT THE BASIC PROMPT WHERE # IS THE LINE NUMBER
                        ;*
                        ;*
                        ;* NOTE: FOR ANSI COMMANDS THE FIRST COLUMN = 1 NOT 0
                        ;*
                        ;* INPUTS:
                        ;* D = ADDRESS OF LINE
                        ;*
   0a10   d5            EDITOR:	PUSH	D	; SAVE LINE
                        	; PRINT THE LINE
   0a11   3e 5d         	MVI	A,EPROMPT
   0a13   d7            	RST	2	; SHOW EDIT MODE PROMPT
   0a14   1a            	LDAX	D	
   0a15   6f            	MOV	L,A	; LOW ORDER LINE #
   0a16   13            	INX	D 
   0a17   1a            	LDAX	D	; HIGH ORDER
   0a18   67            	MOV	H,A 
   0a19   22 a6 3f      	SHLD	CURLIN	; SAVE LINE NUMBER BEING EDITED
   0a1c   13            	INX	D
   0a1d   0e 04         	MVI	C,4	; PRINT 4 DIGIT LINE #
   0a1f   cd 64 09      	CALL	PRTNUM
   0a22   3e 20         	MVI	A,' '	; FOLLOWED BY A BLANK 
   0a24   d7            	RST	2 
   0a25   3e 0d         	MVI	A,CR	; AND THEN THE TEXT 
   0a27   cd 31 09      	CALL	PRTSTG	; D,E => END OF LINE+1 (AFTER <CR>)
   0a2a   eb            	XCHG		; H,L => END OF LINE+1
   0a2b   2b            	DCX	H	; H,L => END OF TEXT+1 (AT <CR>)
   0a2c   22 a4 3f      	SHLD	LINEND	; SAVE IT
                        	; CONVERT LINE NUMBER TO ASCII, MOVE TO BUFFER
   0a2f   d1            	POP	D	; D,E => START OF LINE
   0a30   1a            	LDAX	D	; GET LINE NUMBER
   0a31   6f            	MOV	L,A
   0a32   13            	INX	D
   0a33   1a            	LDAX	D
   0a34   67            	MOV	H,A	; H,L = LINE NUMBER
   0a35   13            	INX	D
   0a36   d5            	PUSH	D	; SAVE START OF TEXT
   0a37   16 03         	MVI	D,1000 SHR 8
   0a39   1e e8         	MVI	E,1000 AND 255
   0a3b   cd f1 07      	CALL	DIVIDE	; BC = HL / DE, HL = HL % DE
   0a3e   eb            	XCHG		; DE = REMAINDER
   0a3f   79            	MOV	A,C	; GET THOUSANDS
   0a40   c6 30         	ADI	'0'	; CONVERT TO ASCII
   0a42   21 38 3e      	LXI	H,BUFFER
   0a45   77            	MOV	M,A	; WRITE TO BUFFER
   0a46   23            	INX	H
   0a47   22 a0 3f      	SHLD	VARTMP	; SAVE BUFFER POINTER
   0a4a   eb            	XCHG		; HL = REMAINDER
   0a4b   16 00         	MVI	D,0
   0a4d   1e 64         	MVI	E,100
   0a4f   cd f1 07      	CALL	DIVIDE	; BC = HL / DE, HL = HL % DE
   0a52   eb            	XCHG		; DE = REMAINDER
   0a53   79            	MOV	A,C	; GET HUNDREDS
   0a54   c6 30         	ADI	'0'	; CONVERT TO ASCII
   0a56   2a a0 3f      	LHLD	VARTMP	; GET BUFFER BACK
   0a59   77            	MOV	M,A	; WRITE TO BUFFER
   0a5a   23            	INX	H
   0a5b   22 a0 3f      	SHLD	VARTMP	; AND SAVE BUFFER POINTER
   0a5e   eb            	XCHG		; HL = REMAINDER
   0a5f   16 00         	MVI	D,0
   0a61   1e 0a         	MVI	E,10
   0a63   cd f1 07      	CALL	DIVIDE	; BC = HL / DE, HL = HL % DE
   0a66   eb            	XCHG		; DE = REMAINDER
   0a67   79            	MOV	A,C	; GET TENS
   0a68   c6 30         	ADI	'0'	; CONVERT TO ASCII
   0a6a   2a a0 3f      	LHLD	VARTMP	; GET BUFFER BACK
   0a6d   77            	MOV	M,A	; WRITE TO BUFFER
   0a6e   23            	INX	H
   0a6f   7b            	MOV	A,E	; GET ONES
   0a70   c6 30         	ADI	'0'	; CONVERT TO ASCII
   0a72   77            	MOV	M,A	; WRITE TO BUFFER
   0a73   23            	INX	H
   0a74   3e 20         	MVI	A,' '
   0a76   77            	MOV	M,A	; WRITE A SPACE TO THE BUFFER
   0a77   23            	INX	H
   0a78   44            	MOV	B,H	; MOVE H,L
   0a79   4d            	MOV	C,L	; TO B,C
   0a7a   2a a4 3f      	LHLD	LINEND	; RESTORE END OF TEXT+1 (AT <CR>)
   0a7d   d1            	POP	D	; RESTORE START OF TEXT
                        	;
                        	; D,E => START OF TEXT
                        	; H,L => END OF TEXT
                        	; B,C => DESTINATION
                        	; COPY THE REST OF THE LINE TO THE BUFFER
   0a7e   cd b3 09      	CALL	MVUP	; COPY LINE TO BUFFER
   0a81   c5            	PUSH	B	; SAVE POSITION AT END OF TEXT IN BUFFER
   0a82   60            	MOV	H,B
   0a83   69            	MOV	L,C	; HL = FIRST FREE POSITION AFTER TEXT
   0a84   16 3e         	MVI	D,BUFFER SHR 8
   0a86   1e 38         	MVI	E,BUFFER AND 255
   0a88   cd 07 08      	CALL	SUBDE	; HL = HL - DE
   0a8b   4d            	MOV	C,L	; BUFFER COUNT IN C
   0a8c   e1            	POP	H	; HL => END OF TEXT IN BUFFER (AT <CR>)
                        
                        ;
                        ; EDIT LOOP
   0a8d                 EDLOOP:	
   0a8d   cd 09 10      	CALL	CIN	; GET CHARACTER
   0a90   fe 1b         	CPI	ESC	; ESCAPE SEQUENCE?
   0a92   c2 1f 0b      	JNZ	CHKDEL	; NO, CHECK IF DEL CHARACTER
   0a95   cd 09 10      	CALL	CIN	; YES, GET NEXT CHARACTER
   0a98   fe 5b         	CPI	'['	; START OF SEQUENCE (CSI)?
   0a9a   c2 8d 0a      	JNZ	EDLOOP	; NO, IGNORE
   0a9d   cd 09 10      	CALL	CIN	; YES, GET CODE
                        
   0aa0   fe 41         	CPI	'A'	; CURSOR UP?
   0aa2   c2 a8 0a      	JNZ	TSTB	; NO
   0aa5   c3 6e 0b      	JMP	EDERR	; YES, IGNORE <UP>
                        
   0aa8   fe 42         TSTB:	CPI	'B'	; CURSOR DOWN?
   0aaa   c2 b0 0a      	JNZ	TSTC	; NO
   0aad   c3 6e 0b      	JMP	EDERR	; YES, IGNORE <DOWN>
                        
   0ab0   fe 43         TSTC:	CPI	'C'	; CURSOR RIGHT?
   0ab2   c2 c2 0a      	JNZ	TSTD	; NO
   0ab5   cd 76 0b      	CALL	CHKEOL
   0ab8   ca 6e 0b      	JZ	EDERR	; AT END OF LINE, EXIT
   0abb   23            	INX	H	; INCREMENT POINTER
   0abc   cd 21 0c      	CALL	RIGHT	; SHOW CURSOR MOVEMENT
   0abf   c3 8d 0a      	JMP	EDLOOP
                        ;
   0ac2   fe 44         TSTD:	CPI	'D'	; CURSOR LEFT?
   0ac4   c2 d4 0a      	JNZ	TST1	; NO
   0ac7   7d            	MOV	A,L	; GET BUFFER POINTER
   0ac8   fe 3d         	CPI	(BUFFER  + 5) AND 255
   0aca   ca 6e 0b      	JZ	EDERR	; AT START OF TEXT, EXIT
   0acd   2b            	DCX	H	; DECREMENT POINTER
   0ace   cd 2a 0c      	CALL	LEFT	; SHOW CURSOR MOVEMENT
   0ad1   c3 8d 0a      	JMP 	EDLOOP
                        ;
   0ad4   fe 31         TST1:	CPI	'1'	; CURSOR HOME?
   0ad6   c2 e4 0a      	JNZ	TST4	; NO
   0ad9   cd 09 10      	CALL	CIN	; GET THE COMMAND
   0adc   fe 7e         	CPI	'~'
   0ade   c2 f4 0a      	JNZ	TSTF1	; NOT HOME KEY, F1 KEY?
   0ae1   c3 6e 0b      	JMP	EDERR	; YES, IGNORE <HOME>
                        ;
   0ae4   fe 34         TST4:	CPI	'4'	; CURSOR END?
   0ae6   c2 19 0b      	JNZ	EATCH	; NO
   0ae9   cd 09 10      	CALL	CIN	; GET THE COMMAND
   0aec   fe 7e         	CPI	'~'
   0aee   c2 6e 0b      	JNZ	EDERR	; NOT END KEY
   0af1   c3 6e 0b      	JMP	EDERR	; YES, IGNORE <END>
                        ;
   0af4   fe 31         TSTF1:	CPI	'1'	; CHECK IF F1 KEY (EXIT)
   0af6   c2 19 0b      	JNZ	EATCH	; NO, ERROR
   0af9   cd 09 10      	CALL	CIN	; GET TERMINATOR
   0afc   fe 7e         	CPI	'~'
   0afe   c2 6e 0b      	JNZ	EDERR	; NOT F1 KEY
                        	
                        	; SET H,L TO END OF BUFFER
   0b01   21 38 3e      	LXI	H,BUFFER; POINT TO START OF BUFFER
   0b04   79            	MOV	A,C	; ADD BUFFER COUNT
   0b05   85            	ADD	L
   0b06   6f            	MOV	L,A
   0b07   7c            	MOV	A,H
   0b08   ce 00         	ACI	0
   0b0a   67            	MOV	H,A	; H,L -> END OF TEXT + 1
                        ;	
   0b0b   3e 0d         EDITX:	MVI	A,CR
   0b0d   77            	MOV	M,A	; SAVE CR
   0b0e   23            	INX	H	; INCREMENT POINTER
                        ;
   0b0f   e5            	PUSH	H	; SAVE END OF LINE + 1 ON STACK FOR STORLN
   0b10   cd 0e 00      	CALL	CRLF	; START NEW LINE ON TERMINAL
   0b13   2a a6 3f      	LHLD	CURLIN	; RETURN WITH H,L = LINE NUMBER
   0b16   c3 d3 01      	JMP	STORLN	; STORE LINE
                        ;
   0b19   cd 09 10      EATCH:	CALL	CIN	; GET THE LAST CHARACTER
   0b1c   c3 6e 0b      	JMP	EDERR	; TO IGNORE THE SEQUENCE
                        ;
                        ;
                        ; CHECK FOR DELETE
   0b1f   fe 7f         CHKDEL:	CPI	DEL	; DELETE? (DELETE CHAR UNDER CURSOR)
   0b21   c2 30 0b      	JNZ	CHKC
                        	
   0b24   cd 76 0b      	CALL	CHKEOL
   0b27   ca 6e 0b      	JZ	EDERR	; AT END OF LINE, EXIT
   0b2a   cd e2 0b      	CALL	DELETE
   0b2d   c3 8d 0a      	JMP	EDLOOP
                        ;
                        ; CHECK FOR A CONTROL CHARACTER
   0b30   fe 20         CHKC:	CPI	' '	; CONTROL?
   0b32   d2 68 0b      	JNC	ECHO	; NO, ECHO
                        ;
   0b35   fe 0d         	CPI	CR	; CR?
   0b37   c2 43 0b      	JNZ	TSTBK
   0b3a   11 6f 01      	LXI	D,CEEOL	; YES
   0b3d   cd 30 09      	CALL	PRTSTZ	; ERASE TO END OF LINE
   0b40   ca 0b 0b      	JZ	EDITX	; EXIT
                        ;
   0b43   fe 08         TSTBK:	CPI	CTRH	; BACKSPACE?  (DELETE CHAR LEFT OF CURSOR)
   0b45   c2 6e 0b      	JNZ	EDERR	; NO, ERROR
                        	
   0b48   3e 05         	MVI	A,5	; OFFSET FOR LINE NUMBER + SPACE
   0b4a   b9            	CMP	C	; CHECK IF START OF TEXT IN BUFFER
   0b4b   ca 6e 0b      	JZ	EDERR	; YES, BEEP AND RETURN
   0b4e   cd 76 0b      	CALL	CHKEOL	; AT END OF BUFFER?
   0b51   ca 60 0b      	JZ	TSTBK1	; YES, JUST DELETE AND RETURN	
                        
   0b54   2b            	DCX	H	; DECREMENT BUFFER POINTER
   0b55   3e 08         	MVI	A,CTRH
   0b57   cd 06 10      	CALL	COUT	; MOVE CURSOR LEFT
   0b5a   cd e2 0b      	CALL	DELETE	; DELETE THE CHARACTER
   0b5d   c3 8d 0a      	JMP	EDLOOP
                        ;
   0b60   2b            TSTBK1:	DCX	H	; DECREMENT BUFFER POINTER
   0b61   0d            	DCR	C	; AND COUNT
   0b62   cd 33 0c      	CALL	DELCL	; DELETE CHARACTER AT END OF LINE
   0b65   c3 8d 0a      	JMP	EDLOOP
                        ;
                        ; STORE THE CHARACTER AND SEND IT
   0b68   cd 7b 0b      ECHO:	CALL	INSERT	
   0b6b   c3 8d 0a      	JMP	EDLOOP
                        ;
                        ; SEND A BEEP TO THE TERMINAL
   0b6e   3e 07         EDERR:	MVI	A,BELL
   0b70   cd 06 10      	CALL	COUT
   0b73   c3 8d 0a      	JMP	EDLOOP
                        ;
                        ; END OF LOOP
                        ;
                        ; ==========================================
                        ; EDITOR SUBROUTINES
                        ;
                        ; CHECK IF AT END OF LINE
   0b76   79            CHKEOL:	MOV	A,C	; GET BUFFER COUNT (PTR + 1)
   0b77   c6 38         	ADI	BUFFER AND 255	; A = END OF BUFFER LSB
   0b79   bd            	CMP	L	; SAME AS BUFFER POINTER?
   0b7a   c9            	RET		; SET FLAGS
                        ;
                        ; INSERT CHARACTER INTO BUFFER
                        ; RE-WRITE THE LINE IF NECESSARY
                        ; CHAR IN A
   0b7b   f5            INSERT:	PUSH	PSW	; SAVE A
   0b7c   3e 50         	MVI	A,BUFSIZ; END OF BUFFER?
   0b7e   b9            	CMP	C
   0b7f   ca db 0b      	JZ	INSERR	; YES, EXIT
                        ;
   0b82   cd 76 0b      	CALL	CHKEOL
   0b85   ca d3 0b      	JZ	INSER3	; AT END OF LINE, JUST INSERT
                        ;
   0b88   e5            	PUSH	H	; SAVE CURRENT BUFFER POINTER
   0b89   d5            	PUSH	D	; SAVE REGISTERS
   0b8a   c5            	PUSH	B
                        ;
   0b8b   11 78 01      	LXI	D,CSAV
   0b8e   cd 30 09      	CALL	PRTSTZ	; SAVE THE CURSOR POSITION
   0b91   11 6f 01      	LXI	D,CEEOL
   0b94   cd 30 09      	CALL	PRTSTZ	; ERASE TO END OF LINE
                        ;
   0b97   3e 38         	MVI	A,BUFFER AND 255
   0b99   81            	ADD	C
   0b9a   5f            	MOV	E,A	; D,E = POINTER TO LAST CHARACTER + 1
   0b9b   54            	MOV	D,H	
   0b9c   95            	SUB	L
   0b9d   47            	MOV	B,A	; B = COUNT OF CHARS TO MOVE
   0b9e   32 a2 3f      	STA	MOVCNT	; SAVE COUNT FOR LATER
   0ba1   6b            	MOV	L,E	; H,L = WRITE PTR (1 PAST LAST CHAR)
   0ba2   1b            	DCX	D	; DECREMENT READ PTR
                        			;   TO POINT TO LAST CHARACTER
                        ; MOVE THE BUFFER UP
   0ba3   1a            INSER1:	LDAX	D	; READ CHARACTER
   0ba4   77            	MOV	M,A	; STORE IN NEW POSITION
   0ba5   1b            	DCX	D
   0ba6   2b            	DCX	H
   0ba7   05            	DCR	B
   0ba8   c2 a3 0b      	JNZ	INSER1
                        ;	
   0bab   c1            	POP	B
   0bac   d1            	POP	D
   0bad   e1            	POP	H
                        ;
                        ; SAVE THE CHARACTER IN THE BUFFER
   0bae   f1            	POP	PSW	; GET CHARACTER BACK
   0baf   77            	MOV	M,A	; SAVE IN BUFFER
                        ;
                        ; H,L NOW POINTS ABOVE THE INSERTED POSITION IN THE BUFFER
                        ; RE-WRITE THE REST OF THE LINE
   0bb0   e5            	PUSH	H	; SAVE REGISTERS AGAIN
   0bb1   d5            	PUSH	D
   0bb2   c5            	PUSH	B
   0bb3   3a a2 3f      	LDA	MOVCNT
   0bb6   47            	MOV	B,A	; B = COUNT + 1
   0bb7   04            	INR	B	; 
   0bb8   7e            INSER2: MOV	A,M	; GET CHARACTER
   0bb9   cd 06 10      	CALL	COUT	; WRITE OUT
   0bbc   23            	INX	H
   0bbd   05            	DCR	B
   0bbe   c2 b8 0b      	JNZ	INSER2
                        ;
   0bc1   11 7c 01      	LXI	D,CUSAV
   0bc4   cd 30 09      	CALL	PRTSTZ	; RESTORE THE CURSOR POSITION
   0bc7   11 67 01      	LXI	D,CRIGHT
   0bca   cd 30 09      	CALL	PRTSTZ	; AND MOVE ONE POSITION OVER
                        ;	
   0bcd   c1            	POP	B
   0bce   d1            	POP	D
   0bcf   e1            	POP	H
   0bd0   23            	INX	H	; INCREMENT POINTER 
   0bd1   0c            	INR	C	;   AND COUNT
   0bd2   c9            	RET
                        	
                        ; SAVE THE CHARACTER IN THE BUFFER AND EXIT
   0bd3   f1            INSER3:	POP	PSW	; GET CHARACTER BACK
   0bd4   77            INSBUF:	MOV	M,A	; SAVE IN BUFFER
   0bd5   23            	INX	H	; INCREMENT POINTER
   0bd6   0c            	INR	C	;   AND COUNT
   0bd7   cd 06 10      	CALL	COUT	; SEND IT OUT
   0bda   c9            	RET
                        ;
                        ; INDICATE INSERT ERROR
   0bdb   f1            INSERR:	POP	PSW
   0bdc   3e 07         	MVI	A,BELL
   0bde   cd 06 10      	CALL	COUT
   0be1   c9            	RET
                        ;
                        ; DELETE CHARACTER FROM BUFFER
                        ; AND RE-WRITE THE LINE IF NECESSARY
   0be2                 DELETE:	
   0be2   e5            	PUSH	H	; SAVE CURRENT BUFFER POINTER
   0be3   d5            	PUSH	D	; SAVE REGISTERS
   0be4   c5            	PUSH	B
                        ;
   0be5   11 78 01      	LXI	D,CSAV
   0be8   cd 30 09      	CALL	PRTSTZ	; SAVE THE CURSOR POSITION
                        ;
   0beb   3e 38         	MVI	A,BUFFER AND 255
   0bed   81            	ADD	C	; A = LAST CHAR + 1
   0bee   95            	SUB	L
   0bef   d6 01         	SUI	1	; NUMBER OF CHARACTERS TO MOVE?
   0bf1   ca 19 0c      	JZ	DELET2	; NONE, JUST DELETE
                        
   0bf4   f5            	PUSH	PSW
   0bf5   11 6f 01      	LXI	D,CEEOL
   0bf8   cd 30 09      	CALL	PRTSTZ	; ERASE TO END OF LINE
   0bfb   f1            	POP	PSW
   0bfc   47            	MOV	B,A	; B = # CHARS TO MOVE
   0bfd   54            	MOV	D,H
   0bfe   5d            	MOV	E,L	; D,E = READ POINTER
   0bff   13            	INX	D	; POINT TO CHAR NEXT TO CURRENT
                        ;
                        ;
                        ; MOVE THE BUFFER DOWN AND RE-WRITE THE LINE
   0c00   1a            DELET1:	LDAX	D	; READ CHARACTER ABOVE CURRENT
   0c01   77            	MOV	M,A	; STORE IN CURRENT POSITION
   0c02   cd 06 10      	CALL	COUT	; DISPLAY IT
   0c05   13            	INX	D
   0c06   23            	INX	H
   0c07   05            	DCR	B
   0c08   c2 00 0c      	JNZ	DELET1
   0c0b   3e 0d         	MVI	A,CR
   0c0d   77            	MOV	M,A	; SET FORMER LAST CHAR TO CR
                        ;
   0c0e   11 7c 01      	LXI	D,CUSAV
   0c11   cd 30 09      	CALL	PRTSTZ	; RESTORE THE CURSOR POSITION
   0c14   c1            	POP	B
   0c15   0d            	DCR	C	; DECREMENT COUNT
   0c16   d1            	POP	D
   0c17   e1            	POP	H
   0c18   c9            	RET
                        ;
                        ; DELETE LAST CHARACTER
   0c19                 DELET2:	
   0c19   c1            	POP	B
   0c1a   0d            	DCR	C	; DECREMENT COUNT
   0c1b   d1            	POP	D
   0c1c   e1            	POP	H
                        
   0c1d   cd 38 0c      	CALL	DELCH	; DELETE CHARACTER
   0c20   c9            	RET
                        ;
                        ;--------------------------------------
                        ; TERMINAL SUB COMMANDS
                        ;
                        ; CURSOR COMMANDS	
                        ;
   0c21   d5            RIGHT:	PUSH 	D
   0c22   11 67 01      	LXI	D,CRIGHT
   0c25   cd 30 09      	CALL	PRTSTZ
   0c28   d1            	POP	D
   0c29   c9            	RET
                        ;	
   0c2a   d5            LEFT:	PUSH	D
   0c2b   11 6b 01      	LXI	D,CLEFT
   0c2e   cd 30 09      	CALL	PRTSTZ
   0c31   d1            	POP	D
   0c32   c9            	RET
                        
                        ; DELETE CHAR LEFT, DROP INTO DELCH
   0c33   3e 08         DELCL:	MVI	A,CTRH
   0c35   cd 06 10      	CALL	COUT
                        ;
                        ; DELETE CHAR UNDER CURSOR
   0c38   3e 20         DELCH:	MVI	A,' '
   0c3a   cd 06 10      	CALL	COUT
   0c3d   3e 08         	MVI	A,CTRH
   0c3f   cd 06 10      	CALL	COUT
   0c42   c9            	RET
                        ;
                        ;**************************************************************
                        ;* 
                        ;* *** XMODEM routines *** 
                        ;* 
                        ;* (C) 2017 DAVID HUNTER
                        ;*
                        ;
                        ; These allow for storing and loading of Tiny BASIC programs
                        ; to another computer using XMODEM protocol
                        ;
                        ;================================================
                        ; XMODEM SEND
                        ; ENTRY:
                        ; 	H,L = START OF DATA
                        ;	D,E = END OF DATA
                        ;
                        ; REGISTER USAGE
                        ; B = BLOCK NUMBER
                        ; C = BLOCK COUNT
                        ; D = TEMP
                        ; E = CHECKSUM
                        ; H,L = MEMORY POINTER
                        ;
                        ; ABORT WITH RESET SWITCH OR ^X
   0c43   06 01         XSEND:	MVI	B,1		; SET BLOCK NUMBER START
   0c45   22 aa 3f      	SHLD	PKTADD		; SET BEGIN ADDRESS FROM H,L
   0c48   eb            	XCHG
   0c49   22 ac 3f      	SHLD	ENDADD		; SET END ADDRESS FROM D,E (NOW IN H,L)
                        ;
                        ; FILL PARTIAL PACKET WITH FFH
                        ;
   0c4c   7d            	MOV	A,L		; END ADDRESS LOWER BYTE
   0c4d   92            	SUB	D		; A = (ENDADD - PKTADD) % 256
   0c4e   4f            	MOV	C,A		; SAVE IN C
   0c4f   3e 80         	MVI	A,80H
   0c51   91            	SUB	C		; A = NUMBER OF FILLER BYTES
   0c52   4f            	MOV	C,A		; C = COUNT OF FILLER BYTES
                        				; HL -> END ADDRESS
   0c53   3e ff         	MVI	A,0FFH		; SET FILLER BYTE
   0c55   23            FILLP:	INX	H		; SET FILL ADDRESS
   0c56   77            	MOV	M,A		; FILL BYTE
   0c57   0d            	DCR	C		; DECREMENT COUNT
   0c58   c2 55 0c      	JNZ	FILLP		; FILL PARTIAL PACKET WITH FFH
                        ;
   0c5b   cd 9b 0d      GETCHR:	CALL	XINP		; GET A CHARACTER
   0c5e   fe 15         	CPI	NAK
   0c60   ca 69 0c      	JZ	SENDP		; IF NAK, BEGIN SENDING
   0c63   fe 18         	CPI	CAN		; IF CANCEL, EXIT
   0c65   c8            	RZ
   0c66   c3 5b 0c      	JMP	GETCHR		; ELSE, IGNORE
                        ;
   0c69   cd b7 0c      SENDP:	CALL	OUTPKT		; SEND A PACKET
   0c6c   cd 7d 0d      GETRSP:	CALL	WAITCH		; GET RESPONSE
   0c6f   b7            	ORA	A		; SET FLAGS
   0c70   ca 69 0c      	JZ	SENDP		; TIMEOUT, SEND AGAIN
   0c73   fe 15         	CPI	NAK		; NAK?
   0c75   ca 69 0c      	JZ	SENDP		; YES, SEND AGAIN
   0c78   fe 06         	CPI	ACK		; ACK?
   0c7a   c2 6c 0c      	JNZ	GETRSP		; NO, WAIT FOR ANOTHER CHARACTER
                        ;
                        ; SUCCESS, POINT TO THE NEXT PACKET
                        ;
   0c7d   3a aa 3f      	LDA	PKTADD		; PKTADD = PKTADD + BLKSIZ
   0c80   c6 80         	ADI	BLKSIZ
   0c82   32 aa 3f      	STA	PKTADD
   0c85   3a ab 3f      	LDA	PKTADD+1
   0c88   ce 00         	ACI	0
   0c8a   32 ab 3f      	STA	PKTADD+1
   0c8d   04            	INR	B		; INCREMENT BLOCK NUMBER
                        ;
                        ; CHECK IF DONE
                        ;
   0c8e   2a aa 3f      	LHLD	PKTADD
   0c91   eb            	XCHG
   0c92   2a ac 3f      	LHLD	ENDADD
   0c95   7d            	MOV	A,L
   0c96   93            	SUB	E
   0c97   6f            	MOV	L,A
   0c98   7c            	MOV	A,H
   0c99   9a            	SBB	D
   0c9a   67            	MOV	H,A		; H,L = ENDADD - PKTADD
   0c9b   fa a2 0c      	JM	SENDX		; IF PKTADD > ENDADD, EXIT
   0c9e   b5            	ORA	L		; PKTADD = ENDADD?
   0c9f   c2 69 0c      	JNZ	SENDP		; NO, CONTINUE
                        ;
                        ; DONE, EXIT
                        ;
   0ca2   3e 04         SENDX:	MVI	A,EOT
   0ca4   cd 06 10      	CALL	COUT		; SEND END OF TEXT MESSAGE
   0ca7   cd 7d 0d      SENDX1:	CALL	WAITCH		; WAIT FOR RESPONSE
   0caa   b7            	ORA	A		; SET FLAGS
   0cab   c8            	RZ			; EXIT IF TIMEOUT
   0cac   fe 15         	CPI	NAK		; NAK?
   0cae   ca a2 0c      	JZ	SENDX		; YES, SEND EOT AGAIN
   0cb1   fe 06         	CPI	ACK		; ACK?
   0cb3   c2 a7 0c      	JNZ	SENDX1		; NO, WAIT FOR ACK OR TIMEOUT
   0cb6   c9            	RET			; YES, RETURN
                        ;
                        ; OUTPUT A PACKET
                        ;
   0cb7   0e 80         OUTPKT:	MVI	C,BLKSIZ 	; SET BLOCK COUNT
   0cb9   2a aa 3f      	LHLD	PKTADD		; POINT TO DATA BLOCK
   0cbc   1e 00         	MVI	E,0		; CLEAR CHECKSUM
   0cbe   3e 01         	MVI	A,SOH
   0cc0   cd 06 10      	CALL	COUT		; SEND START OF PACKET
   0cc3   78            	MOV	A,B		; GET BLOCK NUMBER
   0cc4   cd 06 10      	CALL	COUT		; SEND IT
   0cc7   2f            	CMA			; INVERT BLOCK NUMBER
   0cc8   cd 06 10      	CALL	COUT		; SEND IT
                        ;
   0ccb   7e            OUTDAT:	MOV	A,M		; GET BYTE
   0ccc   cd 06 10      	CALL	COUT		; SEND IT
   0ccf   83            	ADD	E
   0cd0   5f            	MOV	E,A		; UPDATE CHECKSUM
   0cd1   23            	INX	H		; POINT TO NEXT BYTE
   0cd2   0d            	DCR	C
   0cd3   c2 cb 0c      	JNZ	OUTDAT		; CONTINUE IF NOT DONE
                        ;
   0cd6   7b            	MOV	A,E
   0cd7   cd 06 10      	CALL	COUT		; SEND CHECKSUM
   0cda   c9            	RET			; AND EXIT
                        ;
                        ;================================================
                        ; XMODEM RECEIVE
                        ; ENTRY:
                        ; 	H,L = START OF DATA
                        ;
                        ; REGISTER USAGE
                        ; B = BLOCK NUMBER
                        ; C = BLOCK COUNT
                        ; D = TEMP
                        ; E = CALCULATED CHECKSUM
                        ; H,L = MEMORY POINTER
                        ;
                        ; ABORT WITH RESET SWITCH
                        ; IF SUCCESSFUL, UPDATE THE TXTUNF POINTER IN BASIC
                        ; IF ERROR, A '!' WILL BE PRINTED
                        ;
   0cdb   22 aa 3f      XRECV:	SHLD	PKTADD		; SET BEGIN ADDRESS FROM H,L
   0cde   06 01         	MVI	B,1		; SET BLOCK NUMBER START
                        ;
   0ce0   af            NEWPKT:	XRA	A
   0ce1   32 ae 3f      	STA	RETRY		; CLEAR RETRY COUNT
   0ce4   0e 80         	MVI	C,BLKSIZ 	; SET BLOCK COUNT
   0ce6   2a aa 3f      	LHLD	PKTADD		; POINT TO DATA BLOCK
   0ce9   1e 00         	MVI	E,0		; CLEAR CHECKSUM	
                        ;
   0ceb   3e 0a         XRCV2:	MVI	A,MAXTIM
   0ced   32 af 3f      	STA	TIMCNT		; SET TIMEOUT COUNT
                        ;
   0cf0   cd 7d 0d      XRCV3:	CALL	WAITCH		; WAIT FOR CHARACTER
   0cf3   fe 01         	CPI	SOH		; START OF PACKET?
   0cf5   ca 04 0d      	JZ	XRCV4		; YES, GET PACKET
                        ;	
   0cf8   fe 04         	CPI	EOT		; END?
   0cfa   ca 47 0d      	JZ	RECVX		; YES, SEND ACK AND EXIT
                        ;
   0cfd   b7            	ORA	A		; SET FLAGS
   0cfe   ca 23 0d      	JZ	XTMOUT		; TIMEOUT?
   0d01   c3 f0 0c      	JMP	XRCV3		; NO, GET ANOTHER CHARACTER
                        ;
   0d04   cd 51 0d      XRCV4:	CALL	INPKT		; YES, GET THE PACKET
   0d07   c2 2d 0d      	JNZ	BADRCV		; BAD PACKET
                        ;
   0d0a   3a aa 3f      	LDA	PKTADD		; GOOD PACKET
   0d0d   c6 80         	ADI	BLKSIZ
   0d0f   32 aa 3f      	STA	PKTADD
   0d12   3a ab 3f      	LDA	PKTADD+1
   0d15   ce 00         	ACI	0
   0d17   32 ab 3f      	STA	PKTADD+1	; PKTADD = PKTADD + BLKSIZ
   0d1a   04            	INR	B		; INCREMENT BLOCK NUMBER
   0d1b   3e 06         	MVI	A,ACK		; SEND ACK FOR PACKET
   0d1d   cd 06 10      	CALL	COUT
   0d20   c3 e0 0c      	JMP	NEWPKT		; WAIT FOR NEXT PACKET
                        ;
   0d23   3a af 3f      XTMOUT:	LDA	TIMCNT		; TIMEOUT OCCURRED
   0d26   3d            	DCR	A
   0d27   32 af 3f      	STA	TIMCNT		; DECREMENT TIMEOUT COUNT
   0d2a   c2 f0 0c      	JNZ	XRCV3		; MAX TIMEOUT NOT REACHED
                        ;
   0d2d   3e 15         BADRCV:	MVI	A,NAK		; SEND NAK
   0d2f   cd 06 10      	CALL	COUT
   0d32   3a ae 3f      	LDA	RETRY		; BAD PACKET
   0d35   3c            	INR	A
   0d36   32 ae 3f      	STA	RETRY		; INCREMENT RETRY COUNT
   0d39   fe 03         	CPI	MAXTRY		; RETRY = MAX?
   0d3b   ca 41 0d      	JZ	XERROR		; YES, ERROR
   0d3e   da eb 0c      	JC	XRCV2		; NO, KEEP TRYING
                        				; FALL THROUGH IF RETRY > MAX
                        ;
   0d41   3e 21         XERROR:	MVI	A,'!'		; RETRY EXCEEDED
   0d43   cd 06 10      	CALL	COUT
   0d46   c9            	RET			; AND EXIT
                        ;
   0d47   3e 06         RECVX:	MVI	A,ACK
   0d49   cd 06 10      	CALL	COUT		; SEND ACK
   0d4c   2b            	DCX	H		; POINT TO LAST BYTE RECEIVED
   0d4d   cd 6e 0d      	CALL	UPDTXT		; SET THE TXTUNF POINTER
   0d50   c9            	RET			; DONE
                        ;
                        ; INPUT A PACKET
                        ; NOTE, SOH HAS ALREADY BEEN RECEIVED
                        ; RETURN 0 IN A IF BLOCK NUMBERS AND CHECKSUM ARE GOOD
                        ; 
   0d51   cd 9b 0d      INPKT:	CALL	XINP		; GET BLOCK NUMBER
   0d54   a8            	XRA	B		; COMPARE WITH BLOCK NUMBER
   0d55   57            	MOV	D,A		; SAVE IN CHECK FLAG
   0d56   cd 9b 0d      	CALL	XINP		; GET INVERTED BLOCK NUMBER
   0d59   2f            	CMA			; INVERT
   0d5a   a8            	XRA	B		; COMPARE WITH BLOCK NUMBER
   0d5b   b2            	ORA	D		; COMBINE WITH CHECK FLAG
   0d5c   57            	MOV	D,A		; AND SAVE
                        ;
                        ; READ BLOCK OF DATA INTO MEMORY
   0d5d   cd 9b 0d      INDAT:	CALL	XINP		; GET BYTE
   0d60   77            	MOV	M,A		; SAVE BYTE
   0d61   83            	ADD	E		; ADD TO CHECKSUM
   0d62   5f            	MOV	E,A		; AND SAVE
   0d63   23            	INX	H		; POINT TO NEXT BYTE
   0d64   0d            	DCR	C		; DECREMENT COUNT
   0d65   c2 5d 0d      	JNZ	INDAT
                        ;
   0d68   cd 9b 0d      	CALL	XINP		; GET CHECKSUM
   0d6b   ab            	XRA	E		; COMPARE WITH CALCULATED CHECKSUM
   0d6c   b2            	ORA	D		; COMBINE WITH CHECK FLAG AND RETURN IN A
   0d6d   c9            	RET
                        ;
                        ; UPDATE TXTUNF VALUE FROM RECEIVED DATA
                        ; INPUT: H,L = END OF DATA
                        ;
   0d6e   7e            UPDTXT:	MOV	A,M		; GET BYTE
   0d6f   fe ff         	CPI	0FFH		; FF?
   0d71   c2 78 0d      	JNZ	UPDEX		; NO, END OF PROGRAM FOUND
   0d74   2b            	DCX	H		; YES, DECREMENT ADDRESS
   0d75   c3 6e 0d      	JMP	UPDTXT
                        ;	
   0d78   23            UPDEX:	INX	H		; POINT TO LAST EMPTY BYTE
   0d79   22 18 20      	SHLD	TXTUNF		; SAVE POINTER
   0d7c   c9            	RET
                        ;	
                        ;================================================
                        ; WAIT FOR A CHARACTER WITH TIMEOUT
                        ; RETURN 0 IF TIMEOUT
                        ; ELSE RETURN THE CHARACTER
                        ;
                        ; THE POLLING LOOP OFFSETS THE CAPTURE OF THE MID BIT
                        ; 99 CLOCKS = 40.28us WHICH IS ~10% OF A BIT TIME OF 2400 BPS
                        ; THEREFORE SAMPLING WILL BE AT THE 60% POINT OF A BIT
                        ; AS A WORST CASE WHICH SHOULD NOT BE A PROBLEM
                        ;
   0d7d   3e f8         WAITCH:	MVI	A,ONESEC AND 255 ; SET TIMEOUT
   0d7f   32 a8 3f      	STA	TIMOUT
   0d82   3e 60         	MVI	A,ONESEC SHR 8
   0d84   32 a9 3f      	STA	TIMOUT+1
   0d87   20            WAITLP:	RIM			; 99 CLOCKS IN LOOP = 40.28us
   0d88   b7            	ORA	A		; SEE IF DATA RECEIVED
   0d89   f2 9b 0d      	JP	XINP		; YES, GET THE BYTE
                        ;	
   0d8c   e5            	PUSH	H		
   0d8d   2a a8 3f      	LHLD	TIMOUT		; DECREMENT TIMEOUT
   0d90   2b            	DCX	H
   0d91   22 a8 3f      	SHLD	TIMOUT
   0d94   7d            	MOV	A,L
   0d95   b4            	ORA	H		; CHECK IF TIMEOUT = 0
   0d96   e1            	POP	H
   0d97   c2 87 0d      	JNZ	WAITLP
   0d9a   c9            	RET			; RETURN 0 IF TIMEOUT
                        
                        ;================================================
                        ; MODIFIED "BIT-BANG" SERIAL INPUT FOR XMODEM
                        ;
                        ; ADAPTED FROM THE INTEL MCS-80/85 USER'S MANUAL
                        ; RETURNS THE INPUT BYTE IN ACC
                        ;
   0d9b   c5            XINP:	PUSH	B
   0d9c   e5            	PUSH	H
   0d9d   06 09         	MVI	B,9		; 8 BITS + STOP
   0d9f                 XINP1:	
   0d9f   20            	RIM			; GET SERIAL INPUT
   0da0   b7            	ORA	A		; SET/CLEAR SIGN FLAG IN PSW
   0da1   fa 9f 0d      	JM	XINP1		; WAIT FOR START BIT
                        ;
   0da4   2e 26         	MVI	L,HALFBIT 
   0da6   2d            XINP2:	DCR	L		; WAIT UNTIL THE MIDDLE OF THE START BIT
   0da7   c2 a6 0d      	JNZ	XINP2
   0daa   00            	NOP
                        ;
   0dab   2e 45         XINP3:	MVI	L,FULLBIT 	; WAIT ONE BIT TIME
   0dad   2d            XINP4:	DCR	L
   0dae   c2 ad 0d      	JNZ	XINP4
   0db1   00            	NOP
   0db2   00            	NOP
   0db3   20            	RIM			; GET DATA BIT
   0db4   17            	RAL
   0db5   05            	DCR	B
   0db6   ca c0 0d      	JZ	XINP5
   0db9   79            	MOV	A,C
   0dba   1f            	RAR
   0dbb   4f            	MOV	C,A
   0dbc   00            	NOP			; NEEDED TO HAVE EQUAL # CLOCKS WITH COUT
   0dbd   c3 ab 0d      	JMP	XINP3
                        ;
   0dc0   79            XINP5:	MOV	A,C		; GET BYTE INTO ACC
   0dc1   e1            	POP	H
   0dc2   c1            	POP	B
   0dc3   c9            	RET
                        ;
                        ;**************************************************************
                        ;* 
                        ;* *** OUTC *** & CHKIO ****!
                        ;* THESE ARE THE ONLY I/O ROUTINES IN TBI. 
                        ;* 'OUTC' IS CONTROLLED BY A SOFTWARE SWITCH 'OCSW'.  IF OCSW=0
                        ;* 'OUTC' WILL JUST RETURN TO THE CALLER.  IF OCSW IS NOT 0, 
                        ;* IT WILL OUTPUT THE BYTE IN A.  IF THAT IS A CR, A LF IS ALSO
                        ;* SENT OUT.  ONLY THE FLAGS MAY BE CHANGED AT RETURN, ALL REG.
                        ;* ARE RESTORED. 
                        ;* 
                        ;* 'CHKIO' CHECKS THE INPUT.  IF NO INPUT, IT WILL RETURN TO 
                        ;* THE CALLER WITH THE Z FLAG SET.  IF THERE IS INPUT, Z FLAG
                        ;* IS CLEARED AND THE INPUT BYTE IS IN A.  
                        ;* IF INTERRUPTS ARE ENABLED, THE INTERRUPTS ARE DISABLED AND 
                        ;* RE-ENABLED AROUND THE INPUT CALL
                        ;* IF THE INPUT IS A CONTROL-O, THE 'OCSW' SWITCH IS 
                        ;* COMPLEMENTED, AND Z FLAG IS RETURNED. 
                        ;* A CONTROL-C WILL CAUSE A RESTART
                        ;*
                        ;* 'CKABRT' CHECKS THE ABORT FLAG SET BY THE INTERRUPT
                        ;* IF A CONTROL-C WAS DETECTED BY THE INTERRUPT,
                        ;* RESTART TBI
                        ;* 
                        ;* OUTC:PUSH	PSW	;THIS IS AT LOC. 10H 
                        ;*	LDA	OCSW	;PRINT CHARACTER ONLY
                        ;*	ORA	A	;IF OCSW SWITCH IS ON
                        ;*	JMP	OC2	;REST OF THIS IS AT OC2
   0dc4   c2 c9 0d      OC2:	JNZ	OC3	;IT IS ON, CONTINUE
   0dc7   f1            	POP	PSW	;IT IS OFF 
   0dc8   c9            	RET		;RESTORE AF AND RETURN 
   0dc9   f1            OC3:	POP	PSW	;GET OLD A BACK
   0dca   cd 06 10      	CALL	COUT
   0dcd   fe 0d         	CPI	CR 	;WAS IT A 'CR'?
   0dcf   c0            	RNZ		;NO, DONE
   0dd0   3e 0a         	MVI	A,LF	;YES, LOAD A LINEFEED
   0dd2   cd 06 10      	CALL	COUT	;AND SEND
   0dd5   3e 0d         	MVI	A,CR	;GET CR BACK IN A
   0dd7   c9            	RET		;DONE AT LAST
                        ;*
                        ;* THERE IS NO STATUS TO CHECK, THE CALL TO CIN BLOCKS
                        ;*
   0dd8   20            CHKIO:  RIM		;GET THE INTERRUPT STATUS
   0dd9   e6 08         	ANI	IEFLG	;CHECK THE INTERRUPT ENABLE FLAG
   0ddb   ca e4 0d      	JZ	CI0	;INTERRUPTS NOT ENABLED, JUST READ THE CHARACTER
                        			;OTHERWISE,
   0dde   f3            	DI		;DISABLE INTERRUPTS TO READ FROM THE SERIAL PORT
   0ddf   cd 09 10      	CALL	CIN	;WAIT FOR BYTE FROM TERMINAL
   0de2   fb            	EI		;INTERRUPTS RE-ENABLED
   0de3   c9            	RET
                        ;*
   0de4   cd 09 10      CI0:	CALL	CIN	;CALL WITHOUT CHANGING INTERRUPTS
   0de7   c9            	RET
                        ;*
                        ;* CHECK IF ABORT FLAG WAS SET BY THE INTERRUPT
                        ;*
   0de8   3a 00 20      CKABRT:	LDA	ABORTF
   0deb   b7            	ORA	A	;SET FLAGS
   0dec   c8            	RZ		;RETURN IF FLAG IS NOT SET
   0ded   c3 9e 01      	JMP	RSTART	;YES, RESTART
                        ;*
                        ;*
                        ;*
                        ;*
                        ;*
                        ;*
                        ;*
                        ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        ; START OF THE ALTAIR 8800B TURNKEY PROM MONITOR
                        ; RETYPED AND ADAPTED FROM ORIGINAL SOURCE:
                        ; altair(TM) 8800b Turnkey PROM Monitor User's Guide
                        ; (c) 1977, MITS, Inc
                        ; 
                        ;
                        ; Prompt:  '.'
                        ;
                        ; Commands:
                        ; 	Mxxxxxx		- change memory location xxxxxx (octal)
                        ;			- enter 3 octal digits for new data
                        ;			- press <SPACE> to skip to next location
                        ;			- any other character to exit
                        ;
                        ;	Dxxxxxx xxxxxx	- dump data (in octal) from start to end address
                        ;			- modified from original to be more of a "standard" dump
                        ;			- and not the Altair loader format
                        ;			- DH 03/11/18
                        ;
                        ;	Jxxxxxx		- jump to location
                        ;
                        ;
                        ; ALL VALUES ARE IN OCTAL
                        ;
                        ;****************************************************************
                        ;*                                                              *
                        ;*  THIS IS A 256 BYTE PROM MONITOR FOR USE WITH THE ALTAIR     *
                        ;*  8800B TURNKEY MODULE.  THIS MONITOR PROVIDES THE USER WITH  *
                        ;*  THE FOLLOWING FUNCTIONS:                                    *
                        ;*                                                              *
                        ;*      1)  MEMORY EXAMINE AND CHANGE FUNCTION                  *
                        ;*              YOU CAN EXAMINE AND CHANGE THE CONTENTS OF ANY  *
                        ;*              VALID MEMORY LOCATION                           *
                        ;*      2)  MEMORY DUMP FUNCTION                                *
                        ;*              YOU CAN DISPLAY THE MEMORY VALUES BETWEEN ANY   *
                        ;*              TWO VALID MEMORY LOCATIONS (changed from orig)  *
                        ;*      3)  JUMP TO FUNCTION                                    *
                        ;*              YOU CAN CAUSE THE MONITOR TO JUMP TO ANY        *
                        ;*              LOCATION AND START EXECUTING THE PROGRAM THERE  *
                        ;*                                                              *
                        ;*  THE MONITOR CAN BE REENTERED FROM THE USER'S PROGRAM        *
                        ;*  SO THAT THE FEATURES OF THE MONITOR ARE ALWAYS AVAILABLE    *
                        ;*  TO ANY USER PROGRAM.                                        *
                        ;*                                                              *
                        ;****************************************************************
                        ;
                        ;MITS TURNKEY MONITOR
                        ;C.W. VERTREES		01/13/77
                        ;REVISED		01/17/77
                        ;			01/19/77
                        ;			01/20/77
                        ; Adapted for Altaids Computer by D. Hunter	3/11/2018
                        ;
                        ;MONITOR STARTS AT THIS LOCATION (DIFFERENT FROM ALTAIR)
   0f00                 	ORG	0F00H		; start at top of first 4K
                        ;
                        ;
                        ;MONITOR CONTROL STRUCTURE
                        ;
   0f00   31 a0 3f      TURMON:	LXI	SP,STACK	;LOAD STACK
   0f03   cd 7c 16      	CALL	NEWLN		;FORMAT OUTPUT
   0f06   3e 2e         	MVI	A,APROMPT	;HELLO MONITOR
   0f08   cd c2 0f      	CALL	OUTCHK
   0f0b   cd bd 0f      	CALL	INCH		;WHAT TO DO?
   0f0e   fe 4d         	CPI	'M'
   0f10   ca 21 0f      	JZ	MEM		;DO MEMORY EXAMINE
   0f13   fe 44         	CPI	'D'
   0f15   cc 47 0f      	CZ	DMP		;DO A MEMORY DUMP
   0f18   fe 4a         	CPI	'J'
   0f1a   c2 00 0f      	JNZ	TURMON		;NOT A VALID CMD
   0f1d   cd 7c 0f      	CALL	OCTL6		;DO JUMP, GET ADDR
   0f20   e9            	PCHL
                        ;
                        ;THIS CONTROL STRUCTURE HANDLES THE MEMORY
                        ;EXAMINE AND CHANGE FUNCTION
                        ;
   0f21   cd 7c 0f      MEM:	CALL	OCTL6		;GET ADDRESS
   0f24   3e            	DB	076Q		;"MVI A," SKIP NEXT (BOMB A)
   0f25   23            CONT:	INX	H		;INCREMENT ADDRESS
   0f26   cd 7c 16      	CALL	NEWLN		;NEWLINE
   0f29   54            	MOV	D,H		;STORE ADDRESS IN D/E
   0f2a   5d            	MOV	E,L
   0f2b   cd 9e 0f      	CALL	PRINT6		;PRINT ADDRESS
   0f2e   1a            	LDAX	D		;LOAD DATA
   0f2f   67            	MOV	H,A
   0f30   cd a4 0f      	CALL	PRINT3		;PRINT DATA BYTE
   0f33   cd 7d 0f      	CALL	OCTL3		;GET NEW DATA
   0f36   eb            	XCHG			;RESTORE ADDRESS
   0f37   da 25 0f      	JC	CONT		;NO NEW DATA
   0f3a   77            	MOV	M,A		;STORE DATA
   0f3b   be            	CMP	M		;COMPARE DEPOSIT
   0f3c   ca 25 0f      	JZ	CONT		;OK, DO NEXT
                        ;
   0f3f   3e 3f         ERR:	MVI	A,'?'		;FLAG BAD DEPOSIT
   0f41   cd c2 0f      	CALL	OUTCHK		;PRINT "?"
   0f44   c3 00 0f      	JMP	TURMON		;RETURN TO MONITOR
                        ;ERROR CONDITIONS RETURN TO MONITOR VIA "ERR"
                        ;
                        ;THIS CONTROL STRUCTURE RUNS THE MEMORY DUMP FUNCTION
                        ;
   0f47   cd 7c 0f      DMP:	CALL	OCTL6		;GET START
   0f4a   eb            	XCHG			;STORE IN D/E
   0f4b   d4 b8 0f      	CNC	SPC
   0f4e   cd 7c 0f      	CALL	OCTL6		;GET END IN H/L
   0f51   cd 7c 16      	CALL	NEWLN
                        ;
   0f54   7d            	MOV	A,L		;SUB START FROM END
   0f55   93            	SUB	E
   0f56   6f            	MOV	L,A
   0f57   7c            	MOV	A,H
   0f58   9a            	SBB	D
   0f59   67            	MOV	H,A		;HL CONTAINS TOT BYTES
   0f5a   23            	INX	H		;INCLUDE END ADDRESS
                        ;
   0f5b                 NXTLIN:	
   0f5b   eb            	XCHG
   0f5c   e5            	PUSH	H
   0f5d   cd 9e 0f      	CALL	PRINT6		;PRINT ADDRESS
   0f60   e1            	POP	H
   0f61   eb            	XCHG
   0f62   1a            DATA:	LDAX	D		;GET DATA BYTE
   0f63   e5            	PUSH	H
   0f64   67            	MOV	H,A
   0f65   cd a4 0f      	CALL	PRINT3		;PRINT IT
   0f68   e1            	POP	H
   0f69   13            	INX	D		;INCREM ADDR
   0f6a   2b            	DCX	H		;TOTBYTES = TOTBYTES-1
   0f6b   7c            	MOV	A,H		;THROUGH W/ALL BYTES?
   0f6c   b5            	ORA	L
   0f6d   ca 7c 16      	JZ	NEWLN		;SEND LAST CRLF AND EXIT
   0f70   7b            	MOV	A,E		;GET ADDRESS LSB
   0f71   e6 07         	ANI	007Q		;EIGHTH BYTE?
   0f73   c2 62 0f      	JNZ	DATA		;NO, KEEP PRINTING
   0f76   cd 7c 16      	CALL	NEWLN		;YES, PRINT CRLF
   0f79   c3 5b 0f      	JMP	NXTLIN		;AND A NEW ADDRESS
                        ;
                        ;THIS SUBROUTINE BUILDS 3/6 OCTAL DIGITS IN H&L
                        ;
                        ;SPECIAL RETURN PROVIDED BY A "SPACE", CARRY BIT SET
                        ;ONLY VALID OCTAL OR "SPACE" ACCEPTED, ALL OTHER FLAGGED AND
                        ;CONTROL RETURNS TO THE MONITOR
                        ;
   0f7c   06            OCTL6:	DB	006Q		;LOAD B WITH 6, SKIP NEXT
   0f7d   06            OCTL3:	DB	006Q		;LOAD B WITH 3
   0f7e   03            	DB	003Q
   0f7f   21 00 00      	LXI	H,0		;CLEAR H/L FOR LESS THAN 6 DIG RET
   0f82   cd bd 0f      AGN:	CALL	INCH		;GET CHARACTER
   0f85   4f            	MOV	C,A		;STORE IN C
   0f86   fe 20         	CPI	' '		;COMPARE TO "SPACE"
   0f88   37            	STC			;SET THE CARRY
   0f89   c8            	RZ			;RETURN IF "SPACE"
   0f8a   e6 b8         	ANI	270Q		;TEST FOR VALID OCTAL
   0f8c   ee 30         	XRI	060Q
   0f8e   c2 3f 0f      	JNZ	ERR		;BAD, FLAG & RET TO MON
   0f91   79            	MOV	A,C		;RESTORE CHAR
   0f92   e6 07         	ANI	007Q		;STRIP ASCII
   0f94   29            	DAD	H		;SHIFT H&L LEFT 3 BITS
   0f95   29            	DAD	H
   0f96   29            	DAD	H
   0f97   85            	ADD	L
   0f98   6f            	MOV	L,A		;PUT OCTAL IN H
   0f99   05            	DCR	B		;THROUGH ?
   0f9a   c2 82 0f      	JNZ	AGN		;NO, DO AGAIN
   0f9d   c9            	RET			;YES, NORM RETURN
                        ;
                        ;THIS SUBROUTINE PRINTS 3 OCTAL DIGITS FROM H
                        ;OR 6 DIGITS FROM H AND L
                        ;
                        ;DIGITS ARE FOLLOWED BY A SPACE
                        ;
   0f9e   06 06         PRINT6:	MVI	B,6		;LOAD CNTR W/6
   0fa0   af            	XRA	A		;CLEAR A
   0fa1   c3 ab 0f      	JMP	NEXT1		;SHIFT ONE BIT (BIT 15)
   0fa4   06 03         PRINT3:	MVI	B,3		;LOAD CNTR W/3
   0fa6   e6            	DB	346Q		;SKIP NEXT, SHIFT 2 BITS
   0fa7   29            NEXT3:	DAD	H		;SHIFT H/L LEFT 3 INTO A
   0fa8   17            	RAL
   0fa9   29            	DAD	H
   0faa   17            	RAL
   0fab   29            NEXT1:	DAD	H
   0fac   17            	RAL
   0fad   e6 07         	ANI	007Q		;STRIP OFF OCTAL
   0faf   f6 30         	ORI	060Q		;ADD ASCII
   0fb1   cd c2 0f      	CALL	OUTCHK		;PRINT IT
   0fb4   05            	DCR	B		;THROUGH ?
   0fb5   c2 a7 0f      	JNZ	NEXT3		;NO, SHIFT NEXT THREE	
   0fb8   3e 20         SPC:	MVI	A,040Q		;YES, PRINT SPACE
   0fba   c3 c2 0f      	JMP	OUTCHK		;AND RETURN
                        
                        ;RETURN TO CALLING PROG THROUGH OUTCHK
                        ;
                        ;THIS SUBROUTINE WILL INPUT A CHARACTER, STRIP
                        ;PARITY AND AUTOMATICALLY ECHO THE CHARACTER.
                        ;IT WILL ALSO OUTPUT A CHARACTER.
                        ;
   0fbd   cd 13 16      INCH:	CALL	INPUTT
   0fc0   e6 7f         	ANI	177Q		;STRIP PARITY
   0fc2   cd 4d 16      OUTCHK:	CALL	OUTT
   0fc5   c9            	RET			;FROM WHENCE YE CAME
                        ;
                        
                        ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        ; START OF THE 8085 MONITOR
                        ; (c) 2018 David R. Hunter
                        ;
   1000                 	ORG	1000H	; start of monitor at second 4k boundary
                        ;
                        ; MONITOR JUMP TABLE
                        ;
   1000   c3 24 10      START:	JMP	COLD	; COLD START
   1003   c3 9e 01      WSTART:	JMP	RSTART	; BASIC WARM START
                        ;
                        ; VECTORS TO USEFUL ROUTINES (ENTER WITH CALL)
                        ;
   1006   c3 4d 16      COUT:	JMP	OUTT	; OUTPUT CHAR IN A TO SERIAL PORT
   1009   c3 13 16      CIN:	JMP	INPUTT	; INPUT CHAR FROM SERIAL PORT TO A
   100c   c3 8e 16      PRTWD:	JMP	PUTHL	; PRINT H,L IN HEX
   100f   c3 a6 16      PRTBY:	JMP	PUTHEX	; PRINT BYTE IN C IN HEX
   1012   c3 c6 16      GETWD:	JMP	GETW	; GET HEX WORD IN H,L
   1015   c3 cf 16      GETBY:	JMP	GETB	; GET HEX BYTE IN A
   1018   c3 5f 11      PIN:	JMP	IPORT	; GET DATA FROM INPUT PORT
   101b   c3 c5 11      POUT:	JMP	OPORT	; SEND DATA TO OUTPUT PORT
   101e   c3 ce 11      DSPREG:	JMP	DREGS	; DISPLAY REGISTERS
   1021   c3 72 16      PUTSTR:	JMP	SENDM	; PRINT NULL TERMINATED STRING IN D,E
                        ;
                        ;
                        ;================================================
                        ; COLD START
                        ;
   1024   31 a0 3f      COLD:	LXI	SP,STACK	; SET STACK POINTER
   1027   3e c0         	MVI	A,0C0H
   1029   30            	SIM			; ENABLE SERIAL PORT, SET TXD HIGH
   102a   11 01 17      	LXI	D,SIGNON	; SHOW SIGN ON MESSAGE
   102d   cd 72 16      	CALL	SENDM
                        	
   1030   31 a0 3f      WARM:	LXI	SP,STACK	; WARM START, CLEAR STACK	
                        ;
                        ; GET COMMAND AND JUMP TO APPROPRIATE ROUTINE
   1033   cd 7c 16      MAIN:	CALL	NEWLN
   1036   3e 2a         	MVI	A,PROMPT
   1038   cd 4d 16      	CALL	OUTT		; SEND PROMPT
   103b   cd 6c 16      	CALL	GETCHE		; GET COMMAND AND ECHO
   103e   e6 5f         	ANI	5FH		; CONVERT TO UPPER CASE
   1040   d6 41         	SUI	'A'		; A-Z?
   1042   da 57 10      	JC	ERROR
   1045   fe 1a         	CPI	'Z'-'A'+1
   1047   d2 57 10      	JNC	ERROR
                        	
   104a   87            	ADD	A		; CONVERT TO WORD OFFSET
   104b   21 5f 10      	LXI	H,CMDTBL	; POINT TO COMMAND TABLE
   104e   16 00         	MVI	D,0
   1050   5f            	MOV	E,A		; OFFSET IN D,E
   1051   19            	DAD	D		; ADD OFFSET TO TABLE
   1052   5e            	MOV	E,M		; GET ADDRESS
   1053   23            	INX	H
   1054   56            	MOV	D,M
   1055   eb            	XCHG			; PUT IN H,L
   1056   e9            	PCHL			; JUMP TO COMMAND	
                        ;	
                        ; SEND "?" AS ERROR, AND RETURN TO MONITOR
   1057   3e 3f         ERROR:	MVI	A,'?'
   1059   cd 4d 16      	CALL	OUTT
   105c   c3 30 10      	JMP	WARM
                        ;
                        ; COMMAND TABLE
   105f   93 10         CMDTBL:	DW	ALTAIR		; A
   1061   99 10         	DW	TBASIC		; B
   1063   30 10         	DW	WARM		; C
   1065   9f 10         	DW	DUMP		; D
   1067   14 11         	DW	ENTER		; E
   1069   30 10         	DW	WARM		; F
   106b   43 11         	DW	GO		; G
   106d   4a 11         	DW	HELP		; H
   106f   53 11         	DW	INPRT		; I
   1071   30 10         	DW	WARM		; J
   1073   30 10         	DW	WARM		; K
   1075   62 11         	DW	LOAD		; L
   1077   30 10         	DW	WARM		; M
   1079   30 10         	DW	WARM		; N
   107b   bc 11         	DW	OUTPRT		; O
   107d   30 10         	DW	WARM		; P
   107f   30 10         	DW	WARM		; Q
   1081   c8 11         	DW	REGS		; R
   1083   30 10         	DW	WARM		; S
   1085   02 12         	DW	TRACE		; T
   1087   30 10         	DW	WARM		; U
   1089   30 10         	DW	WARM		; V
   108b   30 10         	DW	WARM		; W
   108d   30 10         	DW	WARM		; X
   108f   30 10         	DW	WARM		; Y
   1091   30 10         	DW	WARM		; Z
                        ;
                        ; ALTAIR MONITOR
                        ; CMD: A
                        ; JUMP TO ALTAIR TURNKEY MONITOR (OCTAL I/O)
   1093   cd 7c 16      ALTAIR:	CALL	NEWLN
   1096   c3 00 0f      	JMP	TURMON
                        ;
                        ; TINY BASIC
                        ; CMD: B
                        ; JUMP TO TINY BASIC
   1099   cd 7c 16      TBASIC: CALL	NEWLN
   109c   c3 85 01      	JMP	BASIC
                        ;
                        ; DUMP MEMORY
                        ; CMD: Dnnnn mmmmm
                        ; DISPLAY MEMORY FROM nnnn TO mmmm, BOTH HEX AND ASCII
                        ;
   109f   cd c6 16      DUMP:	CALL	GETW	; GET START ADDRESS
   10a2   eb            	XCHG		; SAVE IN D,E
   10a3   cd 86 16      	CALL	SPACE
   10a6   cd c6 16      	CALL	GETW	; GET END ADDRESS
   10a9   eb            	XCHG		; START IN H,L END IN D,E
   10aa   cd 7c 16      DUMP1:	CALL	NEWLN
   10ad   06 10         	MVI	B,RLEN	; 16 BYTES PER LINE
   10af   cd 8e 16      	CALL	PUTHL	; DISPLAY ADDRESS
   10b2   e5            	PUSH	H	; SAVE ADDRESS
                        ;
   10b3   3e 03         DUMP2:	MVI	A,03H	; CHECK IF ADDRESS IS MODULO 4
   10b5   a5            	ANA	L
   10b6   c2 bc 10      	JNZ	DUMP3
   10b9   cd 86 16      	CALL	SPACE	; PRINT SPACE SEPARATOR EVERY 4 BYTES
   10bc   4e            DUMP3:	MOV	C,M	; GET BYTE
   10bd   cd 96 16      	CALL	PUTB	; DISPLAY IT
   10c0   05            	DCR	B	; DECREMENT COUNT
   10c1   ca e9 10      	JZ	DUMP7	; EXIT IF END OF LINE
                        ;
   10c4   7a            	MOV	A,D
   10c5   bc            	CMP	H	; CHECK IF AT LAST ADDRESS
   10c6   c2 ce 10      	JNZ	DUMP4
   10c9   7b            	MOV	A,E
   10ca   bd            	CMP	L
   10cb   ca d2 10      	JZ	DUMP5	; AT END ADDRESS, FILL OUT REST OF LINE
   10ce   23            DUMP4:	INX	H	; NEXT BYTE
   10cf   c3 b3 10      	JMP	DUMP2	; NOT AT END OF LINE
                        ;
                        ; FILL OUT WITH SPACES IF NOT AT END OF LINE
   10d2   23            DUMP5:	INX	H	; KEEP MOVING POINTER
   10d3   3e 03         	MVI	A,03H	; CHECK IF ADDRESS IS MODULO 4
   10d5   a5            	ANA	L
   10d6   c2 dc 10      	JNZ	DUMP6
   10d9   cd 86 16      	CALL	SPACE	; PRINT SPACE SEPARATOR EVERY 4 BYTES
   10dc   cd 86 16      DUMP6:	CALL	SPACE	; PRINT FILLER SPACES FOR EMPTY BYTES
   10df   cd 86 16      	CALL	SPACE
   10e2   cd 86 16      	CALL	SPACE
   10e5   05            	DCR	B
   10e6   c2 d2 10      	JNZ	DUMP5
                        ;
                        ; PRINT ASCII DATA
   10e9   e1            DUMP7:	POP	H	; GET START ADDRESS BACK
   10ea   cd 86 16      	CALL	SPACE	; SEPARATE DATA FROM ASCII
   10ed   cd 86 16      	CALL	SPACE
   10f0   06 10         	MVI	B,RLEN	; RESET COUNTER
   10f2   7e            DUMP8:	MOV	A,M	; GET BYTE
   10f3   fe 20         	CPI	20H	; CHECK IF PRINTABLE ASCII (20H - 7EH)
   10f5   da fd 10      	JC	DUMP9
   10f8   fe 7f         	CPI	7FH
   10fa   da ff 10      	JC	DUMPA	; PRINTABLE, SKIP NEXT LINE
   10fd   3e 2e         DUMP9:	MVI	A,'.'	; PRINT '.' IF UNPRINTABLE
                        ;
   10ff   cd 4d 16      DUMPA:	CALL	OUTT
   1102   7a            	MOV	A,D
   1103   bc            	CMP	H	; CHECK IF AT LAST ADDRESS
   1104   c2 0c 11      	JNZ	DUMPB
   1107   7b            	MOV	A,E
   1108   bd            	CMP	L
   1109   ca 33 10      	JZ	MAIN	; AT END, EXIT
   110c   23            DUMPB:	INX	H	; NEXT BYTE
   110d   05            	DCR	B	; DECREMENT COUNT
   110e   c2 f2 10      	JNZ	DUMP8
   1111   c3 aa 10      	JMP	DUMP1	; CONTINUE
                        ;
                        ; ENTER MEMORY DATA
                        ; CMD: Ennnn
                        ; ENTER HEX DATA INTO MEMORY STARTING AT nnnn, 
                        ; <SPACE> TO SKIP, INVALID HEX DIGIT TO EXIT
   1114   cd c6 16      ENTER:	CALL	GETW	; GET ADDRESS IN H,L
   1117   cd 7c 16      ENTLP:	CALL	NEWLN
   111a   cd 8e 16      	CALL	PUTHL	; DISPLAY ADDRESS
   111d   4e            	MOV	C,M	; GET CURRENT BYTE VALUE
   111e   cd 96 16      	CALL	PUTB	; DISPLAY IT
   1121   cd 86 16      	CALL	SPACE	; PRINT SPACE
   1124   cd 6c 16      	CALL	GETCHE	; GET CHAR
   1127   fe 20         	CPI	' '	; SPACE?
   1129   ca 3f 11      	JZ	SKIP	; YES, SKIP AHEAD
                        ;
   112c   cd e3 16      	CALL	CHKHEX	; SEE IF VALID CHARACTER
   112f   17            	RAL
   1130   17            	RAL
   1131   17            	RAL
   1132   17            	RAL
   1133   e6 f0         	ANI	0F0H	; MASK OFF UPPER BITS
   1135   4f            	MOV	C,A	; SAVE
   1136   cd e0 16      	CALL	GETHEX	; GET LOWER NIBBLE
   1139   b1            	ORA	C	; BRING IN UPPER BITS
   113a   77            	MOV	M,A	; STORE DATA
   113b   be            	CMP	M	; DID IT GET SAVED?
   113c   c2 57 10      	JNZ	ERROR	; NO, FLAG AS ERROR
                        ;	
   113f   23            SKIP:	INX	H	; NEXT ADDRESS
   1140   c3 17 11      	JMP	ENTLP
                        ;
                        ; GO TO MEMORY LOCATION
                        ; CMD: Gnnnn
                        ; EXECUTE FROM ADDRESS nnnn
   1143   cd c6 16      GO:	CALL	GETW	; GET ADDRESS IN H,L
   1146   cd 7c 16      	CALL	NEWLN
   1149   e9            	PCHL		; GO THERE
                        ;
                        ; HELP
                        ; CMD: H
                        ; DISPLAY COMMANDS
   114a   11 34 18      HELP:	LXI	D,HLPMSG
   114d   cd 72 16      	CALL	SENDM
   1150   c3 33 10      	JMP	MAIN
                        ;
                        ; READ INPUT PORT 60H
                        ; CMD: I
   1153   cd 7c 16      INPRT:	CALL	NEWLN
   1156   cd 5f 11      	CALL	IPORT
   1159   cd 99 16      	CALL	PUTBYT	; PRINT 
   115c   c3 33 10      	JMP	MAIN
                        ;	
   115f   db 60         IPORT:	IN	GPI	; READ DATA, RETURN IN ACC
   1161   c9            	RET
                        ;
                        ; LOAD INTEL HEX FILE
                        ; CMD: L
                        ; PRINT A '.' FOR EVERY RECORD RECEIVED SUCCESSFULLY
                        ; PRINT A '?' FOR EVERY CHECKSUM ERROR
                        ; PRINT A '!' WHEN DONE
                        ; REGISTER USAGE:
                        ;	B = RECORD TYPE
                        ;	C = COUNT
                        ;	E = CHECKSUM
                        ;	H,L = ADDRESS
                        ;
   1162   cd 7c 16      LOAD:	CALL	NEWLN	; SHOW READY WITH NEWLINE
   1165   cd 6c 16      LOAD1:	CALL 	GETCHE	; GET CHARACTER
   1168   fe 3a         	CPI	':'	; START OF RECORD?
   116a   c2 65 11      	JNZ	LOAD1
   116d   cd cf 16      	CALL	GETB	; GET COUNT
   1170   5f            	MOV	E,A	; START CHECKSUM
   1171   4f            	MOV	C,A	; SAVE COUNT
   1172   cd cf 16      	CALL	GETB	; GET ADDRESS HIGH BYTE
   1175   67            	MOV	H,A
   1176   83            	ADD	E
   1177   5f            	MOV	E,A	; ADD TO CHECKSUM
   1178   cd cf 16      	CALL	GETB	; GET ADDRESS LOW BYTE
   117b   6f            	MOV	L,A
   117c   83            	ADD	E
   117d   5f            	MOV	E,A	; ADD TO CHECKSUM
   117e   cd cf 16      	CALL	GETB	; GET TYPE
   1181   47            	MOV	B,A
   1182   83            	ADD	E
   1183   5f            	MOV	E,A
   1184   78            	MOV	A,B	; GET TYPE BACK
   1185   b7            	ORA	A	; SET FLAGS
   1186   c2 ad 11      	JNZ	ENDLD	; IF TYPE != 0, END
                        
   1189   cd cf 16      LOADLP:	CALL	GETB	; GET DATA BYTE
   118c   77            	MOV	M,A	; SAVE IN MEMORY
   118d   23            	INX	H	; MOVE POINTER
   118e   83            	ADD	E
   118f   5f            	MOV	E,A	; ADD TO CHECKSUM
   1190   0d            	DCR	C	; MORE BYTES?
   1191   c2 89 11      	JNZ	LOADLP
                        
   1194   cd cf 16      	CALL	GETB	; GET CHECKSUM
   1197   83            	ADD	E
   1198   c2 a0 11      	JNZ	BADLD	; A GOOD CHECKSUM SHOULD RESULT IN 0 IN ACC
   119b   3e 2e         	MVI	A,'.'	; OK MESSAGE
   119d   c3 a2 11      	JMP	NEXTLD
                        	
   11a0   3e 3f         BADLD:	MVI	A,'?'	; ERROR MESSAGE
   11a2   cd 4d 16      NEXTLD:	CALL	OUTT
   11a5   3e 0a         	MVI	A,LF
   11a7   cd 4d 16      	CALL	OUTT
   11aa   c3 65 11      	JMP	LOAD1
                        
   11ad   cd cf 16      ENDLD:	CALL	GETB	; GET CHECKSUM
   11b0   3e 21         	MVI	A,'!'	; DONE
   11b2   cd 4d 16      	CALL	OUTT
   11b5   2b            	DCX	H	; BACK UP TO LAST ADDRESS WRITTEN
   11b6   cd 8b 16      	CALL	PUTW	; PRINT LAST ADDRESS WRITTEN
                        
   11b9   c3 33 10      	JMP	MAIN
                        ;
                        ; OUTPUT TO PORT 61H
                        ; CMD: O bb
   11bc   cd cf 16      OUTPRT:	CALL	GETB	; GET VALUE
   11bf   cd c5 11      	CALL	OPORT
   11c2   c3 33 10      	JMP	MAIN
                        
   11c5   d3 61         OPORT:	OUT	GPO	; SEND TO PORT, VALUE IN ACC
   11c7   c9            	RET
                        ;
                        ; DISPLAY REGISTERS
                        ; SAVE REGISTERS ON THE STACK, DISPLAY THEM AND RESTORE
                        ; CMD:  R
                        ;
   11c8   cd ce 11      REGS:	CALL	DREGS	; PUT PC ON STACK
   11cb   c3 33 10      	JMP	MAIN
                        
   11ce   e5            DREGS:	PUSH	H	; SAVE REGISTERS ON STACK
   11cf   d5            	PUSH	D
   11d0   c5            	PUSH	B
   11d1   f5            	PUSH	PSW
   11d2   21 08 00      	LXI	H,8
   11d5   39            	DAD	SP
   11d6   e5            	PUSH	H	; SAVE SP FROM ENTRY TO REGS
   11d7   11 74 19      	LXI	D,REGLST ; REGISTER LIST
   11da   cd 72 16      	CALL	SENDM	; SEND REGISTER DISPLAY HEADER
                        ;	
   11dd   e1            	POP	H	; GET SAVED SP INTO H,L
   11de   e5            	PUSH	H	; AND SAVE IT AGAIN
                        ;
                        ;	THE STACK IS NOW:
                        ;		9: RETURN ADDRESS <= (SAVED SP)
                        ;		7: H,L
                        ;		5: D,E
                        ;		3: B,C
                        ;		1: A
                        ;		0: F		
                        ;		-1: SAVED SP	
                        ;		-2: 		<= CURRENT SP
                        ;
   11df   23            	INX	H	; OFFSET TO UPPER BYTE OF PC OF CALLER
   11e0   4e            	MOV	C,M	; GET UPPER BYTE OF PC
   11e1   cd 99 16      	CALL	PUTBYT	; PRINT IT WITHOUT A SPACE
   11e4   2b            	DCX	H	; MOVE POINTER
   11e5   4e            	MOV	C,M	; GET LOWER BYTE OF PC
   11e6   cd 99 16      	CALL	PUTBYT	; PRINT IT
                        ;	
   11e9   e1            	POP	H	; GET SAVED SP
   11ea   cd 8b 16      	CALL	PUTW	; PRINT
                        ; STACK IS NOW POINTING TO PSW
   11ed   e1            	POP	H	; GET ACC,FLAGS
   11ee   4c            	MOV	C,H	; PUT ACC IN C FOR PUTB
   11ef   cd 96 16      	CALL	PUTB	; PRINT
   11f2   cd af 16      	CALL	BITS	; PRINT FLAGS ALREADY IN L
                        ;
   11f5   e1            	POP	H	; GET B,C
   11f6   cd 8b 16      	CALL	PUTW	; PRINT
                        ;
   11f9   e1            	POP	H	; GET D,E
   11fa   cd 8b 16      	CALL	PUTW	; PRINT
                        ;
   11fd   e1            	POP	H	; GET H,L
   11fe   cd 8b 16      	CALL	PUTW	; PRINT
                        ;
   1201   c9            	RET
                        ;
                        ;*********************************************************************
                        ; SINGLE STEP AND DISASSEMBLER MODULE
                        ; 
                        ; THIS PRINTS THE REGISTER VALUES AND THE NEXT INSTRUCTION
                        ; PRESSING ANY KEY GOES TO THE NEXT INSTRUCTION
                        ; USE ^C TO EXIT TO THE MONITOR
                        ;
   1202   cd c6 16      TRACE:	CALL	GETW		; ADDRESS TO START AT
   1205   22 0c 3f      	SHLD	PSAVE		; SET ENTRY POINT TO START SINGLE STEP
   1208   11 9c 19      	LXI	D,DISINS 	; MESSAGE
   120b   cd 72 16      	CALL	SENDM		; SEND IT
   120e   31 02 3f      	LXI	SP,MSTCK	; SET SINGLE STEP STACK POINTER
                        ;
                        ;*********************************************************************
                        ;*   RETURN POINT AFTER SIMULATION OF OPCODE IN RAM AREA             *
                        ;*********************************************************************
   1211   22 08 3f      RSTA:	SHLD	LSAVE		; SAVE H
   1214   32 03 3f      	STA	ASAVE		; TEMP SAVE A
   1217   1f            	RAR			; SAVE CY TO ACCUMULATOR
   1218   21 00 00      	LXI	H,0		; GET 0'S IN HL
   121b   39            	DAD	SP		; GET VALUE OF STACK POINTER
   121c   22 0a 3f      	SHLD	SSAVE		; SAVE VALUE OF STACK POINTER
   121f   17            	RAL			; RESET CY TO PROPER VALUE
   1220   3a 03 3f      	LDA	ASAVE		; GET VALUE OF A
   1223   31 08 3f      	LXI	SP,LSAVE	; SET STACK POINTER TO LSAVE
   1226   d5            	PUSH	D		; SAVE D-E
   1227   c5            	PUSH	B		; SAVE B-C
   1228   f5            	PUSH	PSW		; SAVE PSW-A
   1229   31 02 3f      FINI:	LXI	SP,MSTCK	; RESET STACK POINTER
                        ;
                        ; DISPLAY REGISTERS
                        ;
   122c   11 74 19      DSPLY:	LXI	D,REGLST 	; REGISTER LIST
   122f   cd 72 16      	CALL	SENDM		; SEND IT	
   1232   2a 0c 3f      	LHLD	PSAVE
   1235   cd 8e 16      	CALL	PUTHL		; PRINT PC
   1238   2a 0a 3f      	LHLD	SSAVE
   123b   cd 8b 16      	CALL	PUTW		; PRINT SP
   123e   3a 03 3f      	LDA	ASAVE
   1241   4f            	MOV	C,A
   1242   cd 96 16      	CALL	PUTB		; PRINT ACC
   1245   3a 02 3f      	LDA	FSAVE
   1248   6f            	MOV	L,A
   1249   cd af 16      	CALL	BITS		; PRINT FLAG
   124c   2a 04 3f      	LHLD	CSAVE
   124f   cd 8b 16      	CALL	PUTW		; PRINT B,C
   1252   2a 06 3f      	LHLD	ESAVE
   1255   cd 8b 16      	CALL	PUTW		; PRINT D,E
   1258   2a 08 3f      	LHLD	LSAVE
   125b   cd 8b 16      	CALL	PUTW		; PRINT H,L
   125e   3e 20         	MVI	A,' '
   1260   cd 4d 16      	CALL	OUTT		; ADD SPACE BEFORE OPCODE STRINGS
   1263   2a 0c 3f      	LHLD	PSAVE		; POINT TO OP CODE IN HL
   1266   cd 7f 13      	CALL 	DISASM		; SHOW OP CODE MNEMONICS
   1269   cd 7c 16      	CALL	NEWLN		; NEW LINE	
                        ; WAIT FOR KEYBOARD INPUT TO CONTINUE, ^C ABORTS AND RETURNS TO MONITOR	
   126c   cd 13 16      SSWAIT:	CALL	INPUTT	
   126f   fe 03         	CPI	CTRC		; ABORT?
   1271   c2 77 12      	JNZ	SSTEP		; NO, CONTINUE
                        ;
   1274   c3 30 10      	JMP	WARM		; YES, RETURN TO MONITOR
                        ;
                        ;*********************************************************************
                        ;*                 SINGLE STEP LOOP CYCLE                            *
                        ;*********************************************************************
   1277   3e c3         SSTEP:	MVI	A,0C3H		; SET JUMP OPCODE
   1279   32 11 3f      	STA	EXOP3		; STORE IN RAM EXECUTION AREA
   127c   21 11 12      	LXI	H,RSTA		; GET RETURN POINT IN H-L
   127f   22 12 3f      	SHLD	EXOP4		; STORE IN RAM EXECUTION AREA
   1282   21 00 00      	LXI	H,0		; GET 0'S IN HL
   1285   22 0f 3f      	SHLD	EXOP1		; MAKE 2ND & 3RD BYTES NOP'S
   1288   2a 0c 3f      	LHLD	PSAVE		; LOCATION OPCODE TO BE SIMULATED
   128b   7e            	MOV	A,M		; GET THE OPCODE BYTE
   128c   32 0e 3f      	STA	EXOP		; STORE IT IN RAM EXECUTION AREA
   128f   cd 50 13      	CALL	TCNT		; GET NUMBER OF BYTES OF OPCODE
   1292   2a 0c 3f      	LHLD	PSAVE		; GET PROGRAM COUNTER IN H-L AGAIN
   1295   fe 01         	CPI	1		; SEE IF ONE BYTE INSTRUCTION
   1297   ca a9 12      	JZ	NMB		; IF SO, UPDATE PSAVE
   129a   fe 02         	CPI	2		; SET Z FLAG - TWO BYTE INSTRUCTION
   129c   23            	INX	H		; POINT TO SECOND BYTE
   129d   7e            	MOV	A,M		; FETCH THE SECOND BYTE
   129e   32 0f 3f      	STA	EXOP1		; STORE IN RAM EXECUTION AREA
   12a1   ca a9 12      	JZ	NMB		; Z SET IF TWO BYTE INSTRUCTION
   12a4   23            	INX	H		; POINT TO THIRD BYTE
   12a5   7e            	MOV	A,M		; FETCH THE THIRD BYTE
   12a6   32 10 3f      	STA	EXOP2		; STORE IN RAM EXECUTION AREA
   12a9   23            NMB:	INX	H		; INCREMENT TO PROPER VALUE
   12aa   22 0c 3f      	SHLD	PSAVE		; STORE NEW PROGRAM COUNTER
                        ;*********************************************************************
                        ;* CHECK ODD OPCODE TABLE FOR BYTE AND JUMP TO CORRESPONDING ADDRESS *
                        ;* THESE ARE OPCODES WHICH ARE OUT OF ALIGNMENT WITH THE SYSTEM TYPE *
                        ;* OPCODES                                                           *
                        ;*********************************************************************
   12ad   3a 0e 3f      	LDA	EXOP		; GET THE OPCODE BYTE AGAIN
   12b0   21 35 19      	LXI	H,OOTBL		; SET H-L TO BEGINNING OF OOTBL
   12b3   06 05         	MVI	B,5		; SET COUNT OF NUMBER OF ENTRIES
                        ; SEE IF IN TABLE
   12b5   04            TBCHK:	INR	B		; INCREMENT LOOP COUNTER
   12b6   05            TBC1:	DCR	B		; DECREMENT LOOP COUNTER
   12b7   ca c8 12      	JZ	TBNOT		; IF B IS ZERO, BYTE NOT IN TABLE
   12ba   be            	CMP	M		; SEE IF BYTE IN TABLE
   12bb   ca c4 12      	JZ	TBC2		; IF SO, THEN NEED ADDRESS
   12be   23            	INX	H		; SKIP DATA BYTE
   12bf   23            	INX	H		; AND SKIP THE TWO
   12c0   23            	INX	H		; SUBSEQUENT ADDRESS BYTES
   12c1   c3 b6 12      	JMP	TBC1		; DO THE LOOP AGAIN
   12c4   23            TBC2:	INX	H		; POINT TO LOW ORDER ADDRESS BYTE
   12c5   c3 e9 12      	JMP	HLJMP		; GET ADDRESS AND MAKE JUMP
                        ;
   12c8   e6 c0         TBNOT:	ANI	300Q		; NOT IN TABLE, GET HIGH OCTAL PART
   12ca   fe c0         	CPI	300Q		; SEE IF IT IS THREE
   12cc   ca dc 12      	JZ	SYSOP		; JUMP TO SYSTEM TYPE OPCODES IF SO
                        ;*********************************************************************
                        ;*   NORMAL REGISTER AND STACK POINTER RESTORING SEQUENCE            *
                        ;*********************************************************************
   12cf   f1            EXCYC:	POP	PSW		; RESTORE PSW
   12d0   c1            	POP	B		; RESTORE B-C
   12d1   d1            	POP	D		; RESTORE D-E
   12d2   2a 0a 3f      	LHLD	SSAVE		; GET VALUE OF STACK POINTER
   12d5   f9            	SPHL			; RESTORE STACK POINTER VALUE
   12d6   2a 08 3f      	LHLD	LSAVE		; RESTORE H-L
   12d9   c3 0e 3f      	JMP	EXOP		; EXECUTE THE OPCODE
                        ;*********************************************************************
                        ;*    SYSTEM TYPE OPCODES -- HIGH ORDER OCTAL PART IS 3              *
                        ;*    A JUMP IS MADE TO THE APPROPRIATE ROUTINE CONSISTENT           *
                        ;*    WITH THE FOLLOWING OCTAL ORGANIZATION OF THE OPCODE            *
                        ;*                                                                   *
                        ;*  RETYP . EXCYC . BRTYP . EXCYC . CALTY . EXCYC  . EXCYC . RSTTY   *
                        ;*  ...............................................................  *
                        ;*   3X0  .  3X1  .  3X2  .  3X3  .  3X4  .  3X5   .  3X6  .  3X7    *
                        ;*  ...............................................................  *
                        ;*   RNZ  . POP B .  JNZ  .  JMP  .  CNZ  . PUSH B .  ADI  . RST 0   *
                        ;*   RZ   . RET   .  JZ   .  ---  .  CZ   . CALL   .  ACI  . RST 1   *
                        ;*   RNC  . POP D .  JNC  .  OUT  .  CNC  . PUSH D .  SUI  . RST 2   *
                        ;*   RC   . ---   .  JC   .  IN   .  CC   . ---    .  SBI  . RST 3   *
                        ;*   RPO  . POP H .  JPO  .  XTHL .  CPO  . PUSH H .  ANI  . RST 4   *
                        ;*   RPE  . PCHL  .  JPE  .  XCHG .  CPE  . ---    .  XRI  . RST 5   *
                        ;*   RP   . POP P .  JP   .  DI   .  CP   . PUSH P .  ORI  . RST 6   *
                        ;*   RM   . SPHL  .  JM   .  EI   .  CM   . ---    .  CPI  . RST 7   *
                        ;*                                                                   *
                        ;*    NOTE:                                                          *
                        ;*          JMP, RET, CALL AND PCHL HAVE BEEN ELIMINATED             *
                        ;*          FROM CONSIDERATION AT THIS POINT                         *
                        ;*********************************************************************
   12dc   21 44 19      SYSOP:	LXI	H,SYTBL		; GET START OF SYTBL ADDRESS
   12df   3a 0e 3f      	LDA	EXOP		; GET OPCODE
   12e2   e6 07         	ANI	07Q		; GET LOW ORDER OCTAL PART
                        ;*********************************************************************
                        ;*        INDIRECT JUMP COMPUTE ROUTINE                              *
                        ;*********************************************************************
   12e4   87            INJMP:	ADD	A		; MULTIPLY BY TWO
   12e5   5f            	MOV	E,A		; SET UP FOR COMPUTING
   12e6   16 00         	MVI	D,0		; THE OFFSET
   12e8   19            	DAD	D		; COMPUTE THE OFFSET
   12e9   5e            HLJMP:	MOV	E,M		; LOW ORDER ADDRESS
   12ea   23            	INX	H		; POINT TO HIGH ORDER ADDRESS
   12eb   56            	MOV	D,M		; HIGH ORDER ADDRESS
   12ec   eb            	XCHG			; MOVE TO H-L
   12ed   e9            	PCHL			; MAKE THE JUMP
                        ;
                        ;*********************************************************************
                        ;*       INSTRUCTION SIMULATION ROUTINES                             *
                        ;*********************************************************************
   12ee   2a 08 3f      PCH:	LHLD	LSAVE		; GET ORIGINAL VALUE OF H-L
   12f1   22 0c 3f      	SHLD 	PSAVE		; UPDATE PROGRAM COUNTER
   12f4   c3 29 12      	JMP	FINI		; FINISHED
                        ;
   12f7   2a 0f 3f      BRTYP:	LHLD	EXOP1		; GET USER'S JUMP TO ADDRESS
   12fa   eb            	XCHG			; PASS D-E
   12fb   21 01 13      	LXI	H,JMPSC		; SUCCESSFUL JUMP ADDRESS
   12fe   c3 11 13      	JMP	BRSB		; COMPLETE BRANCH OPERATION
   1301   2a 00 3f      JMPSC:	LHLD	MSTC2		; GET JUMP ADDRESS FROM MSTC2
   1304   22 0c 3f      	SHLD	PSAVE		; STORE THE ADDRESS
   1307   c3 29 12      	JMP	FINI		; FINISHED
                        ;
   130a   2a 0f 3f      CALTY:	LHLD	EXOP1		; GET USER'S CALL ADDRESS
   130d   eb            	XCHG			; PASS IN D-E
   130e   21 38 13      	LXI	H,CALSC		; SUCCESSFUL CALL ADDRESS
   1311   22 0f 3f      BRSB:	SHLD	EXOP1		; REPLACE JUMP ADDRESS IN RAM
   1314   eb            	XCHG			; PASS USER'S SAVE ADDRESS IN H-L
   1315   c3 1b 13      	JMP	FLRS		; RESTORE FLAGS AND EXECUTE
   1318   21 27 13      RETYP:	LXI	H,RETSC		; RETURN SUCCESSFUL ADDRESS
   131b   f1            FLRS:	POP	PSW		; RESTORE FLAGS
   131c   f5            	PUSH	PSW		; RESTORE STACK POINTER TO MSTCK
   131d   e5            	PUSH	H		; PUT USER'S ADDRESS AT MSTCK-2
   131e   21 29 12      	LXI	H,FINI		; GET RETURN POINT
   1321   22 12 3f      	SHLD	EXOP4		; FOR UNSUCCESSFUL CALL/RET
   1324   c3 0e 3f      	JMP	EXOP		; EXECUTION STEP
                        ;
   1327   2a 0a 3f      RETSC:	LHLD	SSAVE		; GET ORIGINAL STACK POINTER VALUE
   132a   f9            	SPHL			; RESET STACK POINTER TO THIS VALUE
   132b   e1            	POP	H		; RETURN ADDRESS - ORIGINAL STACK
   132c   c3 43 13      	JMP	SAVPS		; UPDATE PSAVE AND SSAVE
   132f   3a 0e 3f      RSTTY:	LDA	EXOP		; GET OPCODE
   1332   e6 38         	ANI	070Q		; EXTRACT MIDDLE ORDER OCTAL PART
   1334   6f            	MOV	L,A		; WHICH IS LOW ORDER ADDRESS
   1335   26 00         	MVI	H,0		; FILL H WITH 0'S
   1337   e5            	PUSH	H		; SAVE AT MSTCK-2
   1338   2a 0a 3f      CALSC:	LHLD	SSAVE		; GET ORIGINAL STACK POINTER VALUE
   133b   f9            	SPHL			; RESET STACK POINTER TO THIS VALUE
   133c   2a 0c 3f      	LHLD	PSAVE		; GET RETURN ADDRESS AFTER CALL
   133f   e5            	PUSH	H		; PUT ON ORIGINAL STACK
   1340   2a 00 3f      	LHLD	MSTC2		; GET ORIGINAL CALL ADDRESS
   1343   22 0c 3f      SAVPS:	SHLD	PSAVE		; UPDATE PSAVE TO CORRECT ADDRESS
   1346   21 00 00      	LXI	H,0		; FILL H-L WITH 0'S
   1349   39            	DAD	SP		; GET VALUE OF STACK POINTER
   134a   22 0a 3f      	SHLD	SSAVE		; SAVE - NEW VALUE OF STACK POINTER
   134d   c3 29 12      	JMP	FINI		; FINISHED
                        ;
                        ;*********************************************************************
                        ;*               RETURN NUMBER OF BYTES FOR OPCODE                   *
                        ;*       A- HAS OPCODE ON ENTRY AND BYTE COUNT ON EXIT               *
                        ;*********************************************************************
   1350   21 54 19      TCNT:	LXI	H,CLTBL		; GET 1ST PART OF OP COUNT TABLE
   1353   fe 40         	CPI	40H		; SEE IF LOW PART OF OP COUNT TABLE
   1355   da 63 13      	JC	MAKCN		; IF SO NEED TO LOOK UP THE COUNT
   1358   21 64 19      	LXI	H,CHTBL		; GET SECOND PART OF OP COUNT TABLE
   135b   d6 c0         	SUI	0C0H		; SEE IF 2ND PART OF OP COUNT TABLE
   135d   d2 63 13      	JNC	MAKCN		; IF SO NEED TO LOOK UP THE COUNT
   1360   3e 01         	MVI	A,1		; IF NOT, COUNT MUST BE 1
   1362   c9            	RET			; AND NO MORE TO DO
                        ;
   1363   fe 04         MAKCN:	CPI	4		; SEE IF LESS THAN OR EQUAL TO 3
   1365   da 6e 13      	JC	EXBYT		; IF SO EXTRACT THE BYTE
   1368   23            	INX	H		; POINT H TO NEXT BYTE
   1369   d6 04         	SUI	4		; SUBTRACT 4 FROM ACCUMULATOR
   136b   c3 63 13      	JMP	MAKCN		; TRY AGAIN
   136e   b7            EXBYT:	ORA	A		; SET FLAG IF A SUBTRACTED TO ZERO
   136f   07            	RLC			; DOUBLE VALUE IN A
   1370   47            	MOV	B,A		; SAVE A IN B
   1371   7e            	MOV	A,M		; GET BYTE OF OP COUNT INFORMATION
   1372   ca 7a 13      	JZ	FSTCN		; EXTRACT DATA IF Z FLAG = 1
   1375   07            RLC10:	RLC			; ROTATE ACCUMULATOR LEFT ONCE
   1376   05            	DCR	B		; ONE LESS FOR B
   1377   c2 75 13      	JNZ	RLC10		; ROTATE SOME MORE IF B NOT ZERO YET
   137a   07            FSTCN:	RLC			; ROTATE VALUE TO BIT 0
   137b   07            	RLC			; AND TO BIT 1
   137c   e6 03         	ANI	03H		; MASK OUT REST OF BYTE
   137e   c9            	RET			; OPCODE BYTE COUNT IS NOW IN A
                        ;
                        ;
                        ;************************************************************
                        ;* 8085 DISASSEMBLER
                        ;* (c) 2017  DAVID HUNTER
                        ;*
                        ;* PRINT THE OPCODE AND APPROPRIATE BYTES/WORDS 
                        ;* FOR THE INSTRUCTION POINTED TO BY (H,L)
                        ;* H,L IS UPDATED BEFORE IT RETURNS SO IT CAN BE CALLED AGAIN
                        ;************************************************************
   137f   7e            DISASM:	MOV	A,M		; GET OP CODE
   1380   e6 c0         	ANI	0C0H		; DETERMINE INSTRUCTION TYPE
   1382   ca de 14      	JZ	TYPE0
   1385   fe 40         	CPI	40H
   1387   ca b1 14      	JZ	TYPE1
   138a   fe 80         	CPI	80H
   138c   ca 9c 14      	JZ	TYPE2
                        ;
                        ; TYPE 3 INSTRUCTIONS CALLS, RETURNS, JUMPS, ETC.
                        ; FORMAT: 11 YYY ZZZ
   138f   7e            TYPE3:	MOV	A,M		; GET OP CODE
   1390   e6 07         	ANI	07H		; DETERMINE SUB TYPE
   1392   c2 a1 13      	JNZ	TYPE3A
                        				; 11YYY000
   1395   3e 52         	MVI	A,'R'		; CONDITIONAL RETURN
   1397   cd 4d 16      	CALL	OUTT
   139a   cd d5 15      	CALL	PCOND		; PRINT CONDITION CODE
   139d   23            	INX	H		; INCREMENT POINTER
   139e   c3 0c 16      	JMP	PEXIT
                        ;
   13a1   3d            TYPE3A:	DCR	A		; 11YYY001
   13a2   c2 c9 13      	JNZ	TYPE3B
                        ;	
   13a5   7e            	MOV	A,M		; GET OP CODE
   13a6   e6 08         	ANI	08H		; CHECK IF POP OR OTHER
   13a8   c2 bb 13      	JNZ	TYP3A1
   13ab   11 cc 1b      	LXI	D,IPOP		; 11YY0001 POP
   13ae   cd 72 16      	CALL	SENDM		; SEND STRING
   13b1   11 07 1a      	LXI	D,STKPR
   13b4   cd c8 15      	CALL	PPAIR		; PRINT REGISTER PAIR
   13b7   23            	INX	H		; INCREMENT POINTER
   13b8   c3 0c 16      	JMP	PEXIT
                        ;	
   13bb   7e            TYP3A1:	MOV	A,M		; 11YY1001 RET,PCHL,SPHL
   13bc   e6 30         	ANI	30H		; DETERMINE SPECIAL INSTRUCTION
   13be   0f            	RRC			; OFFSET * 8
   13bf   11 f7 1a      	LXI	D,IOP31		; POINT TO TABLE
   13c2   cd dc 15      	CALL	POFF		; AND PRINT
   13c5   23            	INX	H		; INCREMENT POINTER
   13c6   c3 0c 16      	JMP	PEXIT
                        ;
   13c9   3d            TYPE3B:	DCR	A		; 11YYY010
   13ca   c2 de 13      	JNZ	TYPE3C
   13cd   3e 4a         	MVI	A,'J'		; CONDITIONAL JUMP
   13cf   cd 4d 16      	CALL	OUTT
   13d2   cd d5 15      	CALL	PCOND		; PRINT CONDITION CODE
   13d5   3e 20         	MVI	A,' '
   13d7   cd 4d 16      	CALL	OUTT		; ALIGN ADDRESS
   13da   23            	INX	H
   13db   c3 02 16      	JMP	PWORD		; PRINT ADDRESS AND RETURN
                        ;
   13de   3d            TYPE3C:	DCR	A		; 11YYY011
   13df   c2 2b 14      	JNZ	TYPE3D
   13e2   7e            	MOV	A,M		; JMP, OUT, IN, XTHL, XCHG, DI, EI
   13e3   fe c3         	CPI	0C3H		; JUMP?
   13e5   ca fe 13      	JZ	TYP3C1
   13e8   fe d3         	CPI	0D3H		; OUT?
   13ea   ca 0d 14      	JZ	TYP3C2
   13ed   fe db         	CPI	0DBH		; IN?
   13ef   ca 1c 14      	JZ	TYP3C3
   13f2   e6 38         	ANI	38H		; NO, DETERMINE INSTRUCTION
   13f4   11 17 1b      	LXI	D,IOP33		; POINT TO TABLE
   13f7   cd dc 15      	CALL	POFF		; PRINT INSTRUCTION
   13fa   23            	INX	H		; INCREMENT POINTER
   13fb   c3 0c 16      	JMP	PEXIT
                        ;
   13fe   11 17 1b      TYP3C1:	LXI	D,IJMP		; JMP INSTRUCTION
   1401   cd 72 16      	CALL	SENDM
   1404   3e 20         	MVI	A,' '
   1406   cd 4d 16      	CALL	OUTT		; PRINT SPACE
   1409   23            	INX	H		; POINT TO ADDRESS
   140a   c3 02 16      	JMP	PWORD		; AND PRINT IT AND RETURN
                        ;
   140d   11 27 1b      TYP3C2:	LXI	D,IOUT		; OUT INSTRUCTION
   1410   cd 72 16      	CALL	SENDM
   1413   3e 20         	MVI	A,' '
   1415   cd 4d 16      	CALL	OUTT		; PRINT SPACE
   1418   23            	INX	H		; POINT TO PORT NUMBER
   1419   c3 fa 15      	JMP	PBYTE		; AND PRINT IT AND RETURN
                        ;
   141c   11 2f 1b      TYP3C3:	LXI	D,IIN		; IN INSTRUCTION
   141f   cd 72 16      	CALL	SENDM
   1422   3e 20         	MVI	A,' '
   1424   cd 4d 16      	CALL	OUTT		; PRINT SPACE
   1427   23            	INX	H		; POINT TO PORT NUMBER
   1428   c3 fa 15      	JMP	PBYTE		; AND PRINT IT AND RETURN
                        ;
   142b   3d            TYPE3D:	DCR	A		; 11YYY100
   142c   c2 40 14      	JNZ	TYPE3E
   142f   3e 43         	MVI	A,'C'		; CONDITIONAL CALL
   1431   cd 4d 16      	CALL	OUTT
   1434   cd d5 15      	CALL	PCOND		; PRINT CONDITION CODE
   1437   3e 20         	MVI	A,' '
   1439   cd 4d 16      	CALL	OUTT		; ALIGN ADDRESS
   143c   23            	INX	H		; POINT TO ADDRESS
   143d   c3 02 16      	JMP	PWORD		; AND PRINT IT AND RETURN	
                        ;
   1440   3d            TYPE3E:	DCR	A		; 11YYY101
   1441   c2 6f 14      	JNZ	TYPE3F
   1444   7e            	MOV	A,M		; GET OP CODE
   1445   e6 08         	ANI	08H		; CHECK IF PUSH OR CALL
   1447   c2 5a 14      	JNZ	TYP3E1
   144a   11 d1 1b      	LXI	D,IPUSH		; 11YY0101 PUSH
   144d   cd 72 16      	CALL	SENDM		; SEND STRING
   1450   11 07 1a      	LXI	D,STKPR
   1453   cd c8 15      	CALL	PPAIR		; PRINT REGISTER PAIR
   1456   23            	INX	H		; INCREMENT POINTER
   1457   c3 0c 16      	JMP	PEXIT
                        ;	
   145a   7e            TYP3E1:	MOV	A,M		; 11YY1101 CALL
   145b   fe cd         	CPI	0CDH		; CALL INSTRUCTION
   145d   c2 0d 16      	JNZ	PINV
   1460   11 95 1b      	LXI	D,ICALL
   1463   cd 72 16      	CALL	SENDM		; 11001101 CALL
   1466   3e 20         	MVI	A,' '
   1468   cd 4d 16      	CALL	OUTT		; PRINT SPACE
   146b   23            	INX	H		; INCREMENT POINTER
   146c   c3 02 16      	JMP	PWORD		; PRINT ADDRESS AND RETURN
                        ;
   146f   3d            TYPE3F:	DCR	A		; 11YYY110 ADI,ACI, ETC.
   1470   c2 85 14      	JNZ	TYPE3G
   1473   7e            	MOV	A,M
   1474   e6 38         	ANI	38H		; DETERMINE INSTRUCTION
   1476   11 55 1b      	LXI	D,IOP36
   1479   cd dc 15      	CALL	POFF		; PRINT OP CODE
   147c   3e 20         	MVI	A,' '
   147e   cd 4d 16      	CALL	OUTT		; PRINT SPACE
   1481   23            	INX	H		; INCREMENT POINTER
   1482   c3 fa 15      	JMP	PBYTE		; PRINT 8 BIT VALUE AND RETURN
                        ;
   1485   11 db 1b      TYPE3G:	LXI	D,IRST		; 11YYY111 RST
   1488   cd 72 16      	CALL	SENDM		; SEND OP CODE
   148b   3e 20         	MVI	A,' '
   148d   cd 4d 16      	CALL	OUTT
   1490   7e            	MOV	A,M
   1491   e6 38         	ANI	38H		; MASK RESET CODE
   1493   0f            	RRC
   1494   0f            	RRC
   1495   0f            	RRC			; SHIFT OVER TO LOWER BITS
   1496   c6 30         	ADI	30H		; CONVERT TO ASCII
   1498   23            	INX	H		; INCREMENT POINTER
   1499   c3 4d 16      	JMP	OUTT		; PRINT AND RETURN
                        ;
                        ; TYPE 2 INSTRUCTIONS REGISTER MATH
                        ; FORMAT: 10 YYY ZZZ
   149c   7e            TYPE2:	MOV	A,M
   149d   e6 38         	ANI	38H		; DETERMINE INSTRUCTION
   149f   11 b7 1a      	LXI	D,IOP2X
   14a2   cd dc 15      	CALL	POFF		; PRINT OP CODE
   14a5   3e 20         	MVI	A,' '
   14a7   cd 4d 16      	CALL	OUTT		; PRINT A SPACE
   14aa   7e            	MOV	A,M		; GET OP CODE
   14ab   e6 07         	ANI	07H		; MASK OFF REGISTER
   14ad   23            	INX	H		; INCREMENT POINTER
   14ae   c3 ea 15      	JMP	PNAME		; PRINT NAME AND RETURN
                        ;	
                        ; TYPE 1 INSTRUCTIONS REGISTER MOVE
                        ; FORMAT: 01 YYY ZZZ
   14b1   7e            TYPE1:	MOV	A,M
   14b2   fe 76         	CPI	76H		; HALT INSTRUCTION?
   14b4   ca d7 14      	JZ	TYPE1A		; YES, HANDLE SEPARATELY
   14b7   11 bd 1b      	LXI	D,IMOV		; NO,
   14ba   cd 72 16      	CALL	SENDM		; PRINT OP CODE
   14bd   3e 20         	MVI	A,' '
   14bf   cd 4d 16      	CALL	OUTT		; PRINT SPACE
   14c2   7e            	MOV	A,M		; GET OP CODE BACK
   14c3   e6 38         	ANI	38H		; GET UPPER REGISTER
   14c5   0f            	RRC
   14c6   0f            	RRC
   14c7   0f            	RRC
   14c8   cd ea 15      	CALL	PNAME		; PRINT REGISTER NAME
   14cb   3e 2c         	MVI	A,','
   14cd   cd 4d 16      	CALL	OUTT		; PRINT COMMA
   14d0   7e            	MOV	A,M
   14d1   e6 07         	ANI	07H		; GET LOWER REGISTER
   14d3   23            	INX	H		; INCREMENT POINTER
   14d4   c3 ea 15      	JMP	PNAME		; PRINT NAME AND RETURN
                        ;
   14d7   11 a9 1b      TYPE1A:	LXI	D,IHLT
   14da   23            	INX	H		; INCREMENT POINTER
   14db   c3 72 16      	JMP	SENDM		; PRINT HALT AND RETURN
                        ;	
                        ; TYPE 1 INSTRUCTIONS NOP, RIM, SIM, LXI, DAD, ETC.
                        ; FORMAT: 00 YYY ZZZ
   14de   7e            TYPE0:	MOV	A,M		; GET OP CODE
   14df   e6 07         	ANI	07H		; DETERMINE SUB TYPE
   14e1   c2 08 15      	JNZ	TYPE0A
   14e4   7e            	MOV	A,M		; 00YYY000
   14e5   fe 20         	CPI	20H		; RIM?
   14e7   c2 f1 14      	JNZ	TYP01
   14ea   23            	INX	H		; INCREMENT POINTER
   14eb   11 d6 1b      	LXI	D,IRIM
   14ee   c3 72 16      	JMP	SENDM		; YES, PRINT IT AND RETURN
                        
   14f1   fe 30         TYP01:	CPI	30H		; SIM?
   14f3   c2 fd 14      	JNZ	TYP02
   14f6   23            	INX	H		; INCREMENT POINTER
   14f7   11 e0 1b      	LXI	D,ISIM
   14fa   c3 72 16      	JMP	SENDM		; YES, PRINT IT AND RETURN
                        	
   14fd   b7            TYP02:	ORA	A		; SET FLAGS
   14fe   11 c7 1b      	LXI	D,INOP
   1501   23            	INX	H		; INCREMENT POINTER
   1502   ca 72 16      	JZ	SENDM		; NOP? YES, SEND AND RETURN
   1505   c3 0d 16      	JMP	PINV		; ELSE INVALID
                        ;
   1508   3d            TYPE0A:	DCR	A		; 00YYY001 LXI OR DAD
   1509   c2 37 15      	JNZ	TYPE0B
   150c   7e            	MOV	A,M		; GET OP CODE
   150d   e6 08         	ANI	08H
   150f   ca 22 15      	JZ	TYP0A1		; LXI OR DAD?
   1512   11 9a 1b      	LXI	D,IDAD
   1515   cd 72 16      	CALL	SENDM		; DAD, SEND OP 
   1518   11 f7 19      	LXI	D,REGPR
   151b   cd c8 15      	CALL	PPAIR		; SEND REGISTER PAIR AND RETURN
   151e   23            	INX	H		; INCREMENT POINTER
   151f   c3 0c 16      	JMP	PEXIT
                        ;	
   1522   11 b8 1b      TYP0A1:	LXI	D,ILXI		; LXI, SEND OP
   1525   cd 72 16      	CALL	SENDM		; SEND STRING
   1528   11 f7 19      	LXI	D,REGPR
   152b   cd c8 15      	CALL	PPAIR		; PRINT REGISTER PAIR
   152e   3e 2c         	MVI	A,','		; PRINT COMMA
   1530   cd 4d 16      	CALL	OUTT
   1533   23            	INX	H
   1534   c3 02 16      	JMP	PWORD		; PRINT VALUE AND RETURN
                        ;
   1537   3d            TYPE0B:	DCR	A		; 00YYY010  STAX,LDAX, ETC.
   1538   c2 57 15      	JNZ	TYPE0C
   153b   7e            	MOV	A,M		; GET OP CODE
   153c   e6 38         	ANI	38H		; GET OFFSET
   153e   11 37 1a      	LXI	D,IOP02
   1541   cd dc 15      	CALL	POFF		; PRINT OP
   1544   7e            	MOV	A,M
   1545   e6 20         	ANI	20H		; PRINT REGISTER PAIR? (STAX,LDAX)
   1547   c2 4e 15      	JNZ	TYP0B1		; NO, PRINT ADDRESS
   154a   23            	INX	H		; INCREMENT POINTER
   154b   c3 0c 16      	JMP	PEXIT
                        ;	
   154e   3e 20         TYP0B1:	MVI	A,' '
   1550   cd 4d 16      	CALL	OUTT		; PRINT SPACE
   1553   23            	INX	H
   1554   c3 02 16      	JMP	PWORD		; PRINT ADDRESS AND RETURN
                        ;
   1557   3d            TYPE0C:	DCR	A		; 00YYY011  INX, DCX
   1558   c2 77 15      	JNZ	TYPE0D
   155b   7e            	MOV	A,M		; GET OP CODE
   155c   e6 08         	ANI	08H
   155e   ca 67 15      	JZ	TYP0C1		; INX OR DCX?
   1561   11 a4 1b      	LXI	D,IDCX		; DCX
   1564   c3 6a 15      	JMP	TYP0C2
   1567   11 b3 1b      TYP0C1:	LXI	D,IINX		; INX
   156a   cd 72 16      TYP0C2:	CALL	SENDM		; PRINT OP
   156d   11 f7 19      	LXI	D,REGPR
   1570   cd c8 15      	CALL	PPAIR		; PRINT REGISTER PAIR
   1573   23            	INX	H		; INCREMENT POINTER
   1574   c3 0c 16      	JMP	PEXIT
                        ;
   1577   3d            TYPE0D:	DCR	A		; 00YYY100  INR
   1578   c2 81 15      	JNZ	TYPE0E
   157b   11 ae 1b      	LXI	D,IINR
   157e   c3 88 15      	JMP	TYP0E1
                        ;
   1581   3d            TYPE0E:	DCR	A		; 00YYY101  DCR
   1582   c2 9a 15      	JNZ	TYPE0F
   1585   11 9f 1b      	LXI	D,IDCR
                        ;
   1588   cd 72 16      TYP0E1:	CALL	SENDM		; PRINT OP
   158b   3e 20         	MVI	A,' '
   158d   cd 4d 16      	CALL	OUTT		; PRINT SPACE
   1590   7e            	MOV	A,M		; GET OP CODE
   1591   e6 38         	ANI	38H		; GET REGISTER
   1593   0f            	RRC
   1594   0f            	RRC
   1595   0f            	RRC
   1596   23            	INX	H		; INCREMENT POINTER
   1597   c3 ea 15      	JMP	PNAME		; PRINT REGISTER NAME AND RETURN
                        ;
   159a   3d            TYPE0F:	DCR	A		; 00YYY110  MVI
   159b   c2 bb 15      	JNZ	TYPE0G
   159e   11 c2 1b      	LXI	D,IMVI
   15a1   cd 72 16      	CALL	SENDM
                        ;
   15a4   3e 20         	MVI	A,' '
   15a6   cd 4d 16      	CALL	OUTT		; PRINT SPACE
   15a9   7e            	MOV	A,M		; GET OP CODE
   15aa   e6 38         	ANI	38H		; GET REGISTER
   15ac   0f            	RRC
   15ad   0f            	RRC
   15ae   0f            	RRC
   15af   cd ea 15      	CALL	PNAME		; PRINT REGISTER NAME
   15b2   3e 2c         	MVI	A,','
   15b4   cd 4d 16      	CALL	OUTT		; PRINT COMMA
   15b7   23            	INX	H		; INCREMENT POINTER
   15b8   c3 fa 15      	JMP	PBYTE		; PRINT BYTE AND RETURN
                        ;
   15bb   7e            TYPE0G:	MOV	A,M		; 00YYY111  OTHER
   15bc   e6 38         	ANI	38H
   15be   11 77 1a      	LXI	D,IOP07
   15c1   cd dc 15      	CALL	POFF		; PRINT STRING
   15c4   23            	INX	H		; INCREMENT POINTER
   15c5   c3 0c 16      	JMP	PEXIT
                        ;
                        ; PRINT REGISTER PAIR, REGISTER STRING POINTER IN (D,E)
   15c8   3e 20         PPAIR:	MVI	A,' '
   15ca   cd 4d 16      	CALL	OUTT		; PRINT A SPACE
   15cd   7e            	MOV	A,M		; GET OP CODE
   15ce   e6 30         	ANI	30H		; GET REGISTER PAIR
   15d0   0f            	RRC
   15d1   0f            	RRC			; OFFSET INTO TABLE
   15d2   c3 dc 15      	JMP	POFF		; PRINT THE STRING
                        ;
                        ; PRINT CONDITION CODE
   15d5   7e            PCOND:	MOV	A,M		; GET OPCODE
   15d6   e6 38         	ANI	38H		; GET CONDITION CODE
   15d8   0f            	RRC			; OFFSET VALUE TO TABLE
   15d9   11 17 1a      	LXI	D,CONDF		; POINT TO CONDITION FLAGS
                        				; DROP INTO PRINT STRING WITH OFFSET
                        ; 
                        ; PRINT THE STRING IN (D,E) + A
   15dc   e5            POFF:	PUSH	H		; SAVE POINTER
   15dd   eb            	XCHG			; PUT DE -> HL
   15de   5f            	MOV	E,A		; OFFSET IN DE
   15df   16 00         	MVI	D,0		; 
   15e1   19            	DAD	D		; COMPUTE THE OFFSET FROM HL
   15e2   eb            	XCHG			; STRING ADDRESS IN DE
   15e3   cd 72 16      	CALL	SENDM		; PRINT THE STRING
   15e6   e1            	POP	H
   15e7   c3 0c 16      	JMP	PEXIT
                        ;
                        ; PRINT REGISTER NAME BASED ON OFFSET IN A
   15ea   e5            PNAME:	PUSH	H
   15eb   21 ef 19      	LXI	H,REGNAM
   15ee   5f            	MOV	E,A		; OFFSET IN DE
   15ef   16 00         	MVI	D,0		; 
   15f1   19            	DAD	D		; COMPUTE THE OFFSET FROM HL
   15f2   7e            	MOV	A,M		; GET REGISTER NAME
   15f3   cd 4d 16      	CALL	OUTT		; PRINT
   15f6   e1            	POP	H
   15f7   c3 0c 16      	JMP	PEXIT
                        ;
                        ; PRINT SPACE AND BYTE VALUE FROM (H,L), INCREMENT HL
   15fa   4e            PBYTE: 	MOV	C,M
   15fb   23            	INX	H		; INCREMENT POINTER
   15fc   cd 96 16      	CALL	PUTB
   15ff   c3 0c 16      	JMP	PEXIT
                        ;
                        ; PRINT SPACE AND 16 BIT VALUE FROM (H,L), INCREMENT HL TWICE
   1602   5e            PWORD:	MOV	E,M
   1603   23            	INX	H		; INCREMENT POINTER
   1604   56            	MOV	D,M		; VALUE IN D
   1605   23            	INX	H		; INCREMENT POINTER
   1606   e5            	PUSH	H
   1607   eb            	XCHG			; 16 BIT VALUE IN H
   1608   cd 8b 16      	CALL	PUTW		; PRINT IT
   160b   e1            	POP	H
   160c   c9            PEXIT:	RET
                        ;
                        ; PRINT INVALID OP CODE AND RETURN
   160d   11 ff 1a      PINV:	LXI	D,IERR
   1610   c3 72 16      	JMP	SENDM
                        ;
                        ;
                        ;================================================
                        ; "BIT-BANG" SERIAL I/O
                        ;
                        ; CONSOLE INPUT ROUTINE
                        ; ADAPTED FROM THE INTEL MCS-80/85 USER'S MANUAL
                        ; RETURNS THE INPUT BYTE IN ACC
                        ; ALSO INCREMENTS A COUNTER TO USE FOR "RANDOMIZE" KEYWORD
                        ; SAVES REGISTERS
   1613   c5            INPUTT:	PUSH	B
   1614   e5            	PUSH	H
   1615   06 09         	MVI	B,9	; 8 BITS + STOP
   1617                 INP1:	
   1617   20            	RIM		; (4 CLK) GET SERIAL INPUT
   1618   b7            	ORA	A	; (7 CLK) SET/CLEAR SIGN FLAG IN PSW
   1619   f2 26 16      	JP	INP1A	; (7/10 CLK) EXIT IF START BIT ARRIVED
   161c   2a b2 3f      	LHLD	RANDOM	; (16 CLK) INCREMENT RANDOM COUNTER 
   161f   23            	INX	H	; (6 CLK)
   1620   22 b2 3f      	SHLD	RANDOM	; (16 CLK) 
   1623   c3 17 16      	JMP	INP1	; (10 CLK) WAIT FOR START BIT
                        			; POLLING INTERVAL = 66 CLKS => 26.8us => 6.4% OF A BIT TIME
                        ;
   1626   2e 26         INP1A:	MVI	L,HALFBIT 
   1628   2d            INP2:	DCR	L	; WAIT UNTIL THE MIDDLE OF THE START BIT
   1629   c2 28 16      	JNZ	INP2
   162c   00            	NOP
                        ;
   162d   2e 45         INP3:	MVI	L,FULLBIT ; WAIT ONE BIT TIME
   162f   2d            INP4:	DCR	L
   1630   c2 2f 16      	JNZ	INP4
   1633   00            	NOP
   1634   00            	NOP
   1635   20            	RIM		; GET DATA BIT
   1636   17            	RAL
   1637   05            	DCR	B
   1638   ca 42 16      	JZ	INP5
   163b   79            	MOV	A,C
   163c   1f            	RAR
   163d   4f            	MOV	C,A
   163e   00            	NOP		; NEEDED TO HAVE EQUAL # CLOCKS WITH COUT
   163f   c3 2d 16      	JMP	INP3
                        ;
   1642   79            INP5:	MOV	A,C	; GET BYTE INTO ACC
   1643   e6 7f         	ANI	7FH	; MASK OFF 7 BITS
   1645   e1            	POP	H
   1646   c1            	POP	B
   1647   fe 18         	CPI	CTRX	; ABORT?
   1649   ca 30 10      	JZ	WARM	; YES, 
   164c   c9            	RET
                        ;
                        ;
                        ; CONSOLE OUTPUT ROUTINE
                        ; OUTPUT BYTE IN ACC
                        ; SAVES REGISTERS
   164d                 OUTT:	
   164d   f5            	PUSH	PSW
   164e   c5            	PUSH	B
   164f   e5            	PUSH	H
   1650   4f            	MOV	C,A	; OUTPUT BYTE INTO C
                        	
   1651   af            	XRA	A	; CLEAR A, CARRY
   1652   06 0a         	MVI	B,10	; 10 BITS FOR 8N1
   1654   3e 80         OUT1:	MVI	A,80H	; SET SOD ENABLE BIT << 1
   1656   1f            	RAR		; GET BIT FROM CARRY
   1657   30            	SIM		; OUTPUT BIT
                        ;	
   1658   2e 45         	MVI	L,FULLBIT
   165a   2d            OUT2:	DCR	L	; DELAY ONE BIT TIME
   165b   c2 5a 16      	JNZ	OUT2
   165e   00            	NOP
   165f   00            	NOP
   1660   37            	STC		; SET STOP BIT
   1661   79            	MOV	A,C
   1662   1f            	RAR		; GET NEXT BIT INTO CARRY
   1663   4f            	MOV	C,A
   1664   05            	DCR	B
   1665   c2 54 16      	JNZ	OUT1
                        ;	
   1668   e1            	POP	H
   1669   c1            	POP	B
   166a   f1            	POP	PSW	; RETURN THE OUTPUT BYTE
   166b   c9            	RET
                        ;
                        ;================================================
                        ; MONITOR UTILITY SUBROUTINES
                        ;
                        ; GET CHARACTER AND ECHO
   166c   cd 13 16      GETCHE:	CALL	INPUTT
   166f   c3 4d 16      	JMP	OUTT
                        ;
                        ; SEND NULL TERMINATED STRING IN D,E
   1672   1a            SENDM:	LDAX	D	; GET CHARACTER
   1673   b7            	ORA	A	; SET FLAGS
   1674   c8            	RZ		; EXIT IF NULL
   1675   cd 4d 16      	CALL	OUTT	; SEND IT
   1678   13            	INX	D	; NEXT CHARACTER
   1679   c3 72 16      	JMP	SENDM
                        ;
                        ; SEND CR,LF
   167c   3e 0d         NEWLN:	MVI	A,CR
   167e   cd 4d 16      	CALL	OUTT
   1681   3e 0a         	MVI	A,LF
   1683   c3 4d 16      	JMP	OUTT
                        ;
                        ; SEND SPACE
   1686   3e 20         SPACE:	MVI	A,' '
   1688   c3 4d 16      	JMP	OUTT
                        ;
                        ; SEND SPACE, THEN 16 BIT WORD IN H,L AS HEX
   168b   cd 86 16      PUTW:	CALL	SPACE
   168e   4c            PUTHL:	MOV	C,H
   168f   cd 99 16      	CALL	PUTBYT
   1692   4d            	MOV	C,L
   1693   c3 99 16      	JMP	PUTBYT
                        ;
                        ; SEND SPACE, THEN BYTE IN C OUT AS HEX
   1696   cd 86 16      PUTB:	CALL	SPACE
   1699   79            PUTBYT:	MOV	A,C	; GET BYTE
   169a   0f            	RRC		; MOVE UPPER NIBBLE OVER
   169b   0f            	RRC
   169c   0f            	RRC
   169d   0f            	RRC
   169e   e6 0f         	ANI	0FH	; MASK OFF BITS
   16a0   cd a6 16      	CALL	PUTHEX
   16a3   79            	MOV	A,C	; GET BYTE BACK
   16a4   e6 0f         	ANI	0FH	; MASK OFF BITS
                        			; DROP INTO PUTHEX
                        ;
                        ; PRINT LOWER 4 BITS OF ACC AS HEX VALUE
   16a6   c6 90         PUTHEX:	ADI	90H
   16a8   27            	DAA
   16a9   ce 40         	ACI	40H
   16ab   27            	DAA
   16ac   c3 4d 16      	JMP	OUTT
                        ;
                        ; SEND BYTE IN L AS 8 BITS
   16af   cd 86 16      BITS:	CALL	SPACE
   16b2   c5            	PUSH	B	; SAVE REGISTERS
   16b3   06 00         	MVI	B,0	; ZERO REGISTER B FOR ACC CLEAR
   16b5   0e 08         	MVI	C,8	; 8 BITS
   16b7   7d            NXTBIT:	MOV	A,L	; GET BYTE
   16b8   07            	RLC		; MOVE UPPER BIT INTO CARRY
   16b9   6f            	MOV	L,A	; SAVE BYTE
   16ba   78            	MOV	A,B	; CLEAR ACC
   16bb   ce 30         	ACI	'0'	; PRINT CARRY BIT
   16bd   cd 4d 16      	CALL	OUTT	; SEND DIGIT
   16c0   0d            	DCR	C	; DECREMENT COUNT
   16c1   c2 b7 16      	JNZ	NXTBIT
   16c4   c1            	POP	B
   16c5   c9            	RET		; EXIT IF DONE
                        ;
                        ; GET 16 BIT HEX WORD, CONVERT TO BINARY, RETURN IN H,L
   16c6   cd cf 16      GETW:	CALL	GETB	; GET UPPER BYTE
   16c9   67            	MOV	H,A	; PUT IN H
   16ca   cd cf 16      	CALL	GETB	; GET LOWER BYTE
   16cd   6f            	MOV	L,A	; PUT IN L
   16ce   c9            	RET
                        ;
                        ; GET HEX BYTE, CONVERT TO BINARY, RETURN IN A
   16cf   c5            GETB:	PUSH	B	; SAVE REGISTERS
   16d0   cd e0 16      	CALL	GETHEX	; GET UPPER NIBBLE
   16d3   17            	RAL
   16d4   17            	RAL
   16d5   17            	RAL
   16d6   17            	RAL
   16d7   e6 f0         	ANI	0F0H	; MASK OFF UPPER BITS
   16d9   4f            	MOV	C,A	; SAVE
   16da   cd e0 16      	CALL	GETHEX	; GET LOWER NIBBLE
   16dd   b1            	ORA	C	; BRING IN UPPER BITS
   16de   c1            	POP	B
   16df   c9            	RET
                        ;
   16e0   cd 6c 16      GETHEX: CALL	GETCHE	; GET CHAR AND ECHO
   16e3   fe 30         CHKHEX:	CPI	'0'	; BETWEEN 0 AND 9?
   16e5   da 57 10      	JC	ERROR
   16e8   fe 3a         	CPI	'9'+1
   16ea   da f9 16      	JC	CONVHX
   16ed   e6 5f         	ANI	05FH	; CONVERT TO UPPER CASE
   16ef   fe 41         	CPI	'A'	; BETWEEN A AND F?
   16f1   da 57 10      	JC	ERROR
   16f4   fe 47         	CPI	'F'+1
   16f6   d2 57 10      	JNC	ERROR
                        			; FALL INTO CONVHX
                        ;
   16f9   d6 30         CONVHX:	SUI	'0'	; CONVERT TO BINARY
   16fb   fe 0a         	CPI	0AH	; 0-9?
   16fd   d8            	RC		; YES, RETURN
   16fe   d6 07         	SUI	7	; NO, ADJUST A-F
   1700   c9            	RET
                        ;
                        ;
                        ;================================================
                        ;
                        ; SIGN ON MESSAGE AT EACH COLD START
   1701   0d 0a         SIGNON:	DB	CR,LF
   1703   41 6c 74 61   	DB	'Altaids Monitor Ver '
   1707   69 64 73 20   
   170b   4d 6f 6e 69   
   170f   74 6f 72 20   
   1713   56 65 72 20   
   1717   30 35         	DW	VERS
   1719   0d 0a         	DB	CR,LF
   171b   43 6f 70 79   	DB	'Copyright (C) 2018 David R. Hunter',CR,LF
   171f   72 69 67 68   
   1723   74 20 28 43   
   1727   29 20 32 30   
   172b   31 38 20 44   
   172f   61 76 69 64   
   1733   20 52 2e 20   
   1737   48 75 6e 74   
   173b   65 72 0d 0a   
   173f   54 68 69 73   	DB	'This program comes with ABSOLUTELY NO WARRANTY',CR,LF
   1743   20 70 72 6f   
   1747   67 72 61 6d   
   174b   20 63 6f 6d   
   174f   65 73 20 77   
   1753   69 74 68 20   
   1757   41 42 53 4f   
   175b   4c 55 54 45   
   175f   4c 59 20 4e   
   1763   4f 20 57 41   
   1767   52 52 41 4e   
   176b   54 59 0d 0a   
   176f   54 68 69 73   	DB 	'This is free software, and you are welcome to redistribute it',CR,LF
   1773   20 69 73 20   
   1777   66 72 65 65   
   177b   20 73 6f 66   
   177f   74 77 61 72   
   1783   65 2c 20 61   
   1787   6e 64 20 79   
   178b   6f 75 20 61   
   178f   72 65 20 77   
   1793   65 6c 63 6f   
   1797   6d 65 20 74   
   179b   6f 20 72 65   
   179f   64 69 73 74   
   17a3   72 69 62 75   
   17a7   74 65 20 69   
   17ab   74 0d 0a      
   17ae   75 6e 64 65   	DB	'under certain conditions; see the GNU GPL Version 3 for details',CR,LF
   17b2   72 20 63 65   
   17b6   72 74 61 69   
   17ba   6e 20 63 6f   
   17be   6e 64 69 74   
   17c2   69 6f 6e 73   
   17c6   3b 20 73 65   
   17ca   65 20 74 68   
   17ce   65 20 47 4e   
   17d2   55 20 47 50   
   17d6   4c 20 56 65   
   17da   72 73 69 6f   
   17de   6e 20 33 20   
   17e2   66 6f 72 20   
   17e6   64 65 74 61   
   17ea   69 6c 73 0d   
   17ee   0a            
   17ef   54 79 70 65   	DB	'Type "B" for BASIC, "H" for help',CR,LF
   17f3   20 22 42 22   
   17f7   20 66 6f 72   
   17fb   20 42 41 53   
   17ff   49 43 2c 20   
   1803   22 48 22 20   
   1807   66 6f 72 20   
   180b   68 65 6c 70   
   180f   0d 0a         
   1811   54 79 70 65   	DB	'Type ^X to return to the Monitor',CR,LF
   1815   20 5e 58 20   
   1819   74 6f 20 72   
   181d   65 74 75 72   
   1821   6e 20 74 6f   
   1825   20 74 68 65   
   1829   20 4d 6f 6e   
   182d   69 74 6f 72   
   1831   0d 0a         
   1833   00            	DB	0
                        ;
                        ; MONITOR HELP MESSAGE
   1834   0d 0a         HLPMSG:	DB	CR,LF
   1836   4d 6f 6e 69   	DB	'Monitor commands',CR,LF
   183a   74 6f 72 20   
   183e   63 6f 6d 6d   
   1842   61 6e 64 73   
   1846   0d 0a         
   1848   41 20 3a 20   	DB	'A : ALTAIR MONITOR',CR,LF
   184c   41 4c 54 41   
   1850   49 52 20 4d   
   1854   4f 4e 49 54   
   1858   4f 52 0d 0a   
   185c   42 20 3a 20   	DB	'B : TINY BASIC',CR,LF
   1860   54 49 4e 59   
   1864   20 42 41 53   
   1868   49 43 0d 0a   
   186c   44 20 3a 20   	DB	'D : DUMP [Dnnnn mmmmm]',CR,LF
   1870   44 55 4d 50   
   1874   20 5b 44 6e   
   1878   6e 6e 6e 20   
   187c   6d 6d 6d 6d   
   1880   6d 5d 0d 0a   
   1884   45 20 3a 20   	DB	'E : ENTER [Ennnn]',CR,LF
   1888   45 4e 54 45   
   188c   52 20 5b 45   
   1890   6e 6e 6e 6e   
   1894   5d 0d 0a      
   1897   47 20 3a 20   	DB	'G : RUN [Gnnnn]',CR,LF
   189b   52 55 4e 20   
   189f   5b 47 6e 6e   
   18a3   6e 6e 5d 0d   
   18a7   0a            
   18a8   48 20 3a 20   	DB	'H : HELP (this message)',CR,LF
   18ac   48 45 4c 50   
   18b0   20 28 74 68   
   18b4   69 73 20 6d   
   18b8   65 73 73 61   
   18bc   67 65 29 0d   
   18c0   0a            
   18c1   49 20 3a 20   	DB	'I : INPUT FROM PRT 60H',CR,LF
   18c5   49 4e 50 55   
   18c9   54 20 46 52   
   18cd   4f 4d 20 50   
   18d1   52 54 20 36   
   18d5   30 48 0d 0a   
   18d9   4c 20 3a 20   	DB	'L : LOAD HEX FILE',CR,LF
   18dd   4c 4f 41 44   
   18e1   20 48 45 58   
   18e5   20 46 49 4c   
   18e9   45 0d 0a      
   18ec   4f 20 3a 20   	DB	'O : OUTPUT TO PRT 61H [Obb]',CR,LF
   18f0   4f 55 54 50   
   18f4   55 54 20 54   
   18f8   4f 20 50 52   
   18fc   54 20 36 31   
   1900   48 20 5b 4f   
   1904   62 62 5d 0d   
   1908   0a            
   1909   52 20 3a 20   	DB	'R : DISPLAY REG',CR,LF
   190d   44 49 53 50   
   1911   4c 41 59 20   
   1915   52 45 47 0d   
   1919   0a            
   191a   54 20 3a 20   	DB	'T : TRACE (STEP) [Tnnnn]',CR,LF
   191e   54 52 41 43   
   1922   45 20 28 53   
   1926   54 45 50 29   
   192a   20 5b 54 6e   
   192e   6e 6e 6e 5d   
   1932   0d 0a         
   1934   00            	DB	0
                        ;
                        ;
                        ;*********************************************************************
                        ;*   TABLES USED TO LOOK UP CERTAIN OPCODES AND JUMP LOCATIONS       *
                        ;* THESE ARE EXCEPTIONS TO THE "REGULAR" OP CODE DECODING            *
                        ;*********************************************************************
   1935   e9            OOTBL:	DB	0E9H		; PCHL INSTRUCTION BYTE
   1936   ee 12         	DW	PCH
   1938   c3            	DB	0C3H		; JMP INSTRUCTION BYTE
   1939   f7 12         	DW	BRTYP
   193b   cd            	DB	0CDH		; CALL INSTRUCTION BYTE
   193c   0a 13         	DW	CALTY
   193e   c9            	DB	0C9H		; RET INSTRUCTION BYTE
   193f   18 13         	DW	RETYP
   1941   76            	DB	076H		; HLT INSTRUCTION BYTE
   1942   30 10         	DW	WARM		; EXIT WITH HALT
   1944   18 13         SYTBL:	DW	RETYP
   1946   cf 12         	DW	EXCYC
   1948   f7 12         	DW	BRTYP
   194a   cf 12         	DW	EXCYC
   194c   0a 13         	DW	CALTY
   194e   cf 12         	DW	EXCYC
   1950   cf 12         	DW	EXCYC
   1952   2f 13         	DW	RSTTY
                        	; PACKED COUNT OF BYTES (4 PER BYTE) FOR INSTRUCTIONS 00 - 3F
                        	;       00H,04H,08H,0CH,10H,14H,18H,1CH,20H,24H,28H,2CH,30H,34H,38H,3CH
   1954   75 59 15 59   CLTBL:	DB	75H,59H,15H,59H,35H,59H,15H,59H,7DH,59H,1DH,59H,7DH,59H,1DH,59H
   1958   35 59 15 59   
   195c   7d 59 1d 59   
   1960   7d 59 1d 59   
                        	; INSTRUCTIONS 40 - BF ARE SINGLE BYTE INSTRUCTIONS
                        	; PACKED COUNT OF BYTES FOR INSTRUCTIONS C0 - FF
                        	;	C0H,C4H, C8H, CCH,D0H, D4H,D8H, DCH,E0H, E4H,E8H, ECH,F0H, F4H,F8H, FCH
   1964   5f d9 5c f9   CHTBL:	DB	5FH,0D9H,5CH,0F9H,5EH,0D9H,4EH,0C9H,5DH,0D9H,5DH,0C9H,5DH,0D9H,5DH,0C9H
   1968   5e d9 4e c9   
   196c   5d d9 5d c9   
   1970   5d d9 5d c9   
                        ;
                        ; REGISTER IDENTIFIERS
                        ;
   1974   0d 0a         REGLST:	DB	CR,LF
   1976   50 43 20 20   	DB	"PC  :SP  :A  SZ_A_P_C:B C :D E :H L"
   197a   3a 53 50 20   
   197e   20 3a 41 20   
   1982   20 53 5a 5f   
   1986   41 5f 50 5f   
   198a   43 3a 42 20   
   198e   43 20 3a 44   
   1992   20 45 20 3a   
   1996   48 20 4c      
   1999   0d 0a 00      	DB	CR,LF,0
                        ;
                        ; USER INSTRUCTIONS
   199c   0d 0a         DISINS:	DB	CR,LF
   199e   50 72 65 73   	DB	'Press any key to step to the next instruction'
   19a2   73 20 61 6e   
   19a6   79 20 6b 65   
   19aa   79 20 74 6f   
   19ae   20 73 74 65   
   19b2   70 20 74 6f   
   19b6   20 74 68 65   
   19ba   20 6e 65 78   
   19be   74 20 69 6e   
   19c2   73 74 72 75   
   19c6   63 74 69 6f   
   19ca   6e            
   19cb   0d 0a         	DB	CR,LF
   19cd   50 72 65 73   	DB	'Press ^C to return to the Monitor'
   19d1   73 20 5e 43   
   19d5   20 74 6f 20   
   19d9   72 65 74 75   
   19dd   72 6e 20 74   
   19e1   6f 20 74 68   
   19e5   65 20 4d 6f   
   19e9   6e 69 74 6f   
   19ed   72            
   19ee   00            	DB	0
                        ;
                        ;
                        ;*********************************************************************
                        ;* DISASSEMBLER TABLES
                        ;*********************************************************************
                        ; REGISTER NAMES  (IN OP CODE ORDER)
   19ef   42            REGNAM:	DB	"B"
   19f0   43            	DB	"C"
   19f1   44            	DB	"D"
   19f2   45            	DB	"E"
   19f3   48            	DB	"H"
   19f4   4c            	DB	"L"
   19f5   4d            	DB	"M"
   19f6   41            	DB	"A"
                        ; REGISTER PAIRS (IN OP CODE ORDER, 4 BYTES EACH)
   19f7   42 20 20 00   REGPR:	DB	"B  ",0
   19fb   44 20 20 00   	DB	"D  ",0
   19ff   48 20 20 00   	DB	"H  ",0
   1a03   53 50 20 00   	DB	"SP ",0
                        ; STACK REGISTER PAIRS (IN OP CODE ORDER, 4 BYTES EACH)
   1a07   42 20 20 00   STKPR:	DB	"B  ",0
   1a0b   44 20 20 00   	DB	"D  ",0
   1a0f   48 20 20 00   	DB	"H  ",0
   1a13   50 53 57 00   	DB	"PSW",0
                        ; CONDITIONAL FLAGS (IN OP CODE ORDER, 4 BYTES EACH)
   1a17   4e 5a 20 00   CONDF:	DB	"NZ ",0
   1a1b   5a 20 20 00   	DB	"Z  ",0
   1a1f   4e 43 20 00   	DB	"NC ",0
   1a23   43 20 20 00   	DB	"C  ",0
   1a27   50 4f 20 00   	DB	"PO ",0
   1a2b   50 45 20 00   	DB	"PE ",0
   1a2f   50 20 20 00   	DB	"P  ",0
   1a33   4d 20 20 00   	DB	"M  ",0
                        ; OP CODE STRINGS (INTEL MNEMONICS)
                        ;
                        ; THESE ARE SPECIAL TABLES (IN OP CODE ORDER, 8 BYTES EACH)
                        ; OP CODE 00YYY010
   1a37   53 54 41 58   IOP02:	DB	"STAX B",0,0
   1a3b   20 42 00 00   
   1a3f   4c 44 41 58   	DB	"LDAX B",0,0
   1a43   20 42 00 00   
   1a47   53 54 41 58   	DB	"STAX D",0,0
   1a4b   20 44 00 00   
   1a4f   4c 44 41 58   	DB	"LDAX D",0,0
   1a53   20 44 00 00   
   1a57   53 48 4c 44   	DB	"SHLD",0,0,0,0
   1a5b   00 00 00 00   
   1a5f   4c 48 4c 44   	DB	"LHLD",0,0,0,0
   1a63   00 00 00 00   
   1a67   53 54 41 20   	DB	"STA ",0,0,0,0
   1a6b   00 00 00 00   
   1a6f   4c 44 41 20   	DB	"LDA ",0,0,0,0
   1a73   00 00 00 00   
                        ;
                        ; OP CODE 00YYY111
   1a77   52 4c 43 00   IOP07:	DB	"RLC",0,0,0,0,0
   1a7b   00 00 00 00   
   1a7f   52 52 43 00   	DB	"RRC",0,0,0,0,0
   1a83   00 00 00 00   
   1a87   52 41 4c 00   	DB	"RAL",0,0,0,0,0
   1a8b   00 00 00 00   
   1a8f   52 41 52 00   	DB	"RAR",0,0,0,0,0
   1a93   00 00 00 00   
   1a97   44 41 41 00   	DB	"DAA",0,0,0,0,0
   1a9b   00 00 00 00   
   1a9f   43 4d 41 00   	DB	"CMA",0,0,0,0,0
   1aa3   00 00 00 00   
   1aa7   53 54 43 00   	DB	"STC",0,0,0,0,0
   1aab   00 00 00 00   
   1aaf   43 4d 43 00   	DB	"CMC",0,0,0,0,0
   1ab3   00 00 00 00   
                        ;
                        ; OP CODE 10YYYZZZ
   1ab7   41 44 44 20   IOP2X:	DB	"ADD ",0,0,0,0
   1abb   00 00 00 00   
   1abf   41 44 43 20   	DB	"ADC ",0,0,0,0
   1ac3   00 00 00 00   
   1ac7   53 55 42 20   	DB	"SUB ",0,0,0,0
   1acb   00 00 00 00   
   1acf   53 42 42 20   	DB	"SBB ",0,0,0,0
   1ad3   00 00 00 00   
   1ad7   41 4e 41 20   	DB	"ANA ",0,0,0,0
   1adb   00 00 00 00   
   1adf   58 52 41 20   	DB	"XRA ",0,0,0,0
   1ae3   00 00 00 00   
   1ae7   4f 52 41 20   	DB	"ORA ",0,0,0,0
   1aeb   00 00 00 00   
   1aef   43 4d 50 20   	DB	"CMP ",0,0,0,0
   1af3   00 00 00 00   
                        ;
                        ; OP CODE  11YY1001
   1af7   52 45 54 20   IOP31: 	DB	"RET ",0,0,0,0
   1afb   00 00 00 00   
   1aff   3f 3f 3f 3f   IERR:	DB	"????",0,0,0,0	; NOT USED
   1b03   00 00 00 00   
   1b07   50 43 48 4c   	DB	"PCHL",0,0,0,0
   1b0b   00 00 00 00   
   1b0f   53 50 48 4c   	DB	"SPHL",0,0,0,0
   1b13   00 00 00 00   
                        ;
                        ; OP CODE 11YYY011
   1b17                 IOP33:	
   1b17   4a 4d 50 20   IJMP:	DB	"JMP ",0,0,0,0
   1b1b   00 00 00 00   
   1b1f   3f 3f 3f 3f   	DB	"????",0,0,0,0	; NOT USED
   1b23   00 00 00 00   
   1b27   4f 55 54 20   IOUT:	DB	"OUT ",0,0,0,0
   1b2b   00 00 00 00   
   1b2f   49 4e 20 20   IIN:	DB	"IN  ",0,0,0,0
   1b33   00 00 00 00   
   1b37   58 54 48 4c   	DB	"XTHL",0,0,0,0
   1b3b   00 00 00 00   
   1b3f   58 43 48 47   	DB	"XCHG",0,0,0,0
   1b43   00 00 00 00   
   1b47   44 49 00 00   	DB	"DI",0,0,0,0,0
   1b4b   00 00 00      
   1b4e   45 49 00 00   	DB	"EI",0,0,0,0,0
   1b52   00 00 00      
                        ;
                        ; OP CODE 11YYY110
   1b55   41 44 49 20   IOP36:	DB	"ADI ",0,0,0,0
   1b59   00 00 00 00   
   1b5d   41 43 49 20   	DB	"ACI ",0,0,0,0
   1b61   00 00 00 00   
   1b65   53 55 49 20   	DB	"SUI ",0,0,0,0
   1b69   00 00 00 00   
   1b6d   53 42 49 20   	DB	"SBI ",0,0,0,0
   1b71   00 00 00 00   
   1b75   41 4e 49 20   	DB	"ANI ",0,0,0,0
   1b79   00 00 00 00   
   1b7d   58 52 49 20   	DB	"XRI ",0,0,0,0
   1b81   00 00 00 00   
   1b85   4f 52 49 20   	DB	"ORI ",0,0,0,0
   1b89   00 00 00 00   
   1b8d   43 50 49 20   	DB	"CPI ",0,0,0,0
   1b91   00 00 00 00   
                        ;
                        ; OTHER OP CODE NAMES
   1b95   43 41 4c 4c   ICALL:	DB	"CALL",0
   1b99   00            
   1b9a   44 41 44 20   IDAD:	DB	"DAD ",0
   1b9e   00            
   1b9f   44 43 52 20   IDCR:	DB	"DCR ",0
   1ba3   00            
   1ba4   44 43 58 20   IDCX:	DB	"DCX ",0
   1ba8   00            
   1ba9   48 4c 54 20   IHLT:	DB	"HLT ",0
   1bad   00            
   1bae   49 4e 52 20   IINR:	DB	"INR ",0
   1bb2   00            
   1bb3   49 4e 58 20   IINX:	DB	"INX ",0
   1bb7   00            
   1bb8   4c 58 49 20   ILXI:	DB	"LXI ",0
   1bbc   00            
   1bbd   4d 4f 56 20   IMOV:	DB	"MOV ",0
   1bc1   00            
   1bc2   4d 56 49 20   IMVI:	DB	"MVI ",0
   1bc6   00            
   1bc7   4e 4f 50 20   INOP:	DB	"NOP ",0
   1bcb   00            
   1bcc   50 4f 50 20   IPOP:	DB	"POP ",0
   1bd0   00            
   1bd1   50 55 53 48   IPUSH:	DB	"PUSH",0
   1bd5   00            
   1bd6   52 49 4d 20   IRIM:	DB	"RIM ",0
   1bda   00            
   1bdb   52 53 54 20   IRST:	DB	"RST ",0
   1bdf   00            
   1be0   53 49 4d 20   ISIM:	DB	"SIM ",0	
   1be4   00            
                        ;
                        ;******
   1be5                 LSTROM: EQU	$	; END OF ROM
                        ;
                        ; RAM START
   2000                 	ORG	2000H
                        ;* PATB INTERPRETER VARIABLES
   2000   00            ABORTF	DB	0	; ABORT (^C) FLAG
   2001   ff            OCSW:	DB	0FFH	; SWITCH FOR OUTPUT
   2002   00 00         CURRNT:	DW	0	; POINTS TO CURRENT LINE
   2004   00 00         STKGOS:	DW	0	; SAVES SP IN 'GOSUB'
   2006   00 00         VARNXT:	DW	0	; TEMPORARY STORAGE
   2008   00 00         STKINP:	DW	0	; SAVES SP IN 'INPUT'
   200a   00 00         LOPVAR:	DW	0	; 'FOR' LOOP SAVE AREA
   200c   00 00         LOPINC:	DW	0	; INCREMENT
   200e   00 00         LOPLMT:	DW	0	; LIMIT
   2010   00 00         LOPLN:	DW	0	; LINE NUMBER
   2012   00 00         LOPPT:	DW	0	; TEXT POINTER
   2014   85 01         SEED:	DW	BASIC	; RANDOM NUMBER SEED
   2016   ff 3d         ARRUNF: DW	TXTEND-1; POINTER TO UNFILLED ARRAY SPACE
   2018   1a 20         TXTUNF:	DW	TXTBGN	; ->UNFILLED TEXT AREA
                        ;
   201a                 TXTBGN:	DS	1	; TEXT SAVE AREA BEGINS 
                        ;
                        ;	TEXT AREA HERE ~ 7.5K
                        ;	AND GOES UP IN MEMORY
                        ;	
                        ;
                        ;	A-Z ARRAY MEMORY STARTS BELOW VARIABLES
                        ;	AND GOES DOWN IN MEMORY IN THE ORDER OF THE "DIM"
                        ;	STATEMENTS
                        ;
                        ;	@ ARRAY MEMORY STARTS FROM VARBGN GOES DOWN IN MEMORY
                        ;	AND THEREFORE OVERLAPS THE OTHER ARRAY MEMORY
                        ;
                        ; NOTE: PATB USER VARIABLES MUST START ON A PAGE BOUNDARY
                        ;
   3e00                 	ORG	3E00H
   3e00                 TXTEND:	EQU	$	; TEXT SAVE AREA ENDS 
   3e00                 VARBGN: DS	2*27	; USER VARIABLES @(0), A-Z
   3e36                 	DS	2	; EXTRA BYTES FOR LINE NUMBER
   3e38                 BUFFER: DS	80	; INPUT BUFFER
   3e88                 BUFEND: EQU	$	; BUFFER ENDS
   3e88                 	DS	10	; PADDING BETWEEN BUFFER AND STACK
   3e92                 STKLMT:	EQU	$	; TOP LIMIT FOR STACK
                        ;
   3f00                 	ORG	3F00H
                        ;
                        ; 8085 MONITOR SINGLE STEP VARIABLES AND TEMPORARY STACK
                        ;
                        ; NOTE: WHEN PATB IS RUNNING, THESE VARIABLES ARE PART OF 
                        ; 	THE TINY BASIC STACK
                        ;
   3f00                 MSTC2:	DS	2	; ADDRESS AND STACK SAVE LOCATION
   3f02                 MSTCK:	EQU	$
   3f02                 FSAVE:	DS	1	; FLAG SAVE LOCATION
   3f03                 ASAVE:	DS	1	; A REGISTER SAVE LOCATION
   3f04                 CSAVE:	DS	1	; C REGISTER SAVE LOCATION
   3f05                 BSAVE:	DS	1	; B REGISTER SAVE LOCATION
   3f06                 ESAVE:	DS	1	; E REGISTER SAVE LOCATION
   3f07                 DSAVE:	DS	1	; D REGISTER SAVE LOCATION
   3f08                 LSAVE:	DS	1	; L REGISTER SAVE LOCATION
   3f09                 HSAVE:	DS	1	; H REGISTER SAVE LOCATION
   3f0a                 SSAVE:	DS	2	; STACK POINTER SAVE LOCATION
   3f0c                 PSAVE:	DS	2	; PROGRAM COUNTER SAVE LOCATION
   3f0e                 EXOP:	DS	1	; TEMPORARY OP CODES FOR SINGLE STEP
   3f0f                 EXOP1:	DS	1
   3f10                 EXOP2:	DS	1
   3f11                 EXOP3:	DS	1
   3f12                 EXOP4:	DS	2
                        ;
                        ; STACK RESIDES HERE
                        ; AND GOES DOWN IN MEMORY
                        ;
   3fa0                 	ORG	3FA0H	; STACK START + 1
   3fa0                 STACK:	EQU	$	
                        ;
                        ; TEMPORARY VARIABLES FOR PATB SUBROUTINES
                        ;
                        ; EDITOR VARIABLES
                        ;
   3fa0   00 00         VARTMP:	DW	0	; TEMPORARY VARIABLE
   3fa2   00 00         MOVCNT:	DW	0	; MOVE COUNT
   3fa4   00 00         LINEND:	DW	0	; LINE END
   3fa6   00 00         CURLIN: DW	0	; CURRENT LINE BEING EDITED
                        ;
                        ; XMODEM VARIABLES
                        ;
   3fa8   00 00         TIMOUT:	DW	0	; TIME OUT VALUE
   3faa   00 00         PKTADD:	DW	0	; PACKET ADDRESS
   3fac   00 00         ENDADD:	DW	0	; END ADDRESS (SEND)
   3fae   00            RETRY:	DB	0	; RETRY COUNT
   3faf   00            TIMCNT:	DB	0	; TIME OUT COUNT
                        ;
                        ; ARRAY VARIABLE
                        ;
   3fb0   00 00         VADDR:	DW	0	; VARIABLE ADDRESS
                        ;
                        ; RANDOMIZE VARIABLE
                        ;
   3fb2   00 00         RANDOM:	DW	0	; COUNTER UPDATED BY SERIAL POLL
                        ;
   3fb4                 	END
Altaids ROM VER 5

2000  ABORTF        06e7  ABS           0006  ACK           0f82  AGN       
00fe  AHOW          1093  ALTAIR        002e  APROMPT       2016  ARRUNF    
3f03  ASAVE         0744  ASC1          0879  ASORRY        084c  AWHAT     
0008  BACKUP        11a0  BADLD         0d2d  BADRCV        0185  BASIC     
0007  BELL          16af  BITS          0080  BLKSIZ        003e  BPROMPT   
1311  BRSB          12f7  BRTYP         3f05  BSAVE         3e88  BUFEND    
3e38  BUFFER        0050  BUFSIZ        1338  CALSC         130a  CALTY     
0018  CAN           0163  CDN           016f  CEEOL         0173  CELN      
07eb  CHCNT         0811  CHGSGN        0b30  CHKC          0b1f  CHKDEL    
0b76  CHKEOL        16e3  CHKHEX        0dd8  CHKIO         080e  CHKSGN    
015b  CHOME         1964  CHTBL         0de4  CI0           1009  CIN       
0823  CK1           0de8  CKABRT        081d  CKHLDE        016b  CLEFT     
07ba  CLR1          07b7  CLRARY        038b  CLS           0157  CLSCR     
1954  CLTBL         105f  CMDTBL        1024  COLD          1a17  CONDF     
0f25  CONT          16f9  CONVHX        1006  COUT          0180  CQERY     
000d  CR            0167  CRIGHT        000e  CRLF          0178  CSAV      
3f04  CSAVE         0154  CSI           0003  CTRC          0004  CTRD      
0008  CTRH          000f  CTRO          0018  CTRX          015f  CUP       
3fa6  CURLIN        2002  CURRNT        017c  CUSAV         0f62  DATA      
0594  DEFLT         007f  DEL           0c38  DELCH         0c33  DELCL     
0c00  DELET1        0c19  DELET2        0be2  DELETE        0792  DIM       
07d0  DIMERR        0317  DIRECT        137f  DISASM        199c  DISINS    
07f1  DIVIDE        0f47  DMP           11ce  DREGS         3f07  DSAVE     
122c  DSPLY         101e  DSPREG        109f  DUMP          10aa  DUMP1     
10b3  DUMP2         10bc  DUMP3         10ce  DUMP4         10d2  DUMP5     
10dc  DUMP6         10e9  DUMP7         10f2  DUMP8         10fd  DUMP9     
10ff  DUMPA         110c  DUMPB         07fc  DV1           07fe  DV2       
0b19  EATCH         0b68  ECHO          0b6e  EDERR         0430  EDIT      
0a10  EDITOR        0b0b  EDITX         0a8d  EDLOOP        3fac  ENDADD    
0847  ENDCHK        11ad  ENDLD         1114  ENTER         1117  ENTLP     
0004  EOT           005d  EPROMPT       0f3f  ERR           1057  ERROR     
084f  ERRORB        3f06  ESAVE         001b  ESC           031a  EX0       
031c  EX1           032f  EX2           0339  EX3           033b  EX4       
0340  EX5           136e  EXBYT         12cf  EXCYC         031a  EXEC      
3f0e  EXOP          3f0f  EXOP1         3f10  EXOP2         3f11  EXOP3     
3f12  EXOP4         05a4  EXPR1         05e8  EXPR2         061c  EXPR3     
068d  EXPR4         083f  FI1           0846  FI2           0c55  FILLP     
0838  FIN           1229  FINI          0910  FL1           0925  FL2       
131b  FLRS          0908  FNDLN         0910  FNDLNP        0924  FNDNXT    
0926  FNDSKP        047b  FOR           048b  FR1           0495  FR2       
0499  FR3           049c  FR4           049f  FR5           04b4  FR7       
04d5  FR8           0700  FREE          3f02  FSAVE         137a  FSTCN     
0045  FULLBIT       16cf  GETB          1015  GETBY         166c  GETCHE    
0c5b  GETCHR        16e0  GETHEX        087f  GETLN         0c6c  GETRSP    
070d  GETST         16c6  GETW          1012  GETWD         0880  GL0       
0883  GL1           089c  GL2           089f  GL3           08ae  GL4       
08cc  GL5           08e5  GL6           08fe  GL7           1143  GO        
0442  GOSUB         037c  GOTO          0060  GPI           0061  GPO       
0026  HALFBIT       114a  HELP          12e9  HLJMP         1834  HLPMSG    
0104  HOW           3f09  HSAVE         1b95  ICALL         1b9a  IDAD      
1b9f  IDCR          1ba4  IDCX          0008  IEFLG         1aff  IERR      
052b  IFF           1ba9  IHLT          1b2f  IIN           1bae  IINR      
1bb3  IINX          1b17  IJMP          1bb8  ILXI          1bbd  IMOV      
1bc2  IMVI          0fbd  INCH          0751  INCMD         0d5d  INDAT     
12e4  INJMP         1bc7  INOP          1617  INP1          1626  INP1A     
1628  INP2          162d  INP3          162f  INP4          1642  INP5      
053a  INPERR        0d51  INPKT         1153  INPRT         0544  INPUT     
1613  INPUTT        0bd4  INSBUF        0ba3  INSER1        0bb8  INSER2    
0bd3  INSER3        0bdb  INSERR        0b7b  INSERT        0044  INT2      
0049  INT3          004b  INT4          005e  INT5          003c  INT75     
006b  INTX          078f  IOMERR        1a37  IOP02         1a77  IOP07     
1ab7  IOP2X         1af7  IOP31         1b17  IOP33         1b55  IOP36     
1b27  IOUT          0544  IP1           0552  IP2           0562  IP3       
057b  IP3A          058c  IP4           0593  IP5           1bcc  IPOP      
115f  IPORT         1bd1  IPUSH         1bd6  IRIM          1bdb  IRST      
1be0  ISIM          1301  JMPSC         0c2a  LEFT          059a  LET       
000a  LF            3fa4  LINEND        03ce  LIST          1162  LOAD      
1165  LOAD1         1189  LOADLP        200c  LOPINC        200e  LOPLMT    
2010  LOPLN         2012  LOPPT         200a  LOPVAR        03de  LS1       
3f08  LSAVE         1be5  LSTROM        05a3  LT1           1033  MAIN      
1363  MAKCN         000a  MAXTIM        0003  MAXTRY        09c4  MD1       
0f21  MEM           3fa2  MOVCNT        07d3  MPY           0118  MSG1      
3f00  MSTC2         3f02  MSTCK         07e5  MULT          07de  MULTPY    
09bc  MVDOWN        09b3  MVUP          0015  NAK           0348  NEW       
167c  NEWLN         0ce0  NEWPKT        04da  NEXT          0fab  NEXT1     
0fa7  NEXT3         11a2  NEXTLD        12a9  NMB           04e1  NX0       
0511  NX1           0523  NX2           04f9  NX3           16b7  NXTBIT    
0f5b  NXTLIN        0dc4  OC2           0dc9  OC3           2001  OCSW      
0f7d  OCTL3         0f7c  OCTL6         0109  OK            60f8  ONESEC    
1935  OOTBL         11c5  OPORT         1654  OUT1          165a  OUT2      
0fc2  OUTCHK        0747  OUTCMD        0ccb  OUTDAT        0cb7  OUTPKT    
11bc  OUTPRT        164d  OUTT          06a2  PARN          077c  PASPRM    
15fa  PBYTE         12ee  PCH           15d5  PCOND         0766  PEEK      
160c  PEXIT         1018  PIN           160d  PINV          3faa  PKTADD    
0974  PN1           0975  PN2           0985  PN3           0986  PN4       
0992  PN5           0995  PN6           15ea  PNAME         15dc  POFF      
075c  POKE          09cb  POPA          101b  POUT          09e5  PP1       
15c8  PPAIR         0401  PR0           0409  PR1           03f8  PR2       
041a  PR3           0414  PR4           0423  PR6           0427  PR8       
03ed  PRINT         0fa4  PRINT3        0f9e  PRINT6        002a  PROMPT    
100f  PRTBY         09a0  PRTLN         0964  PRTNUM        0931  PRTSTG    
0930  PRTSTZ        100c  PRTWD         0932  PS1           3f0c  PSAVE     
0a0d  PU1           09e7  PUSHA         1696  PUTB          1699  PUTBYT    
16a6  PUTHEX        168e  PUTHL         0704  PUTST         1021  PUTSTR    
168b  PUTW          1602  PWORD         00fd  QHOW          0878  QSORRY    
0942  QT1           094b  QT2           094f  QT3           0957  QT4       
0963  QT5           093d  QTSTG         084b  QWHAT         06dc  RA1       
3fb2  RANDOM        0d47  RECVX         1974  REGLST        19ef  REGNAM    
19f7  REGPR         11c8  REGS          0527  REM           3fae  RETRY     
1327  RETSC         0462  RETURN        1318  RETYP         0c21  RIGHT     
1375  RLC10         0010  RLEN          06ad  RND           0395  RNDMZ     
03a4  RNDMZ1        0000  ROMST         1211  RSTA          019e  RSTART    
132f  RSTTY         0357  RUN           0363  RUNNXL        0373  RUNSML    
036c  RUNTSL        1343  SAVPS         073b  SCHAR         2014  SEED      
1672  SENDM         0c69  SENDP         0ca2  SENDX         0ca7  SENDX1    
0825  SETVAL        1701  SIGNON        06f3  SIZE          06f8  SIZEA     
113f  SKIP          0001  SOH           0112  SORRY         1686  SPACE     
0fb8  SPC           0028  SS1           008b  SS1A          3f0a  SSAVE     
1277  SSTEP         126c  SSWAIT        01b4  ST1           01c4  ST2       
01cd  ST3           0202  ST4           0213  ST4A          3fa0  STACK     
1000  START         2004  STKGOS        2008  STKINP        3e92  STKLMT    
1a07  STKPR         0351  STOP          01d3  STORLN        0807  SUBDE     
0835  SV1           12dc  SYSOP         1944  SYTBL         0009  TAB       
0229  TAB1          0252  TAB2          02c7  TAB4          02f2  TAB5      
02f8  TAB6          0300  TAB8          1099  TBASIC        12b6  TBC1      
12c4  TBC2          12b5  TBCHK         12c8  TBNOT         00c6  TC1       
00d1  TC2           1350  TCNT          3faf  TIMCNT        3fa8  TIMOUT    
00da  TN1           1202  TRACE         0ad4  TST1          0ae4  TST4      
0aa8  TSTB          0b43  TSTBK         0b60  TSTBK1        0ab0  TSTC      
0ac2  TSTD          0af4  TSTF1         00d5  TSTNUM        0073  TSTV0     
0077  TSTV1         0f00  TURMON        0093  TV1           00ab  TV2       
201a  TXTBGN        3e00  TXTEND        2018  TXTUNF        14f1  TYP01     
14fd  TYP02         1522  TYP0A1        154e  TYP0B1        1567  TYP0C1    
156a  TYP0C2        1588  TYP0E1        13bb  TYP3A1        13fe  TYP3C1    
140d  TYP3C2        141c  TYP3C3        145a  TYP3E1        14de  TYPE0     
1508  TYPE0A        1537  TYPE0B        1557  TYPE0C        1577  TYPE0D    
1581  TYPE0E        159a  TYPE0F        15bb  TYPE0G        14b1  TYPE1     
14d7  TYPE1A        149c  TYPE2         138f  TYPE3         13a1  TYPE3A    
13c9  TYPE3B        13de  TYPE3C        142b  TYPE3D        1440  TYPE3E    
146f  TYPE3F        1485  TYPE3G        0d78  UPDEX         0d6e  UPDTXT    
076d  USR           078c  USRET         3fb0  VADDR         3e00  VARBGN    
2006  VARNXT        3fa0  VARTMP        3530  VERS          0d7d  WAITCH    
0d87  WAITLP        1030  WARM          010c  WHAT          1003  WSTART    
0d41  XERROR        0d9b  XINP          0d9f  XINP1         0da6  XINP2     
0dab  XINP3         0dad  XINP4         0dc0  XINP5         0145  XLMSG     
03a9  XLOAD         05aa  XP11          05b0  XP12          05b6  XP13      
05bd  XP14          05c5  XP15          05cb  XP16          05d1  XP17      
05d3  XP18          05f1  XP21          05f4  XP22          05f7  XP23      
05fe  XP24          060f  XP25          0612  XP26          061f  XP31      
063b  XP32          0644  XP34          0664  XP34A         067f  XP35      
0693  XP40          069c  XP41          06a9  XP42          06aa  XP43      
0ceb  XRCV2         0cf0  XRCV3         0d04  XRCV4         0cdb  XRECV     
03b9  XSAVE         0c43  XSEND         0138  XSMSG         0d23  XTMOUT    
