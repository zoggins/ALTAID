; Altaids ROM
; (c) 2016-2018	David R. Hunter
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, version 3 of the License.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of 
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; alog with this program.  If not, see <https://www.gnu.org/licenses/>.
;
;
; Included are three programs in the 8K EPROM of the Altaids Computer:
;	1. TINY BASIC with a single line editor (ANSI Terminal) and XMODEM SAVE/LOAD
;	2. Altair Turnkey Monitor (to recreate the "feel" of an Altair and terminal)
;	3. 8085 Monitor with Intel Hex file load and single step trace capability
;
; This program source has a mix of "styles" because it is a 
; combination of programs from different sources (see ACKNOWLEDGMENTS).
; To be true to the authors of those programs, I tried to keep the style 
; of the originals
;  Dave Hunter
;
;
; ACKNOWLEDGEMENTS:
;
; Developed with A85: 8085 Cross-Assembler Ver 0.1 by William C. Colley, III
;   incorporating fixes for LCC/Windows by HRJ Dec 2013
;
; command line: A85 altaidsRom.asm -l altaids.lst -o altaids.hex
;
; The BASIC is adapted Palo Alto Tiny BASIC (PATB) by LiChen Wang DDJ June 1976
; using features of the Sherry Brothers version
;
; GET$ AND PUT$ are adapted from DDJ Feb 1977, 
; EXTENSIONS TO WANG'S PALO ALTO TINY BASIC by Russ Hayden
;
; RND is the 16-bit Random Number Generator from the web site:
; www.map.grauw.nl/sources/external/z80bits.html#4.2
; by Milos "Baze" Bazelides
; and converted from Z-80 to 8080
;
; The ^C interrupt, editor, XMODEM routines and other enhancements to PATB
; are by David Hunter 2016-2018
;
; The Altair monitor is adapted from TURMON by MITS (C)1977
;
; The 8085 monitor is by David Hunter March 2018
;
; The single step was adapted and modified from:
; SINGLE STEPPING THE 8080 PROCESSOR
; By Charles Sharp BYTE Magazine January 1979
;
; The 8085 disassembler is by David Hunter 2017
;
; The serial port routines are adapted from:
; The MCS-80/85 Family User's Manual by Intel 1986 
;
;
; The Altaids computer features:
; 8K of E(E)PROM and 8K of RAM equivalent to a 16K Altair  
; The serial port uses the SID/SOD pins of the 8085 as a software UART
; There is one 8 bit I/O port which can be used for either input or output
;
; This is similar to the following configuration:
;	Altair 8800b Turnkey Model w/ CPU board	
; 	one 88-PMC8 8K ROM card
;	two 88-4MCS 4K SRAM cards
;	one 88-SIO serial I/O board
;	one 88-PIO parallel I/O board
;
; Giving you a turnkey Altair with power supply and 6 cards in a mint tin!
;
; Hardware Memory Map:
;	0000H - 0EFFH	EPROM: TINY BASIC
;	0F00H - 0FFFH	EPROM: ALTAIR TURNKEY MONITOR
;	1000H - 1BFFH	EPROM: 8085 MONITOR
;	1C00H - 1FFFH	EPROM: unused
;	2000H - 3FFFH	SRAM
;	4000H - 5FFFH	unavailable
;	6000H - 7FFFH	RESERVED (decoded with I/O)
;	8000H - FFFFH	OPEN
;
;
; I/O Map:
;	00H - 5FH	unavailable
;	60H - 7FH	external I/O port
;	80H - FFH	unavailable
;
; Input Port:	60H
; Output Port:	61H
;
; Serial interface: 2400 baud, 8N1, Flow control: None
;
; Because of processing of the serial data, sending text files from TeraTerm
; requires delays for character and lines.  I found the following settings
; very reliable:
; Transmit delay =
;	50 msec/char
;	200 msec/line
;
;
	TITLE	"Altaids ROM VER 5"
;
;	06/14/16	D. Hunter - started project
;	05/07/17	D. Hunter - editor and disassembler complete
;	07/04/17	D. Hunter - added XMODEM Load/Save to Tiny BASIC
;	03/15/18	D. Hunter - added Altair TURMON (modified)
;				  - replaced monitor with my own version
;	04/22/18	D. Hunter - added 1D arrays to Tiny BASIC
;				  - added RANDOMIZE keyword to change random seed
;
;
;
VERS	EQU	'50'	; Version number (2 bytes)
;			  BYTES REVERSED FOR DISPLAY ORDER
;			  e.g. 20 == '0',' 2'
BUFSIZ	EQU	80	; BUFFER SIZE
;
;*******************************************
; CONSTANTS
;
; CONSTANTS FOR 2400 BAUD SERIAL I/O
; USING A 4.9152MHZ CRYSTAL GIVES A 2.4576MHZ CLOCK
; SEE THE INTEL MCS-80/85 FAMILY USER'S MANUAL PG A1-28
; FOR DETAILS.  
HALFBIT	EQU	38	
FULLBIT	EQU	69	; true bit rate = 2388 bps
;
; HARDWARE GPIO PORTS
GPI	EQU	60H	; INPUT PORT
GPO	EQU	61H	; OUTPUT PORT
;
; ASCII CONSTANTS
PROMPT	EQU	'*'	; MONITOR PROMPT CHARACTER
APROMPT	EQU	'.'	; ALTAIR MONITOR PROMPT
BPROMPT	EQU	'>'	; BASIC PROMPT 
EPROMPT	EQU	']'	; EDITOR PROMPT
CTRC	EQU	3	; ^C
CTRD	EQU	4	; ^D
BELL	EQU	7	; ^G BELL
CTRH	EQU	8	; ^H BACKSPACE
TAB	EQU	9	; ^I
CTRO	EQU	15	; ^O TOGGLE OUTPUT
CTRX	EQU	24	; ^X, ABORT
BACKUP	EQU	CTRH	; BACKUP CHAR
DEL	EQU	127	; RUBOUT
ESC	EQU	27	; ESCAPE
CR	EQU	13	; CARRIAGE RET
LF	EQU	10	; LINE FEED
;
RLEN	EQU	16	; RECORD LENGTH FOR HEX DUMP
;
;
; INTERRUPT ENABLE BIT FROM RIM INSTRUCTION
IEFLG	EQU	08H	; SET IF INTERRUPTS ARE ENABLED
;
; XMODEM CONSTANTS
ACK	EQU	06H		; ACKNOWLEDGE
NAK	EQU	15H		; NO ACKNOWLEDGE
SOH	EQU	01H		; START OF DATA
EOT	EQU	04H		; END OF DATA
CAN	EQU	18H		; CAN CHARACTER (^X)
BLKSIZ	EQU	128		; NUMBER OF BYTES PER BLOCK
ONESEC	EQU	24824		; ONE SECOND TIME OUT FOR 2.4576MHZ CLOCK
MAXTRY	EQU	3		; MAXIMUM RETRY COUNT
MAXTIM	EQU	10		; MAXIMUM TIMEOUT COUNT (SECONDS)
;
;*******************************************
; RESTART (RST) AREA
	ORG	0	; RST 0
ROMST:	DI		; START OF ROM, DISABLE INTERRUPTS
	JMP	START	; GO TO THE MONITOR FIRST
	DB	'WANG'
;	
	ORG	08H
	XTHL		;*** TSTC OR RST 1 *** 
	RST	5	;IGNORE BLANKS AND 
	CMP	M	;TEST CHARACTER
	JMP	TC1	;REST OF THIS IS AT TC1
;
CRLF:	MVI	A,CR 	;*** CRLF ***
;	
	ORG	10H
	PUSH	PSW	;*** OUTC OR RST 2 *** 
	LDA	OCSW	;PRINT CHARACTER ONLY
	ORA	A	;IF OCSW SWITCH IS ON
	JMP	OC2	;REST OF THIS IS AT OC2
;	
	ORG	18H
	CALL	EXPR2	;*** EXPR OR RST 3 *** 
	PUSH	H	;EVALUATE AN EXPRESION 
	JMP	EXPR1	;REST OF IT IS AT EXPR1
	DB	'E' 
;	
	ORG	20H
	MOV	A,H	;*** COMP OR RST 4 *** 
	CMP	D	;COMPARE HL WITH DE
	RNZ		;RETURN CORRECT CY AND
	MOV	A,L	;Z FLAGS 
	CMP	E	;BUT OLD A IS LOST 
	RET
	DB	'T '
;	
	ORG	28H
SS1:	LDAX	D	;*** IGNBLK/RST 5 ***
	CPI	' '	;IGNORE BLANKS 
	RNZ		;IN TEXT (WHERE DE->)
	INX	D	;AND RETURN THE FIRST
	JMP	SS1	;NON-BLANK CHAR. IN A
;	
	ORG	30H
	POP	PSW	;*** FINISH/RST 6 ***
	CALL	FIN	;CHECK END OF COMMAND
	JMP	QWHAT	;PRINT "WHAT?" IF WRONG
	DB	'A' 
;	
	ORG	38H	;*** TSTV OR RST 7 *** 
	JMP	TSTV0	;JUMP AROUND INTERRUPT
	DB	'L'
;	
;*******************************************
; SERIAL INTERRUPT
; THIS ROUTINE LOOKS FOR A ^C CHARACTER AND
; SETS THE ABORT FLAG IF ONE OCCURS
;
; ^C = 03H	= 00000011B
; SERIAL DATA IS LSB FIRST, SO THE SEQUENCE
; OF BITS ON THE INTERRUPT PIN IS:
;  0:11000000:1
;  S          P
;  S = START, P = STOP
;  THE TRANSISTION FROM START BIT TO BIT 0 
;  CAUSES THE INTERRUPT.   BY LOOKING FOR THE
;  CORRECT BIT SEQUENCE, A ^C CAN BE DETECTED
;  THE INTERRUPT IS SIMILAR TO THE
;  SERIAL INPUT ROUTINE IN THE MONITOR
; 
;
	ORG	3CH	; RST 7.5 - SERIAL INTERRUPT
INT75:	PUSH	PSW
	PUSH	B
	PUSH	H	; SAVE REGISTERS
	LXI	B,0880H	; B = 7BITS + STOP, C = FIRST BIT
;
; AT THIS POINT, WE ARE AT THE START OF THE FIRST DATA BIT
;
	MVI	L,HALFBIT 
INT2:	DCR	L	; WAIT UNTIL THE MIDDLE OF THE FIRST BIT
	JNZ	INT2
	NOP
;
INT3:	MVI	L,FULLBIT ; WAIT ONE BIT TIME
INT4:	DCR	L
	JNZ	INT4
	NOP
	NOP
	RIM		; GET DATA BIT
	RAL
	DCR	B
	JZ	INT5
	MOV	A,C
	RAR
	MOV	C,A
	NOP		; NEEDED TO HAVE EQUAL # CLOCKS WITH COUT
	JMP	INT3
;
INT5:	MOV	A,C	; GET BYTE INTO ACC
	XRI	CTRC	; CHECK IF ^C
	JNZ	INTX	; EXIT IF IT IS NOT
	CMA		; SET ACC TO 0FFH
	STA	ABORTF	; SET ABORT FLAG
	STA	OCSW	; TURN OFF OUTPUT SO IT DOESN'T PRINT GARBAGE
INTX:	POP	H
	POP	B
	MVI	A,10H	; CLEAR THE RST7.5 FLIP FLOP
	SIM		; THAT WAS SET BY THE STOP BIT
	POP	PSW
	EI
	RET
;
; END - SERIAL INTERRUPT
;*******************************************
;
;
TSTV0:	RST	5
	SUI	'@'	;TEST VARIABLES
	RC		;CY:NOT A VARIABLE
TSTV1:	JNZ	TV1	;NOT "@" ARRAY 
	INX	D	;IT IS THE "@" ARRAY 
	CALL	PARN	;@ SHOULD BE FOLLOWED
	DAD	H	;BY (EXPR) AS ITS INDEX
	JC	QHOW	;IS INDEX TOO BIG? 
	PUSH	D	;WILL IT OVERWRITE 
	XCHG		;TEXT? 
	CALL	SIZE	;FIND SIZE OF FREE 
	RST	4	;AND CHECK THAT
	JC	ASORRY	;IF SO, SAY "SORRY"
SS1A:	LXI	H,VARBGN  ;IF NOT, GET ADDRESS 
	CALL	SUBDE	;OF @(EXPR) AND PUT IT 
	POP	D	;IN HL 
	RET		;C FLAG IS CLEARED
;	
TV1:	CPI	33Q	;NOT @, IS IT A TO Z?
	CMC		;IF NOT RETURN C FLAG
	RC 
	INX	D	;IF A THROUGH Z
	LXI	H,VARBGN  ;COMPUTE ADDRESS OF
	RLC		;THAT VARIABLE 
	ADD	L	;AND RETURN IT IN HL 
	MOV	L,A	;WITH C FLAG CLEARED 
	MVI	A,0 
	ADC	H 
	MOV	H,A
	LDAX	D	;LOOK AT NEXT CHARACTER
	CPI	'('	;ARRAY REFERENCE?
	JZ	TV2	;YES, HANDLE REFERENCE
	STC	
	CMC		;NO, CLEAR CARRY
	RET		;EXIT
;* ARRAY REFERENCE
TV2:	PUSH	B	;SAVE BC
	PUSH	H	;SAVE VARIABLE ADDRESS ON STACK
	CALL	PARN	;GET ARRAY OFFSET
	MOV	A,L
	ORA	H
	JZ	QHOW	;ERROR IF OFFSET IS 0
	DCX	H	;CONVERT FROM 1 TO N OFFSET TO 0 TO N-1 OFFSET
	DAD	H	;CONVERT TO BYTE OFFSET
	JC	QHOW	;INDEX IS WAY TOO BIG
	MOV	C,L
	MOV	B,H	;BC = OFFSET
	POP	H	;GET VARIABLE ADDRESS BACK
	PUSH	D	;SAVE TEXT POINTER
	MOV	E,M	;READ ARRAY ADDRESS
	INX	H
	MOV	D,M	;DE = ARRAY START
	XCHG		;POINT TO ARRAY
	DAD	B	;ARRAY LOCATION IN HL, CARRY CLEAR
	POP	D
	POP	B
	RET
;* 
;*	TSTC	XCH  HL,(SP)   ;*** TSTC OR RST 1 *** 
;*	IGNBLK		THIS IS AT LOC. 8 
;*	CMP	M	AND THEN JMP HERE 
TC1:	INX	H	;COMPARE THE BYTE THAT 
	JZ	TC2	;FOLLOWS THE RST INST. 
	PUSH	B	;WITH THE TEXT (DE->)
	MOV	C,M	;IF NOT =, ADD THE 2ND 
	MVI	B,0	;BYTE THAT FOLLOWS THE 
	DAD	B	;RST TO THE OLD PC 
	POP	B	;I.E., DO A RELATIVE 
	DCX	D	;JUMP IF NOT = 
TC2:	INX	D	;IF =, SKIP THOSE BYTES
	INX	H	;AND CONTINUE
	XTHL 
	RET
;* 
TSTNUM:	LXI	H,0	;*** TSTNUM ***
	MOV	B,H	;TEST IF THE TEXT IS 
	RST	5	;A NUMBER
TN1:	CPI	'0'	;IF NOT, RETURN 0 IN 
	RC		;B AND HL
	CPI	72Q	;IF NUMBERS, CONVERT 
	RNC		;TO BINARY IN HL AND 
	MVI	A,360Q	;SET A TO # OF DIGITS
	ANA	H	;IF H>255, THERE IS NO 
	JNZ	QHOW	;ROOM FOR NEXT DIGIT 
	INR	B	;B COUNTS # OF DIGITS
	PUSH	B 
	MOV	B,H	;HL=10;*HL+(NEW DIGIT)
	MOV	C,L 
	DAD	H	;WHERE 10;* IS DONE BY
	DAD	H	;SHIFT AND ADD 
	DAD	B 
	DAD	H 
	LDAX	D	;AND (DIGIT) IS FROM 
	INX	D	;STRIPPING THE ASCII 
	ANI	17Q	;CODE
	ADD	L 
	MOV	L,A 
	MVI	A,0 
	ADC	H 
	MOV	H,A 
	POP	B 
	LDAX	D	;DO THIS DIGIT AFTER 
	JP	TN1	;DIGIT. S SAYS OVERFLOW
;
; ERROR MESSAGES
QHOW:	PUSH	D	;*** ERROR: "HOW?" *** 
AHOW:	LXI	D,HOW 
	JMP	ERRORB
HOW:	DB	'HOW?',CR 
OK:	DB	'OK',CR 
WHAT:	DB	'WHAT?',CR
SORRY:	DB	'SORRY',CR
;
; TINY BASIC SIGN ON MESSAGE
MSG1:	DB	'PALO ALTAIDS TINY BASIC VER 1.0',CR
;
XSMSG:	DB	'SENDING FILE',CR
XLMSG:	DB	'READY FOR FILE',CR
;
; ANSI TERMINAL COMMANDS
;
CSI:	DB	ESC	; CONTROL SEQUENCE INITIATOR
	DB	'[',0
;
CLSCR:	DB	ESC	; CLEAR SCREEN
	DB	'[2J'	; CONTINUE WITH HOME
CHOME:	DB	ESC
	DB	'[H',0	; CURSOR HOME TO UPPER LEFT
CUP:	DB	ESC	; CURSOR COMMANDS
	DB	'[A',0
CDN:	DB	ESC
	DB	'[B',0
CRIGHT:	DB	ESC
	DB	'[C',0
CLEFT:	DB	ESC
	DB	'[D',0
CEEOL:	DB	ESC	; ERASE TO END OF LINE
	DB	'[K',0
CELN:	DB	ESC	; ERASE LINE
	DB	'[2K',0
CSAV:	DB	ESC	; SAVE CURSOR
	DB	'[s',0
CUSAV:	DB	ESC	; UNSAVE CURSOR
	DB	'[u',0
CQERY:	DB	ESC	; QUERY CURSOR
	DB	'[6n',0	
;
;* 
;**************************************************************
;* 
;* *** MAIN ***
;* 
;* THIS IS THE MAIN LOOP THAT COLLECTS THE TINY BASIC PROGRAM
;* AND STORES IT IN THE MEMORY.
;* 
;* AT START, IT PRINTS OUT "(CR)OK(CR)", AND INITIALIZES THE 
;* STACK AND SOME OTHER INTERNAL VARIABLES.  THEN IT PROMPTS 
;* ">" AND READS A LINE.  IF THE LINE STARTS WITH A NON-ZERO 
;* NUMBER, THIS NUMBER IS THE LINE NUMBER.  THE LINE NUMBER
;* (IN 16 BIT BINARY) AND THE REST OF THE LINE (INCLUDING CR)
;* IS STORED IN THE MEMORY.  IF A LINE WITH THE SAME LINE
;* NUMBER IS ALREDY THERE, IT IS REPLACED BY THE NEW ONE.  IF
;* THE REST OF THE LINE CONSISTS OF A CR ONLY, IT IS NOT STORED
;* AND ANY EXISTING LINE WITH THE SAME LINE NUMBER IS DELETED. 
;* 
;* AFTER A LINE IS INSERTED, REPLACED, OR DELETED, THE PROGRAM 
;* LOOPS BACK AND ASKS FOR ANOTHER LINE.  THIS LOOP WILL BE 
;* TERMINATED WHEN IT READS A LINE WITH ZERO OR NO LINE
;* NUMBER; AND CONTROL IS TRANSFERED TO "DIRECT".
;* 
;* TINY BASIC PROGRAM SAVE AREA STARTS AT THE MEMORY LOCATION
;* LABELED "TXTBGN" AND ENDED AT "ARRUNF".  WE ALWAYS FILL THIS
;* AREA STARTING AT "TXTBGN", THE UNFILLED PORTION IS POINTED
;* BY THE CONTENT OF A MEMORY LOCATION LABELED "TXTUNF". 
;*
;* ARRUNF POINTS TO UNFILLED ARRAY SPACE WHICH STARTS AT TXTEND-1
;* AND MOVES DOWN IN MEMORY.  THEREFORE, ARRAY SPACE REDUCES
;* PROGRAM SPACE.
;* 
;* THE MEMORY LOCATION "CURRNT" POINTS TO THE LINE NUMBER
;* THAT IS CURRENTLY BEING INTERPRETED.  WHILE WE ARE IN 
;* THIS LOOP OR WHILE WE ARE INTERPRETING A DIRECT COMMAND 
;* (SEE NEXT SECTION), "CURRNT" SHOULD POINT TO A 0. 
;* 
; INITIALIZE THE VARIABLES
;
BASIC:	LXI	SP,STACK ;COLD START OF BASIC
	MVI	A,0BH	;ENABLE INTERRUPT 7.5, DISABLE OTHERS
	SIM
	LXI	D,MSG1	;GET SIGNON MESSAGE
	SUB	A	;CLEAR A
	CALL	PRTSTG	;SEND MSG
; INITIALIZE VARIABLES
	LXI	H,BASIC
	SHLD	SEED	;INITIALIZE RANDOM SEED
	LXI	H,TXTBGN
	SHLD	TXTUNF	;INITIALIZE UNFILLED TEXT POINTER
;*	
RSTART:	DI		; WARM START
	LXI	H,TXTEND-1
	SHLD	ARRUNF	;INITIALIZE UNFILLED ARRAY POINTER
;*
	LXI	SP,STACK ;RESET THE STACK ON A RESTART	
	SUB	A
	STA	ABORTF	;CLEAR THE ABORT FLAG
	MVI	A,0FFH
	STA	OCSW	;TURN ON THE OUTPUT SWITCH
	MVI	A,10H	;RESET THE INTERRUPT 7.5 FLIP FLOP
	SIM
ST1:	CALL	CRLF
	LXI	D,OK	;DE->STRING
	SUB	A	;A=0
	CALL	PRTSTG	;PRINT STRING UNTIL CR 
	LXI	H,ST2+1	;POINTER TO 0 VALUE
	SHLD	CURRNT	;CURRNT->LINE # = 0
ST2:	LXI	H,0
	SHLD	LOPVAR
	SHLD	STKGOS
ST3:	MVI	A,BPROMPT ;PROMPT AND
	CALL	GETLN	;READ A LINE
	PUSH	D	;DE->END OF LINE+1
;*
STORLN:	LXI	D,BUFFER ;DE->BEGINNING OF LINE,[SP]->END OF LINE+1
	CALL	TSTNUM	;TEST IF IT IS A NUMBER
	RST	5 	;IGNBLK
	MOV	A,H	;HL=VALUE OF THE # OR
	ORA	L	;0 IF NO # WAS FOUND 
	POP	B	;BC->END OF LINE+1
	JZ	DIRECT
	DCX	D	;BACKUP DE AND SAVE
	MOV	A,H	;VALUE OF LINE # THERE 
	STAX	D 
	DCX	D 
	MOV	A,L 
	STAX	D 
	PUSH	B	;DE->BEGIN, BC->END 
	PUSH	D 
	MOV	A,C 
	SUB	E 
	PUSH	PSW	;A=# OF BYTES IN LINE
	CALL	FNDLN	;FIND THIS LINE IN SAVE
	PUSH	D	;AREA, DE->SAVE AREA 
	JNZ	ST4	;NZ:NOT FOUND, INSERT
	PUSH	D	;Z:FOUND, DELETE IT
	CALL	FNDNXT	;FIND NEXT LINE
;*                       DE->NEXT LINE 
	POP	B	;BC->LINE TO BE DELETED
	LHLD	TXTUNF	;HL->UNFILLED SAVE AREA
	CALL	MVUP	;MOVE UP TO DELETE 
	MOV	H,B	;TXTUNF->UNFILLED AREA 
	MOV	L,C 
	SHLD	TXTUNF	;UPDATE
ST4:	POP	B	;GET READY TO INSERT 
	LHLD	TXTUNF	;BUT FIRT CHECK IF
	POP	PSW	;THE LENGTH OF NEW LINE
	PUSH	H	;IS 3 (LINE # AND CR)
	CPI	3	;THEN DO NOT INSERT
	JZ	RSTART	;MUST CLEAR THE STACK
	ADD	L	;COMPUTE NEW TXTUNF
	MOV	L,A 
	MVI	A,0 
	ADC	H 
	MOV	H,A	;HL->NEW UNFILLED AREA 
ST4A:	LXI	D,TXTEND  ;CHECK TO SEE IF THERE 
	RST	4	;IS ENOUGH SPACE 
	JNC	QSORRY	;SORRY, NO ROOM FOR IT 
	SHLD	TXTUNF	;OK, UPDATE TXTUNF 
	POP	D	;DE->OLD UNFILLED AREA 
	CALL	MVDOWN
	POP	D	;DE->BEGIN, HL->END
	POP	H 
	CALL	MVUP	;MOVE NEW LINE TO SAVE 
	JMP	ST3	;AREA
;*
;* 
;**************************************************************
;* 
;* *** TABLES *** DIRECT *** & EXEC ***
;* 
;* THIS SECTION OF THE CODE TESTS A STRING AGAINST A TABLE.
;* WHEN A MATCH IS FOUND, CONTROL IS TRANSFERED TO THE SECTION 
;* OF CODE ACCORDING TO THE TABLE. 
;* 
;* AT 'EXEC', DE SHOULD POINT TO THE STRING AND HL SHOULD POINT
;* TO THE TABLE-1.  AT 'DIRECT', DE SHOULD POINT TO THE STRING,
;* HL WILL BE SET UP TO POINT TO TAB1-1, WHICH IS THE TABLE OF 
;* ALL DIRECT AND STATEMENT COMMANDS.
;* 
;* A '.' IN THE STRING WILL TERMINATE THE TEST AND THE PARTIAL 
;* MATCH WILL BE CONSIDERED AS A MATCH.  E.G., 'P.', 'PR.',
;* 'PRI.', 'PRIN.', OR 'PRINT' WILL ALL MATCH 'PRINT'. 
;* 
;* THE TABLE CONSISTS OF ANY NUMBER OF ITEMS.  EACH ITEM 
;* IS A STRING OF CHARACTERS WITH BIT 7 SET TO 0 AND 
;* A JUMP ADDRESS STORED HI-LOW WITH BIT 7 OF THE HIGH 
;* BYTE SET TO 1.   THEREFORE, THE ADDRESS < 8000H
;* 
;* END OF TABLE IS AN ITEM WITH A JUMP ADDRESS ONLY.  IF THE 
;* STRING DOES NOT MATCH ANY OF THE OTHER ITEMS, IT WILL 
;* MATCH THIS NULL ITEM AS DEFAULT.
;* 
TAB1:	EQU	$	;DIRECT COMMANDS 
	DB	'LIST'
	DB	LIST SHR 8 + 128,LIST AND 0FFH
	DB	'RUN'
	DB	RUN SHR 8 + 128,RUN AND 255
	DB	'NEW'
	DB	NEW SHR 8 + 128,NEW AND 255
	DB	'EDIT'
	DB	EDIT SHR 8 + 128,EDIT AND 255
	DB	'XLOAD'
	DB	XLOAD SHR 8 + 128,XLOAD AND 255
	DB	'XSAVE'
	DB	XSAVE SHR 8 + 128,XSAVE AND 255
	DB	'BYE'	;GO BACK TO THE MONITOR
	DB	ROMST SHR 8 + 128,ROMST AND 255
TAB2:	EQU	$	;DIRECT/STATEMENT
	DB	'NEXT'
	DB	NEXT SHR 8 + 128,NEXT AND 255
	DB	'LET'
	DB	LET SHR 8 + 128,LET AND 255
	DB	'OUT'
	DB	OUTCMD SHR 8 + 128,OUTCMD AND 255
	DB	'GET$'
	DB	GETST SHR 8 + 128, GETST AND 255
	DB	'PUT$'
	DB	PUTST SHR 8 + 128, PUTST AND 255
	DB	'POKE'
	DB	POKE SHR 8 + 128,POKE AND 255
	DB	'IF'
	DB	IFF SHR 8 + 128,IFF AND 255
	DB	'GOTO'
	DB	GOTO SHR 8 + 128,GOTO AND 255
	DB	'GOSUB'
	DB	GOSUB SHR 8 + 128,GOSUB AND 255
	DB	'RETURN'
	DB	RETURN SHR 8 + 128,RETURN AND 255
	DB	'REM'
	DB	REM SHR 8 + 128,REM AND 255
	DB	'FOR'
	DB	FOR SHR 8 + 128,FOR AND 255
	DB	'INPUT'
	DB	INPUT SHR 8 + 128,INPUT AND 255
	DB	'PRINT'
	DB	PRINT SHR 8 + 128,PRINT AND 255
	DB	'STOP'
	DB	STOP SHR 8 + 128,STOP AND 255
	DB	'END'	; END IS THE SAME AS STOP
	DB	STOP SHR 8 + 128,STOP AND 255
	DB	'CLS'
	DB	CLS SHR 8 + 128,CLS AND 255
	DB	'DIM'
	DB	DIM SHR 8 + 128,DIM AND 255
	DB	'RANDOMIZE'
	DB	RNDMZ SHR 8 + 128,RNDMZ AND 255
;*	ADD MORE COMMANDS HERE
	DB	DEFLT SHR 8 + 128,DEFLT AND 255
TAB4:	EQU	$	;FUNCTIONS (THOSE THAT RETURN VALUES)
	DB	'RND'
	DB	RND SHR 8 + 128,RND AND 255
	DB	'INP'
	DB	INCMD SHR 8 + 128,INCMD AND 255
	DB	'PEEK'
	DB	PEEK SHR 8 + 128,PEEK AND 255
	DB	'USR'
	DB	USR SHR 8 + 128,USR AND 255
	DB	'ABS'
	DB	ABS SHR 8 + 128,ABS AND 255
	DB	'SIZE'	; AMOUNT OF FREE MEMORY
	DB	SIZE SHR 8 + 128,SIZE AND 255
	DB	'FREE'	; FIRST FREE MEMORY ADDRESS
	DB	FREE SHR 8 + 128,FREE AND 255
	DB	'"'
	DB	SCHAR SHR 8 + 128,SCHAR AND 255
;*	ADD MORE FUNCTIONS HERE
	DB	XP40 SHR 8 + 128,XP40 AND 255
TAB5:	EQU	$	;"TO" IN "FOR" 
	DB	'TO'
	DB	FR1 SHR 8 + 128,FR1 AND 255
	DB	QWHAT SHR 8 + 128,QWHAT AND 255
TAB6:	EQU	$	;"STEP" IN "FOR" 
	DB	'STEP'
	DB	FR2 SHR 8 + 128,FR2 AND 255
	DB	FR3 SHR 8 + 128,FR3 AND 255
TAB8:	EQU	$	;RELATION OPERATORS
	DB	'>='
	DB	XP11 SHR 8 + 128,XP11 AND 255
	DB	'<>'
	DB	XP12 SHR 8 + 128,XP12 AND 255
	DB	'>'
	DB	XP13 SHR 8 + 128,XP13 AND 255
	DB	'='
	DB	XP15 SHR 8 + 128,XP15 AND 255
	DB	'<='
	DB	XP14 SHR 8 + 128,XP14 AND 255
	DB	'<'
	DB	XP16 SHR 8 + 128,XP16 AND 255
	DB	XP17 SHR 8 + 128,XP17 AND 255
;* 
DIRECT:	LXI	H,TAB1-1 ;*** DIRECT ***
;* 
EXEC:	EQU	$	;*** EXEC ***
EX0:	RST	5	;IGNORE LEADING BLANKS 
	PUSH	D	;SAVE POINTER
EX1:	LDAX	D	;IF FOUND '.' IN STRING
	INX	D	;BEFORE ANY MISMATCH 
	CPI	'.'	;WE DECLARE A MATCH
	JZ	EX3 
	INX	H	;HL->TABLE 
	CMP	M	;IF MATCH, TEST NEXT 
	JZ	EX1 
	MVI	A,177Q	;ELSE, SEE IF BIT 7
	DCX	D	;OF TABLE IS SET, WHICH
	CMP	M	;IS THE JUMP ADDR. (HI)
	JC	EX5	;C:YES, MATCHED
EX2:	INX	H	;NC:NO, FIND JUMP ADDR.
	CMP	M 
	JNC	EX2 
	INX	H	;BUMP TO NEXT TAB. ITEM
	POP	D	;RESTORE STRING POINTER
	JMP	EX0	;TEST AGAINST NEXT ITEM
EX3:	MVI	A,177Q	;PARTIAL MATCH, FIND 
EX4:	INX	H	;JUMP ADDR., WHICH IS
	CMP	M	;FLAGGED BY BIT 7
	JNC	EX4 
EX5:	MOV	A,M	;LOAD HL WITH THE JUMP 
	INX	H	;ADDRESS FROM THE TABLE
	MOV	L,M 
	ANI	177Q	;MASK OFF BIT 7
	MOV	H,A 
	POP	PSW	;CLEAN UP THE GARBAGE 
	PCHL		;AND WE GO DO IT 
;* 
;**************************************************************
;* 
;* WHAT FOLLOWS IS THE CODE TO EXECUTE DIRECT AND STATEMENT
;* COMMANDS.  CONTROL IS TRANSFERED TO THESE POINTS VIA THE
;* COMMAND TABLE LOOKUP CODE OF 'DIRECT' AND 'EXEC' IN LAST
;* SECTION.  AFTER THE COMMAND IS EXECUTED, CONTROL IS 
;* TANSFERED TO OTHER SECTIONS AS FOLLOWS:
;* 
;* FOR 'LIST', 'NEW', AND 'STOP': GO BACK TO 'RSTART'
;* FOR 'RUN': GO EXECUTE THE FIRST STORED LINE IF ANY; ELSE
;* GO BACK TO 'RSTART'.
;* FOR 'GOTO' AND 'GOSUB': GO EXECUTE THE TARGET LINE. 
;* FOR 'RETURN' AND 'NEXT': GO BACK TO SAVED RETURN LINE.
;* FOR ALL OTHERS: IF 'CURRNT' -> 0, GO TO 'RSTART', ELSE
;* GO EXECUTE NEXT COMMAND.  (THIS IS DONE IN 'FINISH'.) 
;* 
;**************************************************************
;* 
;* *** NEW *** STOP *** RUN (& FRIENDS) *** & GOTO *** CLS *** 
;* *** RNDMZ *** XSAVE *** XLOAD ***
;* 
;* 'NEW(CR)' SETS 'TXTUNF' TO POINT TO 'TXTBGN'
;* 
;* 'STOP(CR)' GOES BACK TO 'RSTART'
;* 
;* 'RUN(CR)' FINDS THE FIRST STORED LINE, STORES ITS ADDRESS (IN
;* 'CURRNT'), AND STARTS TO EXECUTE IT.  NOTE THAT ONLY THOSE
;* COMMANDS IN TAB2 ARE LEGAL FOR STORED PROGRAM.
;* 
;* THERE ARE 3 MORE ENTRIES IN 'RUN':
;* 'RUNNXL' FINDS NEXT LINE, STORES ITS ADDR. AND EXECUTES IT. 
;* 'RUNTSL' STORES THE ADDRESS OF THIS LINE AND EXECUTES IT. 
;* 'RUNSML' CONTINUES THE EXECUTION ON SAME LINE.
;* 
;* 'GOTO EXPR(CR)' EVALUATES THE EXPRESSION, FIND THE TARGET 
;* LINE, AND JUMP TO 'RUNTSL' TO DO IT.
;* 
;* 'CLS(CR)' SENDS AN ANSI TERMINAL CLEAR SCREEN AND HOME COMMAND
;* TO CLEAR THE SCREEN
;*
;* 'RNDMZ(CR)' RANDOMIZES THE RANDOM NUMBER SEED USING RANDOM COUNTER
;*
;* 'XSAVE' WILL SAVE A PROGRAM ONTO ANOTHER COMPUTER USING XMODEM
;*
;* 'XLOAD' WILL LOAD A PROGRAM FROM ANOTHER COMPUTER USING XMODEM
;*
;* THE ORIGINAL XMODEM PROTOCOL WITH 128 BYTE PACKETS AND ARITHMETIC
;* CHECKSUM IS USED.  
;* SEE:
;* 	http://techheap.packetizer.com/communication/modems/xmodem.html
;* FOR MORE INFORMATION
;*
NEW:	CALL	ENDCHK	;*** NEW(CR) *** 
	LXI	H,TXTBGN
	SHLD	TXTUNF
;* 
STOP:	CALL	ENDCHK	;*** STOP(CR) ***
	JMP	RSTART
;* 
RUN:	CALL	ENDCHK	;*** RUN(CR) ***
	PUSH	PSW	;SAVE ACC
	MVI	A,10H
	SIM		;CLEAR RST7.5 FF
	EI		;ENABLE INTERRUPTS
	POP	PSW
	LXI	D,TXTBGN ;FIRST SAVED LINE
;* 
RUNNXL:	LXI	H,0	;*** RUNNXL ***
	CALL	FNDLNP	;FIND WHATEVER LINE #
	JC	RSTART	;C:PASSED TXTUNF, QUIT 
;* 
RUNTSL:	XCHG		;*** RUNTSL ***
	SHLD	CURRNT	;SET 'CURRNT'->LINE #
	XCHG 
	INX	D	;BUMP PASS LINE #
	INX	D 
;* 
RUNSML:	
	CALL	CKABRT	;*** RUNSML ***
	LXI	H,TAB2-1 ;FIND COMMAND IN TAB2
	JMP	EXEC	;AND EXECUTE IT
;* 
GOTO:	RST	3	;*** GOTO EXPR *** 
	PUSH	D	;SAVE FOR ERROR ROUTINE
	CALL	ENDCHK	;MUST FIND A CR 
	CALL	FNDLN	;FIND THE TARGET LINE
	JNZ	AHOW	;NO SUCH LINE #
	POP	PSW	;CLEAR THE "PUSH DE" 
	JMP	RUNTSL	;GO DO IT
;*
CLS:	PUSH	D	;SAVE POINTER
	XRA	A
	LXI	D,CLSCR	;GET CLEAR SCREEN SEQUENCE
	CALL	PRTSTG	;SEND IT
	POP	D	;RESTORE POINTER
	RST	6	;FINISH
;*
RNDMZ:	PUSH	D	;SAVE POINTER
	LHLD	RANDOM	;GET RANDOMIZED VALUE
	XCHG
	LHLD	SEED	;GET RANDOM SEED
	DAD	D	;ADD TOGETHER TO GET A RANDOMIZED SEED
	MOV	A,L
	ORA	H	;CHECK IF 0 (INVALID SEED)
	JNZ	RNDMZ1
	DCX	H	;YES, HAPPENS TO BE 0, CHANGE TO FFFF
RNDMZ1:	SHLD	SEED
	POP	D
	RST	6
;*
XLOAD:	LXI	D,XLMSG	;INDICATE READY FOR FILE
	SUB	A
	CALL	PRTSTG	;SEND IT
	LXI	H,TXTBGN ;POINT TO THE START OF THE PROGRAM
	CALL	XRECV	;GET THE FILE
	JMP	RSTART	;AND RETURN
;*
XSAVE:	LXI	D,XSMSG	;INDICATE FILE IS BEING SENT
	SUB	A
	CALL	PRTSTG	;SEND IT
	LHLD	TXTUNF	;GET THE FREE POINTER
	DCX	H	;POINT TO LAST BYTE IN PROGRAM
	XCHG		;PUT IN D,E
	LXI	H,TXTBGN ;POINT  TO THE START OF THE PROGRAM
	CALL	XSEND	;SEND THE FILE
	JMP	RSTART	;AND RETURN
;* 
;************************************************************* 
;* 
;* *** LIST *** PRINT *** EDIT ***
;* 
;* LIST HAS TWO FORMS: 
;* 'LIST(CR)' LISTS ALL SAVED LINES
;* 'LIST #(CR)' START LIST AT THIS LINE #
;* YOU CAN STOP THE LISTING WITH CONTROL-C
;* 
;* PRINT COMMAND IS 'PRINT ....:' OR 'PRINT ....(CR)'
;* WHERE '....' IS A LIST OF EXPRESIONS, FORMATS, UNDERSCORES
;* AND STRINGS.  THESE ITEMS ARE SEPARATED BY COMMAS.
;* 
;* A FORMAT IS A POUND SIGN (#) FOLLOWED BY A NUMBER.  IT CONTROLS
;* THE NUMBER OF SPACES THE VALUE OF A EXPRESSION IS GOING TO 
;* BE PRINTED.  IT STAYS EFFECTIVE FOR THE REST OF THE PRINT
;* COMMAND UNLESS CHANGED BY ANOTHER FORMAT.  IF NO FORMAT IS
;* SPECIFIED, 6 POSITIONS WILL BE USED.
;*
;* A '$' PROCEDING AN EXPRESSION INDICATES PRINT THE CHARACTER
;* WHOSE VALUE IS DETERMINED BY THE EXPRESSION [LIKE CHR$()]
;* 
;* A STRING IS QUOTED IN A PAIR OF SINGLE QUOTES OR A PAIR OF
;* DOUBLE QUOTES.  A BACKSLASH ALONE MEANS GENERATE
;* A (CR) WITHOUT A (LF) 
;* 
;* A (CR/LF) IS GENERATED AFTER THE ENTIRE LIST HAS BEEN
;* PRINTED OR IF THE LIST IS A NULL LIST.  HOWEVER IF THE LIST 
;* ENDS WITH A COMMA, NO (CR/LF) IS GENERATED. 
;*
;* EDIT #(CR)  EDIT LINE #
;* 
LIST:	MVI	A,10H
	SIM		;CLEAR RST7.5 FF
	CALL	TSTNUM	;TEST IF THERE IS A #
	CALL	ENDCHK	;IF NO # WE GET A 0	
	CALL	FNDLN	;FIND THIS OR NEXT LINE
	JC	RSTART	;C:PASSED TXTUNF 
	EI		;ENABLE INTERRUPTS
LS1:	CALL	PRTLN	;PRINT THE LINE
	CALL	CKABRT	;STOP IF HIT CONTROL-C
	CALL	FNDLNP	;FIND NEXT LINE
	JC	RSTART	;C:PASSED TXTUNF 
	JMP	LS1	;AND LOOP BACK 
;* 
PRINT:	MVI	C,6	;C = # OF SPACES 
	RST	1	;IF NULL LIST & ":"
	DB	':'
	DB	PR2 - $ - 1
	CALL	CRLF	;GIVE CR-LF AND
	JMP	RUNSML	;CONTINUE RUNNING THE SAME LINE
PR2:	RST	1	;IF NULL LIST (CR) 
	DB	CR 
	DB	PR0 - $ - 1
	CALL	CRLF	;ALSO GIVE CR-LF AND 
	JMP	RUNNXL	;GO TO NEXT LINE 
PR0:	RST	1	;ELSE IS IT FORMAT?
	DB	'#' 
	DB	PR1 - $ - 1
	RST	3	;YES, EVALUATE EXPR. 
	MOV	C,L	;AND SAVE IT IN C
	JMP	PR3	;LOOK FOR MORE TO PRINT
PR1:	RST	1	;PRINT ASCII VALUE?
	DB	'$'
	DB	PR4 - $ - 1
	RST	3	;EVALUE THE EXPR
	MOV	A,L	;GET LOWER BYTE
	CALL	COUT	;SEND THE CHARACTER
	JMP	PR3
PR4:	CALL	QTSTG	;OR IS IT A STRING?
	JMP	PR8	;IF NOT, MUST BE EXPR. 
PR3:	RST	1	;IF ",", GO FIND NEXT
	DB	',' 
	DB 	PR6 - $ - 1
	CALL	FIN	;IN THE LIST.
	JMP	PR0	;LIST CONTINUES
PR6:	CALL	CRLF	;LIST ENDS 
	RST	6 
PR8:	RST	3	;EVALUATE THE EXPR 
	PUSH	B 
	CALL	PRTNUM	;PRINT THE VALUE 
	POP	B 
	JMP	PR3	;MORE TO PRINT?
;*
EDIT:	CALL	TSTNUM	;TEST IF THERE IS A #
	CALL	ENDCHK	;IF NO # WE GET A 0	
	CALL	FNDLN	;FIND THIS OR NEXT LINE (D = LINE #)
	JC	QHOW	;C:PASSED TXTUNF 
	JNZ	QWHAT	;NO SUCH LINE #
	JMP	EDITOR	;EDIT THE LINE
	
;* 
;**************************************************************
;* 
;* *** GOSUB *** & RETURN ***
;* 
;* 'GOSUB EXPR;' OR 'GOSUB EXPR (CR)' IS LIKE THE 'GOTO' 
;* COMMAND, EXCEPT THAT THE CURRENT TEXT POINTER, STACK POINTER
;* ETC. ARE SAVED SO THAT EXECUTION CAN BE CONTINUED AFTER THE
;* SUBROUTINE 'RETURN'.  IN ORDER THAT 'GOSUB' CAN BE NESTED 
;* (AND EVEN RECURSIVE), THE SAVE AREA MUST BE STACKED.
;* THE STACK POINTER IS SAVED IN 'STKGOS'. THE OLD 'STKGOS' IS 
;* SAVED IN THE STACK.  IF WE ARE IN THE MAIN ROUTINE, 'STKGOS'
;* IS ZERO (THIS WAS DONE BY THE "MAIN" SECTION OF THE CODE),
;* BUT WE STILL SAVE IT AS A FLAG FORr NO FURTHER 'RETURN'S.
;* 
;* 'RETURN(CR)' UNDOES EVERYTHING THAT 'GOSUB' DID, AND THUS
;* RETURN THE EXECUTION TO THE COMMAND AFTER THE MOST RECENT
;* 'GOSUB'.  IF 'STKGOS' IS ZERO, IT INDICATES THAT WE 
;* NEVER HAD A 'GOSUB' AND IS THUS AN ERROR. 
;* 
GOSUB:	CALL	PUSHA	;SAVE THE CURRENT "FOR"
	RST	3	;PARAMETERS
	PUSH	D	;AND TEXT POINTER
	CALL	FNDLN	;FIND THE TARGET LINE
	JNZ	AHOW	;NOT THERE. SAY "HOW?" 
	LHLD	CURRNT	;FOUND IT, SAVE OLD
	PUSH	H	;'CURRNT' OLD 'STKGOS' 
	LHLD	STKGOS
	PUSH	H 
	LXI	H,0	;AND LOAD NEW ONES 
	SHLD	LOPVAR
	DAD	SP
	SHLD	STKGOS
	JMP	RUNTSL	;THEN RUN THAT LINE
;*
RETURN:	CALL	ENDCHK	;THERE MUST BE A CR 
	LHLD	STKGOS	;OLD STACK POINTER 
	MOV	A,H	;0 MEANS NOT EXIST 
	ORA	L 
	JZ	QWHAT	;SO, WE SAY: "WHAT?" 
	SPHL		;ELSE, RESTORE IT
	POP	H 
	SHLD	STKGOS	;AND THE OLD 'STKGOS'
	POP	H 
	SHLD	CURRNT	;AND THE OLD 'CURRNT'
	POP	D	;OLD TEXT POINTER
	CALL	POPA	;OLD "FOR" PARAMETERS
	RST	6	;AND WE ARE BACK HOME
;* 
;**************************************************************
;* 
;* *** FOR *** & NEXT ***
;* 
;* 'FOR' HAS TWO FORMS:
;* 'FOR VAR=EXP1 TO EXP2 STEP EXP1' AND 'FOR VAR=EXP1 TO EXP2' 
;* THE SECOND FORM MEANS THE SAME THING AS THE FIRST FORM WITH 
;* EXP1=1.  (I.E., WITH A STEP OF +1.) 
;* TBI WILL FIND THE VARIABLE VAR. AND SET ITS VALUE TO THE
;* CURRENT VALUE OF EXP1.  IT ALSO EVALUATES EXPR2 AND EXP1
;* AND SAVES ALL THESE TOGETHER WITH THE TEXT POINTER ETC. IN 
;* THE 'FOR' SAVE AREA, WHICH CONSISTS OF 'LOPVAR', 'LOPINC',
;* 'LOPLMT', 'LOPLN', AND 'LOPPT'.  IF THERE IS ALREADY SOME-
;* THING IN THE SAVE AREA (THIS IS INDICATED BY A NON-ZERO 
;* 'LOPVAR'), THEN THE OLD SAVE AREA IS SAVED IN THE STACK 
;* BEFORE THE NEW ONE OVERWRITES IT. 
;* TBI WILL THEN DIG IN THE STACK AND FIND OUT IF THIS SAME
;* VARIABLE WAS USED IN ANOTHER CURRENTLY ACTIVE 'FOR' LOOP. 
;* IF THAT IS THE CASE THEN THE OLD 'FOR' LOOP IS DEACTIVATED.
;* (PURGED FROM THE STACK..) 
;* 
;* 'NEXT VAR' SERVES AS THE LOGICAL (NOT NECESSARILLY PHYSICAL)
;* END OF THE 'FOR' LOOP.  THE CONTROL VARIABLE VAR. IS CHECKED
;* WITH THE 'LOPVAR'.  IF THEY ARE NOT THE SAME, TBI DIGS IN 
;* THE STACK TO FIND THE RIGHT ONE AND PURGES ALL THOSE THAT 
;* DID NOT MATCH.  EITHER WAY, TBI THEN ADDS THE 'STEP' TO 
;* THAT VARIABLE AND CHECKS THE RESULT WITH THE LIMIT.  IF IT 
;* IS WITHIN THE LIMIT, CONTROL LOOPS BACK TO THE COMMAND
;* FOLLOWING THE 'FOR'.  IF OUTSIDE THE LIMIT, THE SAVE AREA 
;* IS PURGED AND EXECUTION CONTINUES.
;* 
FOR:	CALL	PUSHA	;SAVE THE OLD SAVE AREA
	CALL	SETVAL	;SET THE CONTROL VAR.
	DCX	H	;HL IS ITS ADDRESS 
	SHLD	LOPVAR	;SAVE THAT 
	LXI	H,TAB5-1 ;USE 'EXEC' TO LOOK
	JMP	EXEC	;FOR THE WORD 'TO' 
FR1:	RST	3	;EVALUATE THE LIMIT
	SHLD	LOPLMT	;SAVE THAT 
	LXI	H,TAB6-1  ;USE 'EXEC' TO LOOK
	JMP	EXEC	;FOR THE WORD 'STEP'
FR2:	RST	3	;FOUND IT, GET STEP
	JMP	FR4 
FR3:	LXI	H,1	;NOT FOUND, SET TO 1 
FR4:	SHLD	LOPINC	;SAVE THAT TOO 
FR5:	LHLD	CURRNT	;SAVE CURRENT LINE # 
	SHLD	LOPLN 
	XCHG		;AND TEXT POINTER
	SHLD	LOPPT 
	LXI	B,10	;DIG INTO STACK TO 
	LHLD	LOPVAR	;FIND 'LOPVAR' 
	XCHG 
	MOV	H,B 
	MOV	L,B	;HL=0 NOW
	DAD	SP	;HERE IS THE STACK 
	DB	76Q 	; MVI A, TRICK (SKIP)
FR7:	DAD	B	;EACH LEVEL IS 10 DEEP 
	MOV	A,M	;GET THAT OLD 'LOPVAR' 
	INX	H 
	ORA	M 
	JZ	FR8	;0 SAYS NO MORE IN IT
	MOV	A,M 
	DCX	H 
	CMP	D	;SAME AS THIS ONE? 
	JNZ	FR7 
	MOV	A,M	;THE OTHER HALF? 
	CMP	E 
	JNZ	FR7 
	XCHG		;YES, FOUND ONE
	LXI	H,0
	DAD	SP	;TRY TO MOVE SP
	MOV	B,H 
	MOV	C,L 
	LXI	H,10 
	DAD	D 
	CALL	MVDOWN	;AND PURGE 10 WORDS
	SPHL		;IN THE STACK
FR8:	LHLD	LOPPT	;JOB DONE, RESTORE DE
	XCHG 
	RST	6	;AND CONTINUE
;* 
NEXT:	RST	7	;GET ADDRESS OF VAR. 
	JC	QWHAT	;NO VARIABLE, "WHAT?"
	SHLD	VARNXT	;YES, SAVE IT
NX0:	PUSH	D	;SAVE TEXT POINTER 
	XCHG 
	LHLD	LOPVAR	;GET VAR. IN 'FOR' 
	MOV	A,H 
	ORA	L	;0 SAYS NEVER HAD ONE
	JZ	AWHAT	;SO WE ASK: "WHAT?"
	RST	4	;ELSE WE CHECK THEM
	JZ	NX3	;OK, THEY AGREE
	POP	D	;NO, LET'S SEE 
	CALL	POPA	;PURGE CURRENT LOOP
	LHLD	VARNXT	;AND POP ONE LEVEL 
	JMP	NX0	;GO CHECK AGAIN
NX3:	MOV	E,M	;COME HERE WHEN AGREED 
	INX	H 
	MOV	D,M	;DE=VALUE OF VAR.
	LHLD	LOPINC
	PUSH	H 
	DAD	D	;ADD ONE STEP
	XCHG 
	LHLD	LOPVAR	;PUT IT BACK 
	MOV	M,E 
	INX	H 
	MOV	M,D 
	LHLD	LOPLMT	;HL->LIMIT 
	POP	PSW	;OLD HL
	ORA	A 
	JP	NX1	;STEP > 0
	XCHG 
NX1:	CALL	CKHLDE	;COMPARE WITH LIMIT
	POP	D	;RESTORE TEXT POINTER
	JC	NX2	;OUTSIDE LIMIT 
	LHLD	LOPLN	;WITHIN LIMIT, GO
	SHLD	CURRNT	;BACK TO THE SAVED 
	LHLD	LOPPT	;'CURRNT' AND TEXT 
	XCHG		;POINTER 
	RST	6 
NX2:	CALL	POPA	;PURGE THIS LOOP 
	RST	6 
;* 
;**************************************************************
;* 
;* *** REM *** IF *** INPUT *** & LET (& DEFLT) ***
;* 
;* 'REM' CAN BE FOLLOWED BY ANYTHING AND IS IGNORED BY TBI.
;* TBI TREATS IT LIKE AN 'IF' WITH A FALSE CONDITION.
;* 
;* 'IF' IS FOLLOWED BY AN EXPR. AS A CONDITION AND ONE OR MORE 
;* COMMANDS (INCLUDING OTHER 'IF'S) SEPERATED BY SEMI-COLONS. 
;* NOTE THAT THE WORD 'THEN' IS NOT USED.  TBI EVALUATES THE 
;* EXPR. IF IT IS NON-ZERO, EXECUTION CONTINUES.  IF THE 
;* EXPR. IS ZERO, THE COMMANDS THAT FOLLOWS ARE IGNORED AND
;* EXECUTION CONTINUES AT THE NEXT LINE. 
;* 
;* 'INPUT' COMMAND IS LIKE THE 'PRINT' COMMAND, AND IS FOLLOWED
;* BY A LIST OF ITEMS.  IF THE ITEM IS A STRING IN SINGLE OR 
;* DOUBLE QUOTES, OR IS A BACK-ARROW, IT HAS THE SAME EFFECT AS
;* IN 'PRINT'.  IF AN ITEM IS A VARIABLE, THIS VARIABLE NAME IS
;* PRINTED OUT FOLLOWED BY A COLON.  THEN TBI WAITS FOR AN 
;* EXPR. TO BE TYPED IN.  THE VARIABLE IS THEN SET TO THE
;* VALUE OF THIS EXPR.  IF THE VARIABLE IS PROCEDED BY A STRING
;* (AGAIN IN SINGLE OR DOUBLE QUOTES), THE STRING WILL BE
;* PRINTED FOLLOWED BY A COLON.  TBI THEN WAITS FOR INPUT EXPR.
;* AND SETS THE VARIABLE TO THE VALUE OF THE EXPR.
;* 
;* IF THE INPUT EXPR. IS INVALID, TBI WILL PRINT "WHAT?",
;* "HOW?" OR "SORRY" AND REPRINT THE PROMPT AND REDO THE INPUT.
;* THE EXECUTION WILL NOT TERMINATE UNLESS YOU TYPE CONTROL-C. 
;* THIS IS HANDLED IN 'INPERR'.
;* 
;* 'LET' IS FOLLOWED BY A LIST OF ITEMS SEPERATED BY COMMAS. 
;* EACH ITEM CONSISTS OF A VARIABLE, AN EQUAL SIGN, AND AN EXPR. 
;* TBI EVALUATES THE EXPR. AND SETS THE VARIBLE TO THAT VALUE.
;* TB WILL ALSO HANDLE 'LET' COMMAND WITHOUT THE WORD 'LET'.
;* THIS IS DONE BY 'DEFLT'.
;* 
REM:	LXI	H,0	;*** REM *** 
	DB	76Q 	; SKIP RST 3
;* 
IFF:	RST	3	;*** IFF ***
	MOV	A,H	;IS THE EXPR.=0? 
	ORA	L 
	JNZ	RUNSML	;NO, CONTINUE
	CALL	FNDSKP	;YES, SKIP REST OF LINE
	JNC	RUNTSL	;SAVE AND RUN
	JMP	RSTART	;NO, NEXT, RESTART
;* 
INPERR:	LHLD	STKINP	;*** INPERR ***
	SPHL		;RESTORE OLD SP
	POP	H	;AND OLD 'CURRNT'
	SHLD	CURRNT
	POP	D	;AND OLD TEXT POINTER
	POP	D	;REDO INPUT
;* 
INPUT:	EQU	$	;*** INPUT *** 
IP1:	PUSH	D	;SAVE IN CASE OF ERROR 
	CALL	QTSTG	;IS NEXT ITEM A STRING?
	JMP	IP2	;NO  (YES, SKIPPED BY QTSTG)
	RST	7	;YES. BUT FOLLOWED BY A
	JC	IP4	;VARIABLE?   NO. 
	JMP	IP3	;YES.  INPUT VARIABLE
IP2:	PUSH	D	;SAVE FOR 'PRTSTG' 
	RST	7	;MUST BE VARIABLE NOW
	JC	QWHAT	;"WHAT?" IT IS NOT?
	LDAX	D	;GET READY FOR 'PRTSTG'
	MOV	C,A 
	SUB	A 
	STAX	D 
	POP	D 
	CALL	PRTSTG	;PRINT STRING AS PROMPT
	MOV	A,C	;RESTORE TEXT
	DCX	D 
	STAX	D 
IP3:	PUSH	D	;SAVE IN CASE OF ERROR 
	XCHG 
	LHLD	CURRNT	;ALSO SAVE 'CURRNT'
	PUSH	H 
	LXI	H,IP1	;A NEGATIVE NUMBER 
	SHLD	CURRNT	;AS A FLAG 
	LXI	H,0Q	;SAVE SP TOO 
	DAD	SP
	SHLD	STKINP
	PUSH	D	;OLD HL
	MVI	A,':'	;PRINT THIS TOO
	CALL	GETLN	;AND GET A LINE
IP3A:	LXI	D,BUFFER ;POINTS TO BUFFER
	RST	3	;EVALUATE INPUT
	NOP		;CAN BE 'CALL ENDCHK'
	NOP
	NOP
	POP	D	;OK, GET OLD HL
	XCHG 
	MOV	M,E	;SAVE VALUE IN VAR.
	INX	H 
	MOV	M,D 
	POP	H	;GET OLD 'CURRNT'
	SHLD	CURRNT
	POP	D	;AND OLD TEXT POINTER
IP4:	POP	PSW	;PURGE JUNK IN STACK 
	RST	1	;IS NEXT CH. ','?
	DB	',' 
	DB	IP5 - $ - 1
	JMP	IP1	;YES, MORE ITEMS.
IP5:	RST	6 
;* 
DEFLT:	LDAX	D	;*** DEFLT *** 
	CPI	CR 	;EMPTY LINE IS OK
	JZ	LT1	;ELSE IT IS 'LET'
;* 
LET:	CALL	SETVAL	;*** LET *** 
	RST	1	;SET VALUE TO VAR. 
	DB	',' 
	DB	LT1 - $ - 1
	JMP	LET	;ITEM BY ITEM
LT1:	RST	6	;UNTIL FINISH
;* 
;**************************************************************
;* 
;* *** EXPR ***
;* 
;* 'EXPR' EVALUATES ARITHMETICAL OR LOGICAL EXPRESSIONS. 
;* <EXPR>::=<EXPR2>
;*          <EXPR2><REL.OP.><EXPR2>
;* WHERE <REL.OP.> IS ONE OF THE OPERATORSs IN TAB8 AND THE 
;* RESULT OF THESE OPERATIONS IS 1 IF TRUE AND 0 IF FALSE. 
;* <EXPR2>::=(+ OR -)<EXPR3>(+ OR -<EXPR3>)(....)
;* WHERE () ARE OPTIONAL AND (....) ARE OPTIONAL REPEATS.
;* <EXPR3>::=<EXPR4>(<* OR / OR %><EXPR4>)(....)
;* <EXPR4>::=<VARIABLE>
;*           <FUNCTION>
;*           (<EXPR>)
;* <EXPR> IS RECURSIVE SO THAT VARIABLE '@' CAN HAVE AN <EXPR> 
;* AS INDEX, FUNCTIONS CAN HAVE AN <EXPR> AS ARGUMENTS, AND
;* <EXPR4> CAN BE AN <EXPR> IN PARENTHESES. 
;* 
;* EXPR CALL EXPR2     THIS IS AT LOC. 18
;*      PUSH HL        SAVE <EXPR2> VALUE
EXPR1:	LXI	H,TAB8-1 ;LOOKUP REL.OP.
	JMP	EXEC	;GO DO IT
XP11:	CALL	XP18	;REL.OP.">=" 
	RC		;NO, RETURN HL=0 
	MOV	L,A	;YES, RETURN HL=1
	RET
XP12:	CALL	XP18	;REL.OP."<>"
	RZ		;FALSE, RETURN HL=0
	MOV	L,A	;TRUE, RETURN HL=1 
	RET
XP13:	CALL	XP18	;REL.OP.">"
	RZ		;FALSE 
	RC		;ALSO FALSE, HL=0
	MOV	L,A	;TRUE, HL=1
	RET
XP14:	CALL	XP18	;REL.OP."<=" 
	MOV	L,A	;SET HL=1
	RZ		;REL. TRUE, RETURN 
	RC 
	MOV	L,H	;ELSE SET HL=0 
	RET
XP15:	CALL 	XP18	;REL.OP."="
	RNZ		;FALSE, RETRUN HL=0
	MOV	L,A	;ELSE SET HL=1 
	RET
XP16:	CALL	XP18	;REL.OP."<"
	RNC		;FALSE, RETURN HL=0
	MOV	L,A	;ELSE SET HL=1 
	RET
XP17:	POP	H	;NOT REL.OP. 
	RET		;RETURN HL=<EXPR2> 
XP18:	MOV	A,C	;SUBROUTINE FOR ALL
	POP	H	;REL.OP.'S 
	POP	B 
	PUSH	H	;REVERSE TOP OF STACK
	PUSH	B 
	MOV	C,A 
	CALL	EXPR2	;GET 2ND <EXPR2> 
	XCHG		;VALUE IN DE NOW 
	XTHL		;1ST <EXPR2> IN HL 
	CALL	CKHLDE	;COMPARE 1ST WITH 2ND
	POP	D	;RESTORE TEXT POINTER
	LXI	H,0Q	;SET HL=0, A=1 
	MVI	A,1 
	RET
;* 
EXPR2:	RST	1	;NEGATIVE SIGN?
	DB	'-' 
	DB	XP21 - $ - 1
	LXI	H,0Q	;YES, FAKE '0-'
	JMP	XP26	;TREAT LIKE SUBTRACT 
XP21:	RST	1	;POSITIVE SIGN?  IGNORE
	DB	'+' 
	DB	XP22 - $ - 1
XP22:	CALL	EXPR3	;1ST <EXPR3> 
XP23:	RST	1	;ADD?
	DB	'+' 
	DB	XP25 - $ - 1
	PUSH	H	;YES, SAVE VALUE 
	CALL	EXPR3	;GET 2ND<EXPR3> 
XP24:	XCHG		;2ND IN DE 
	XTHL		;1ST IN HL 
	MOV	A,H	;COMPARE SIGN
	XRA	D 
	MOV	A,D 
	DAD	D 
	POP	D	;RESTORE TEXT POINTER
	JM	XP23	;1ST 2ND SIGN DIFFER 
	XRA	H	;1ST 2ND SIGN EQUAL
	JP	XP23	;SO IS RESULT
	JMP	QHOW	;ELSE WE HAVE OVERFLOW 
XP25:	RST	1	;SUBTRACT? 
	DB	'-' 
	DB	XP42 - $ - 1
XP26:	PUSH	H	;YES, SAVE 1ST <EXPR3> 
	CALL	EXPR3	;GET 2ND <EXPR3> 
	CALL	CHGSGN	;NEGATE
	JMP	XP24	;AND ADD THEM
;* 
EXPR3:	CALL	EXPR4	;GET 1ST <EXPR4> 
XP31:	RST	1	;MULTIPLY? 
	DB	'*' 
	DB	XP34 - $ - 1
	PUSH	H	;YES, SAVE 1ST 
	CALL	EXPR4	;AND GET 2ND <EXPR4> 
	MVI	B,0Q	;CLEAR B FOR SIGN
	CALL	CHKSGN	;CHECK SIGN
	XCHG		;2ND IN DE NOW 
	XTHL		;1ST IN HL 
	CALL	CHKSGN	;CHECK SIGN OF 1ST 
	MOV	A,H	;IS HL > 255 ? 
	ORA	A 
	JZ	XP32	;NO
	MOV	A,D	;YES, HOW ABOUT DE 
	ORA	D 
	XCHG		;PUT SMALLER IN HL 
	JNZ	AHOW	;ALSO >, WILL OVERFLOW 
XP32:	CALL	MULTPY	;HL = E * L
	JC	AHOW	;OVERFLOW
;*
;* ORIGINAL MULTIPLY LOOP
;XP32:	MOV	A,L	;THIS IS DUMB
;	LXI	H,0Q	;CLEAR RESULT
;	ORA	A	;ADD AND COUNT 
;	JZ	XP35
;XP33:	DAD	D 
;	JC	AHOW	;OVERFLOW
;	DCR	A 
;	JNZ	XP33
;*
	JMP	XP35	;FINISHED
;*
XP34:	RST	1	;DIVIDE? 
	DB	'/' 
	DB	XP34A - $ - 1
	PUSH	H	;YES, SAVE 1ST <EXPR4> 
	CALL	EXPR4	;AND GET 2ND ONE 
	MVI	B,0Q	;CLEAR B FOR SIGN
	CALL	CHKSGN	;CHECK SIGN OF 2ND 
	XCHG		;PUT 2ND IN DE 
	XTHL		;GET 1ST IN HL 
	CALL	CHKSGN	;CHECK SIGN OF 1ST 
	MOV	A,D	;DIVIDE BY 0?
	ORA	E 
	JZ	AHOW	;SAY "HOW?"
	PUSH	B	;ELSE SAVE SIGN
	CALL	DIVIDE	;USE SUBROUTINE
	MOV	H,B	;PUT RESULT IN HL
	MOV	L,C 
	POP	B	;GET SIGN BACK 
	JMP	XP35	;FINISHED
;*	
XP34A:	RST	1	;MODULO?
	DB	'%'
	DB	XP42 - $ - 1
	PUSH	H	;YES, SAVE 1ST <EXPR4> 
	CALL	EXPR4	;AND GET 2ND ONE 
	CALL	CHKSGN	;CHECK SIGN OF 2ND 
	XCHG		;PUT 2ND IN DE 
	XTHL		;GET 1ST IN HL 
	CALL	CHKSGN	;CHECK SIGN OF 1ST 
	MOV	A,D	;DIVIDE BY 0?
	ORA	E 
	JZ	AHOW	;SAY "HOW?"
	MVI	B,0Q	;CLEAR B FOR POSITIVE SIGN
	PUSH	B	;SAVE C
	CALL	DIVIDE	;USE SUBROUTINE
	POP	B
			;REMAINDER IN HL
			;MODULO IS ALWAYS POSITIVE
XP35:	POP	D	;RESTORE TEXT POINTER
	MOV	A,H	;HL MUST BE +
	ORA	A 
	JM	QHOW	;ELSE IT IS OVERFLOW 
	MOV	A,B 
	ORA	A 
	CM	CHGSGN	;CHANGE SIGN IF NEEDED 
	JMP	XP31	;LOOK OR MORE TERMS 
;* 
EXPR4:	LXI	H,TAB4-1 ;FIND FUNCTION IN TAB4 
	JMP	EXEC	;AND GO DO IT
XP40:	RST	7	;NO, NOT A FUNCTION
	JC	XP41	;NOR A VARIABLE
	MOV	A,M	;VARIABLE
	INX	H 
	MOV	H,M	;VALUE IN HL 
	MOV	L,A 
	RET
XP41:	CALL	TSTNUM	;OR IS IT A NUMBER 
	MOV	A,B	;# OF DIGIT
	ORA	A 
	RNZ		;OK
PARN:	RST	1	;NO DIGIT, MUST BE 
	DB	'(' 
	DB	XP43 - $ - 1
	RST	3	;"(EXPR)"
	RST	1 
	DB	')' 
	DB	XP43 - $ - 1
XP42:	RET
XP43:	JMP	QWHAT	;ELSE SAY: "WHAT?" 
;*
;*
;*********************************************************
;*
;*   *** RND *** ABS *** SIZE *** FREE 
;*
;*  RND(X)
;*  RETURNS A RANDOM NUMBER BETWEEN 1 AND X (INCLUSIVE)
;*
;*  ABS(X)
;*  RETURNS THE ABSOLUTE VALUE OF X
;*
;*  SIZE 
;*  RETURNS THE NUMBER OF BYTES LEFT UNUSED BY THE PROGRAM
;*
;*  FREE
;*  RETURNS THE ADDRESS OF THE FIRST BYTE OF FREE MEMORY
;*
;*
;************************************************************
;*
RND:	CALL	PARN	;*** RND(EXPR) *** 
	MOV	A,H	;EXPR MUST BE +
	ORA	A 
	JM	QHOW
	ORA	L	;AND NON-ZERO
	JZ	QHOW
	PUSH	B 
	PUSH	D	;SAVE BOTH 
	PUSH	H 	;SAVE EXPR (N)
;* REPLACEMENT RANDOM NUMBER GENERATOR
	LHLD	SEED
	XCHG		;SEED IN DE
	MOV	A,D
	MOV	H,E
	MVI	L,253
	ORA	A	;CLEAR CY
	MOV	B,A	;SAVE A
	CALL	SUBDE	;HL = HL - DE
	MOV	A,B	;RESTORE A
	SBI	0	;SUBTRACT CARRY
	MOV	B,A	;SAVE A
	CALL	SUBDE
	MOV	A,B	;RESTORE A
	MVI	D,0
	SBB	D
	MOV	E,A
	CALL	SUBDE
	JNC	RA1
	INX	H
RA1:	SHLD	SEED	;SAVE NEW SEED
;*	
	POP	D	;BRING "N" BACK
	CALL	DIVIDE	;RND(N)=MOD(M,N)+1 
	POP	D 
	POP	B 
	INX	H 	;RND(N) IN HL
	RET
;* 
ABS:	CALL	PARN	;*** ABS(EXPR) *** 
	CALL	CHKSGN	;CHECK SIGN
	MOV	A,H	;NOTE THAT -32768
	ORA	H	;CANNOT CHANGE SIGN
	JM	QHOW	;SO SAY: "HOW?"
	RET
;*
SIZE:	LHLD	TXTUNF	;*** SIZE ***
	PUSH	D	;GET THE NUMBER OF FREE
	XCHG		;BYTES BETWEEN 'TXTUNF'
SIZEA:	LHLD	ARRUNF	;AND START OF ARRAY MEMORY
	CALL	SUBDE 	; HL = HL  - DE
	POP	D 
	RET
;*
FREE:	LHLD	TXTUNF	;*** FREE ***
	RET		;RETURN FIRST FREE ADDRESS
;
;*
;*********************************************************
;*
;*   *** PUT$ *** GET$ *** "<CHAR>" ***
;*
;*  PUT$ X
;*  OUTPUTS A STRING (NULL TERM) STARTING FROM ADDRESS X
;*
;*  GET$ X
;*  INPUTS A STRING FROM THE KEYBOARD TO SUCCESSIVE MEMORY
;*  LOCATIONS STARTING AT X TERMINATED WITH A NULL
;*  THE LENGTH OF THE STRING INCLUDING THE NULL IS RETURNED
;*  IN VARIABLE Z
;*
;*  "<CHAR>"  (SCHAR)
;*  RETURN THE ASCII VALUE OF A CHARACTER BETWEEN QUOTES
;*
;*
;************************************************************
;*
PUTST:	RST	3	; (EXPR) GET ADDRESS OF STRING
	PUSH	D	; SAVE TEXT POINTER
	XCHG		; DE IS NOW ADDRESS OF STRING
	XRA	A
	CALL	PRTSTG	; PRINT UNTIL NULL
	POP	D	; RESTORE POINTER
	RST	6	; FINISH
;*
GETST:	RST	3	; (EXPR) GET ADDRESS TO STORE STRING
	PUSH	D	; SAVE POINTER
	XCHG
	LHLD	TXTUNF	; GET LOW LIMIT TO DE
	XCHG
	RST	4	; COMPARE (HL-DE)
	JC	ASORRY	; IF HL < LIMIT, NO INPUT
	CALL	GL0	; INPUT TO BUFFER (NO PROMPT)
	MOV	B,H
	MOV	C,L	; BC IS ADDR TO MOVE STRING TO
	XCHG		; HL IS LAST CHR + 1
	DCX	H	; NOW POINTS TO LAST CHR (CR)
	LXI	D,BUFFER ; DE IS FIRST CHAR
	PUSH	D	; SAVE TO COMPUTE LENGTH
	CALL	MVUP	; MOVE (DE) TO (BC) UNTIL DE = HL
	XRA	A
	STAX	B	; REPLACE CR WITH NULL AT END OF STRING
	POP	D	; FIRST CHAR
	INX	H	; LAST CHAR + 1
	CALL	SUBDE	; HL = HL-DE (LENGTH OF STRING)
	XCHG		; PUT IN DE
	LXI	H,VARBGN + (26*2) ; STORE LENGTH IN VARIABLE Z
	MOV	M,E
	INX	H
	MOV	M,D
	POP	D	; RESTORE POINTER
	CALL	FIN	; GO ON IF STORED STATEMENT
	JMP	RSTART	; OTHERWISE INPUT ZAPPED DIRECT COMMAND, RESTART
;*
SCHAR:	LDAX	D	; GET TEXT CHAR AFTER QUOTE ("")
	INX	D
	MOV	L,A	; ASCII VALUE IN HL
	MVI	H,0
	RST	1	; TSTC,'"',ASC1
	DB	'"'
	DB 	ASC1 - $ - 1
	RET		; CHAR FOLLOWED BY QUOTE, RETURN
ASC1:	JMP	QWHAT	; NO, ERROR
;*
;*********************************************************
;*
;*   *** OUT *** INP *** POKE *** PEEK *** USR ***
;*
;*  OUT I,J
;*  OUTPUTS EXPRESSION 'J' TO PORT 'I'
;*  USES THE MONITOR I/O COMMANDS
;*
;*  INP (I)
;*  THIS FUNCTION RETURNS DATA READ FROM INPUT PORT 'I' AS
;*  IT'S VALUE.
;*  USES THE MONITOR I/O COMMANDS
;*
;*  POKE I,J
;*  THIS COMMAND WORKS LIKE OUT EXCEPT THAT IT PUTS DATA 'J'
;*  INTO MEMORY LOCATION 'I'.
;*
;*  PEEK (I)
;*  THIS FUNCTION WORKS LIKE INP EXCEPT IT GETS IT'S VALUE
;*  FROM MEMORY LOCATION 'I'.
;*
;*  USR (I(,J))
;*  USR CALLS A MACHINE LANGUAGE SUBROUTINE AT LOCATION 'I'
;*  IF THE OPTIONAL PARAMETER 'J' IS USED ITS VALUE IS PASSED
;*  IN H&L.  THE VALUE OF THE FUNCTION SHOULD BE RETURNED IN H&L.
;*
;*
;************************************************************
;*
OUTCMD:	RST	3 	; EXPR
	MOV	C,L	; C = PORT NUMBER
	RST	1	; TSTC,',',IOMERR
	DB	','
	DB	IOMERR - $ - 1
	RST	3	; EXPR, L = OUTPUT BYTE
	CALL	POUT	; OUTPUT BYTE TO PORT
	RST	6	; FINISH
;*
INCMD:	CALL	PARN
	MOV	C,L	; C = PORT NUMBER
	CALL	PIN	; READ FROM PORT
	MOV	L,A
	MVI	H,0	; PUT BYTE IN HL
	RET
;*
POKE:	RST	3	; EXPR
	PUSH	H	; SAVE POKE ADDRESS ON STACK
	RST	1	; TEST,',',IIOMERR
	DB	','
	DB	IOMERR - $ - 1
	RST	3	; EXPR
	MOV	A,L	; BYTE TO A
	POP	H	; GET ADDRESS
	MOV	M,A	; POKE BYTE TO ADDRESS
	RST	6	; FINISH
;*
PEEK:	CALL	PARN	; GET ADDRESS
	MOV	L,M	; READ BYTE
	MVI	H,0
	RET
;*
USR:	PUSH	B	; SAVE B
	RST	1	; TSTC,'(',IOMERR
	DB	'('
	DB	IOMERR - $ - 1 ;QWHAT
	RST	3	;EXPR
	RST	1
	DB	')'
	DB	PASPRM - $ - 1 ;PASPRM
	PUSH	D	; SAVE D
	LXI	D,USRET
	PUSH	D	; SET RETURN ADDRESS FROM USER CALL
	PUSH	H	; PUT SUBROUTINE ADDRESS ON STACK
	RET		; CALL USR ROUTINE WITHOUT PARAMETER
;
PASPRM:	RST	1	; TSTC,',',IOMERR
	DB	','
	DB	USRET - $ - 1
	PUSH	H	; SAVE ADDRESS ON STACK
	RST	3	; EXPR
	RST	1	; TSTC,')',USRRET
	DB	')'
	DB	USRET + 1 - $ - 1 ; (SKIP POP D)
	POP	B	; GET ADDRESS IN B
	PUSH	D	; SAVE D
	LXI	D,USRET
	PUSH	D	; SET RETURN ADDRESS FROM USER CALL
	PUSH	B	; PUT SUBROUTINE ADDRESS ON STACK
	RET		;CALL USR ROUTINE
USRET:	POP	D
	POP	B
	RET
;*	
IOMERR:	JMP	QWHAT	; I/O OR MEMORY ERROR
;*
;*********************************************************
;*
;*   *** DIM ***
;*
;*  DIM <VAR>(<SIZE>)
;*  ALLOCATES MEMORY FOR 1-D ARRAY
;*
;*  VARIABLE <VAR> HOLDS ARRAY ADDRESS
;* 
;************************************************************
;*
DIM:	RST	5	; IGNBLK, A=VARIABLE NAME
	SUI	'@'	; CONVERT ASCII TO VARIABLE OFFSET
	JC	DIMERR	; NOT A VARIABLE
	JZ	DIMERR	; ERROR IF '@' WHICH IS ALREADY AN ARRAY
	CPI	1BH	; 'A' TO 'Z'?
	JNC	DIMERR	; NOT A VARIABLE
	INX	D	; MOVE TEXT POINTER
	LXI	H,VARBGN ; COMPUTE ADDRESS OF VARIABLE
	RLC		; CREATE BYTE OFFSET, CLEAR CARRY
	ADD	L	; AND PUT VARIABLE ADDRESS IN H,L
	MOV	L,A
	MVI	A,0
	ADC	H
	MOV	H,A
	SHLD	VADDR	; SAVE VARIABLE ADDRESS
	CALL	PARN	; GET ARRAY SIZE (# WORDS)
	DAD	H	; CONVERT SIZE TO BYTES
	JC	QSORRY	; ERROR IF TOO BIG
	PUSH	D	; SAVE TEXT POINTER
	XCHG		; ARRAY SIZE (IN BYTES) IN D,E
;*
;* ZERO ARRAY MOVING DOWN IN MEMORY
;* STORE LAST ADDRESS IN VARIABLE (LOWEST MEMORY LOCATION)
;*
CLRARY:	LHLD	ARRUNF	; GET NEXT ARRAY FREE ADDRESS
CLR1:	XRA	A	; CLEAR A
	MOV	M,A	; INITIALIZE ARRAY TO ZERO
	DCX	H	; MOVING DOWN IN MEMORY FROM ARRUNF
	DCX	D	; DECREMENT COUNT
	MOV	A,E
	ORA	D	; DONE?
	JNZ	CLR1
	SHLD	ARRUNF	; SET NEW FREE ADDRESS
	INX	H	; POINT BACK TO FIRST BYTE IN ARRAY
	XCHG		; PUT IN DE
	LHLD	VADDR	; GET VARIABLE ADDRESS
	MOV	M,E	; STORE ARRAY ADDRESS IN VARIABLE
	INX	H
	MOV	M,D	
	POP	D	; RESTORE TEXT POINTER
	RST	6	; FINISH
;*	
DIMERR:	JMP	QWHAT	; ERROR
;*
;**************************************************************
;* 
;* *** MULTPY *** DIVIDE *** SUBDE *** CHKSGN *** CHGSGN *** & CKHLDE *** 
;* 
;* 'MULTPY' MULTIPLIES DE BY L, (H = 0) RESULT IN HL
;*
;* 'DIVIDE' DIVIDES HL BY DE, RESULT IN BC, REMAINDER IN HL
;* 
;* 'SUBDE' SUBTRACTS DE FROM HL
;* 
;* 'CHKSGN' CHECKS SIGN OF HL.  IF +, NO CHANGE.  IF -, CHANGE 
;* SIGN AND FLIP SIGN OF B.
;* 
;* 'CHGSGN' CHANGES SIGN OF HL AND B UNCONDITIONALLY. 
;* 
;* 'CKHLDE' CHECKS SIGN OF HL AND DE.  IF DIFFERENT, HL AND DE 
;* ARE INTERCHANGED.  IF SAME SIGN, NOT INTERCHANGED.  EITHER
;* CASE, HL DE ARE THEN COMPARED TO SET THE FLAGS. 
;* 
;*
;*
MPY:	MOV	A,H	;IS HL > 255 ? 
	ORA	A 
	JZ	MULTPY	;NO
	MOV	A,D	;YES, HOW ABOUT DE 
	ORA	D 
	XCHG		;PUT SMALLER IN HL 
	JNZ	QHOW	;ALSO >, WILL OVERFLOW 
MULTPY:	PUSH	B
	MVI	B,8	; BIT COUNT IN B
	MOV	A,L	; MULTIPLIER IN A
	LXI	H,0	; PRODUCT = 0
MULT:	DAD	H	; SHIFT PRODUCT
	RAL		; SHIFT MULTIPLIER
	JNC	CHCNT
	DAD	D	; PRODUCT = PRODUCT * MULTIPLICAND
CHCNT:	DCR	B
	JNZ	MULT
	POP	B
	RET
;*
DIVIDE:	PUSH	H	;*** DIVIDE ***
	MOV	L,H	;DIVIDE H BY DE
	MVI	H,0 
	CALL	DV1 
	MOV	B,C	;SAVE RESULT IN B
	MOV	A,L	;(REMAINDER+L)/DE
	POP	H 
	MOV	H,A 
DV1:	MVI	C,-1	;RESULT IN C 
DV2:	INR	C	;DUMB ROUTINE
	CALL	SUBDE	;DIVIDE BY SUBTRACT
	JNC	DV2	;AND COUNT 
	DAD	D 
	RET
;* 
SUBDE:	MOV	A,L	;*** SUBDE *** 
	SUB	E	;SUBTRACT DE FROM
	MOV	L,A	;HL
	MOV	A,H 
	SBB	D 
	MOV	H,A 
	RET
;* 
CHKSGN:	MOV	A,H	;*** CHKSGN ***
	ORA	A	;CHECK SIGN OF HL
	RP		;IF -, CHANGE SIGN 
;* 
CHGSGN:	MOV	A,H	;*** CHGSGN ***
	CMA		;CHANGE SIGN OF HL 
	MOV	H,A 
	MOV	A,L 
	CMA
	MOV	L,A 
	INX	H 
	MOV	A,B	;AND ALSO FLIP B 
	XRI	80H
	MOV	B,A 
	RET
;* 
CKHLDE:	MOV	A,H 
	XRA	D	;SAME SIGN?
	JP	CK1	;YES, COMPARE
	XCHG		;NO, XCH AND COMP
CK1:	RST	4 	;COMPARE
	RET       
;* 
;**************************************************************
;* 
;* *** SETVAL *** FIN *** ENDCHK *** & ERROR (& FRIENDS) *** 
;* 
;* "SETVAL" EXPECTS A VARIABLE, FOLLOWED BY AN EQUAL SIGN AND
;* THEN AN EXPR.  IT EVALUATES THE EXPR. AND SET THE VARIABLE
;* TO THAT VALUE.
;* 
;* "FIN" CHECKS THE END OF A COMMAND.  IF IT ENDED WITH ":", 
;* EXECUTION CONTINUES.  IF IT ENDED WITH A CR, IT FINDS THE 
;* NEXT LINE AND CONTINUE FROM THERE.
;* 
;* "ENDCHK" CHECKS IF A COMMAND IS ENDED WITH CR.  THIS IS 
;* REQUIRED IN CERTAIN COMMANDS. (GOTO, RETURN, AND STOP ETC.) 
;* 
;* "ERROR" PRINTS THE STRING POINTED BY DE (AND ENDS WITH CR). 
;* IT THEN PRINTS THE LINE POINTED BY 'CURRNT' WITH A "?"
;* INSERTED AT WHERE THE OLD TEXT POINTER (SHOULD BE ON TOP
;* OF THE STACK) POINTS TO.  EXECUTION OF TBI IS STOPPED
;* AND TBI IS RESTARTED.  HOWEVER, IF 'CURRNT' -> ZERO 
;* (INDICATING A DIRECT COMMAND), THE DIRECT COMMAND IS NOT
;*  PRINTED.  AND IF 'CURRNT' -> NEGATIVE # (INDICATING 'INPUT'
;* COMMAND, THE INPUT LINE IS NOT PRINTED AND EXECUTION IS 
;* NOT TERMINATED BUT CONTINUED AT 'INPERR'. 
;* 
;* RELATED TO 'ERROR' ARE THE FOLLOWING: 
;* 'QWHAT' SAVES TEXT POINTER IN STACK AND GET MESSAGE "WHAT?" 
;* 'AWHAT' JUST GET MESSAGE "WHAT?" AND JUMP TO 'ERROR'. 
;* 'QSORRY' AND 'ASORRY' DO SAME KIND OF THING.
;* 'QHOW' AND 'AHOW' IN THE ZERO PAGE SECTION ALSO DO THIS 
;* 
SETVAL:	RST	7	;*** SETVAL ***
	JC	QWHAT	;"WHAT?" NO VARIABLE 
	PUSH	H	;SAVE ADDRESS OF VAR.
	RST	1	;PASS "=" SIGN 
	DB	'=' 
	DB	SV1 - $ - 1
	RST	3	;EVALUATE EXPR.
	MOV	B,H	;VALUE IN BC NOW 
	MOV	C,L 
	POP	H	;GET ADDRESS 
	MOV	M,C	;SAVE VALUE
	INX	H 
	MOV	M,B 
	RET
SV1:	JMP	QWHAT	;NO "=" SIGN 
;* 
FIN:	RST	1	;*** FIN *** 
	DB	':' 
	DB	FI1 - $ - 1
	POP	PSW	;":", PURGE RET ADDR.
	JMP	RUNSML	;CONTINUE SAME LINE
FI1:	RST	1	;NOT ":", IS IT CR?
	DB	CR 
	DB	FI2 - $ - 1
	POP	PSW	;YES, PURGE RET ADDR.
	JMP	RUNNXL	;RUN NEXT LINE 
FI2:	RET		;ELSE RETURN TO CALLER 
;* 
ENDCHK:	RST	5	;*** ENDCHK ***
	CPI	CR 	;END WITH CR?
	RZ		;OK, ELSE SAY: "WHAT?" 
;* 
QWHAT:	PUSH	D	;*** QWHAT *** 
AWHAT:	LXI	D,WHAT	;*** AWHAT *** 
ERRORB:	SUB	A	;*** ERROR *** 
	CALL	PRTSTG	;PRINT 'WHAT?', 'HOW?' 
	POP	D	;OR 'SORRY'
	LDAX	D	;SAVE THE CHARACTER
	PUSH	PSW	;AT WHERE OLD DE ->
	SUB	A	;AND PUT A 0 THERE 
	STAX	D 
	LHLD	CURRNT	;GET CURRENT LINE #
	PUSH	H 
	MOV	A,M	;CHECK THE VALUE 
	INX	H 
	ORA	M 
	POP	D 
	JZ	RSTART	;IF ZERO, JUST RESTART
	MOV	A,M	;IF NEGATIVE,
	ORA	A 
	JM	INPERR	;REDO INPUT
	CALL	PRTLN	;ELSE PRINT THE LINE 
	DCX	D	;UPTO WHERE THE 0 IS 
	POP	PSW	;RESTORE THE CHARACTER 
	STAX	D 
	MVI	A,'?'	;PRINT A "?" 
	RST	2 	;OUTC
	SUB	A	;AND THE REST OF THE 
	CALL	PRTSTG	;LINE
	JMP	RSTART
;*
QSORRY:	PUSH	D	;*** QSORRY ***
ASORRY:	LXI	D,SORRY	;*** ASORRY ***
	JMP	ERRORB 
;* 
;**************************************************************
;* 
;* *** GETLN *** FNDLN (& FRIENDS) *** 
;* 
;* 'GETLN' READS A INPUT LINE INTO 'BUFFER'.  IT FIRST PROMPT
;* THE CHARACTER IN A (GIVEN BY THE CALLER), THEN IT FILLS THE 
;* THE BUFFER AND ECHOS.  LOWER CASE IS CONVERTED TO UPPER.
;*
;* BACKSPACE OR RUB-OUT IS USED TO CAUSE IT TO DELETE 
;* THE LAST CHARACTER (IF THERE IS ONE), AND ^D IS USED TO 
;* CAUSE IT TO DELETE THE WHOLE LINE AND START IT ALL OVER.
;* CR SIGNALS THE END OF A LINE, AND CAUSES 'GETLN' TO RETURN.
;* 
;* 'FNDLN' FINDS A LINE WITH A GIVEN LINE # (IN HL) IN THE 
;* TEXT SAVE AREA.  DE IS USED AS THE TEXT POINTER.  IF THE
;* LINE IS FOUND, DE WILL POINT TO THE BEGINNING OF THAT LINE
;* (I.E., THE LOW BYTE OF THE LINE #), AND FLAGS ARE NC & Z. 
;* IF THAT LINE IS NOT THERE AND A LINE WITH A HIGHER LINE # 
;* IS FOUND, DE POINTS TO THERE AND FLAGS ARE NC & NZ.  IF 
;* WE REACHED THE END OF TEXT SAVE ARE AND CANNOT FIND THE 
;* LINE, FLAGS ARE C & NZ. 
;* 'FNDLN' WILL INITIALIZE DE TO THE BEGINNING OF THE TEXT SAVE
;* AREA TO START THE SEARCH.  SOME OTHER ENTRIES OF THIS 
;* ROUTINE WILL NOT INITIALIZE DE AND DO THE SEARCH. 
;* 'FNDLNP' WILL START WITH DE AND SEARCH FOR THE LINE #.
;* 'FNDNXT' WILL BUMP DE BY 2, FIND A CR AND THEN START SEARCH.
;* 'FNDSKP' USE DE TO FIND A CR, AND THEN START SEARCH. 
;* 
GETLN:	RST	2	;*** GETLN *** 
GL0:	LXI	D,BUFFER ;PROMPT AND INIT
;*
GL1:	CALL	CHKIO	;CONSOLE CHAR
	CPI	' '	;CONTROL?
	JC	GL4	;YES
	CPI	DEL	;DELETE?
	JZ	GL5	;YES
	CPI	'a'	;LOWER CASE?
	JC	GL2	;NO, SKIP
	CPI	'z'+1
	JNC	GL2	;NO, SKIP
	ANI	5FH	;YES, CONVERT
;*
GL2:	STAX	D	;SAVE INPUT IN BUFFER
	INX	D	;AND BUMP POINTER
	RST	2	;ELSE, ECHO THE CHARACTER
;*
;* CHECK FOR END OF BUFFER
;*
GL3:	MOV	A,E	;MORE FREE ROOM?
	CPI	BUFEND AND 0FFH
	JNZ	GL1	;YES, GET NEXT INPUT
;*
;* SEND ERROR BEEP AT THE END OF THE BUFFER
;*
	MVI	A,BELL
	CALL	COUT
	MVI	A,CR
	STAX	D	;TERMINATE WITH A CR AND EXIT
	RET
;*
;* PROCESS CONTROL CHARACTER
;*
GL4:	CPI	CTRC	;^C?
	JZ	RSTART	;YES, RESTART
	CPI	CTRH	;^H?
	JZ	GL5	;YES, DELETE CHAR
	CPI	CTRD	;^D?
	JZ	GL6	;YES, DELETE LINE
	CPI	CTRO	;^O?
	JZ	GL7	;YES, TOGGLE OUTPUT SWITCH
	CPI	CR	;RETURN?
	JNZ	GL1	;NO, IGNORE THE CONTROL CHARACTER
	STAX	D	;YES, SAVE CR
	INX	D	;BUMP POINTER
	JMP	CRLF	;AND EXIT WITH A NEW LINE	
;*
;* DELETE PRIOR CHARACTER IF ANY
;*
GL5:	MOV	A,E	;DELETE LAST CHARACTER 
	CPI	BUFFER AND 0FFH    ;BUT DO WE HAVE ANY? 
	JZ	GL1	;NO, GET THE NEXT CHARACTER
;*
	DCX	D	;YES, BACKUP POINTER 
	MVI	A,CTRH	;AND ECHO A BACK-SPACE, SPACE, BACK-SPACE
	CALL	COUT	;TO DELETE THE CHARACTER
	MVI	A,' '
	CALL	COUT
	MVI	A,CTRH
	CALL 	COUT
	JMP	GL1	;GO GET NEXT INPUT
;*
;* DELETE LINE BY DELETING THE CHARACTERS ONE AT A TIME
;*
GL6:	MOV	A,E
	CPI	BUFFER AND 0FFH	;AT BEGINNING OF BUFFER?
	JZ	GL1	;YES, START AGAIN
	DCX	D	;NO, BACKUP POINTER 
	MVI	A,CTRH	;AND ECHO A BACK-SPACE, SPACE, BACK-SPACE
	CALL	COUT	;TO DELETE THE CHARACTER
	MVI	A,' '
	CALL	COUT
	MVI	A,CTRH
	CALL 	COUT
	JMP	GL6	;GO DELETE NEXT CHARACTER
;*
;* TOGGLE THE OUTPUT SWITCH
;*
GL7:	LDA	OCSW	;YES, TOGGLE OCSW
	CMA		;ON TO OFF OR OFF TO ON
	STA	OCSW	;AND PUT IT BACK
	JMP	GL1	;AND GET ANOTHER CHARACTER
;*
;* FIND A LINE BY THE LINE NUMBER
;*
FNDLN:	MOV	A,H	;*** FNDLN *** 
	ORA	A	;CHECK SIGN OF HL
	JM	QHOW	;IT CANNOT BE -
	LXI	D,TXTBGN  ;INIT. TEXT POINTER
;* 
FNDLNP:	EQU	$	;*** FNDLNP ***
FL1:	PUSH	H	;SAVE LINE # 
	LHLD	TXTUNF	;CHECK IF WE PASSED END
	DCX	H 
	RST	4 	;COMPARE DE WITH HL
	POP	H	;GET LINE # BACK 
	RC		;CY,NZ PASSED END 
	LDAX	D	;WE DID NOT, GET BYTE 1
	SUB	L	;IS THIS THE LINE? 
	MOV	B,A	;COMPARE LOW ORDER 
	INX	D 
	LDAX	D	;GET BYTE 2
	SBB	H	;COMPARE HIGH ORDER
	JC	FL2	;NO, NOT THERE YET 
	DCX	D	;ELSE WE EITHER FOUND
	ORA	B	;IT, OR IT IS NOT THERE
	RET		;NC,Z:FOUND; NC,NZ:NOT FOUND
;* 
FNDNXT:	EQU	$	;*** FNDNXT ***
	INX	D	;FIND NEXT LINE
FL2:	INX	D	;JUST PASSED BYTE 1 & 2
;* 
FNDSKP:	LDAX	D	;*** FNDSKP ***
	CPI	CR 	;TRY TO FIND CR 
	JNZ	FL2	;KEEP LOOKING
	INX	D	;FOUND CR, SKIP OVER 
	JMP	FL1	;CHECK IF END OF TEXT
;* 
;*************************************************************
;* 
;* *** PRTSTG *** QTSTG *** PRTNUM *** & PRTLN *** 
;* 
;* 'PRTSTG' PRINTS A STRING POINTED BY DE.  IT STOPS PRINTING
;* AND RETURNS TO CALLER WHEN EITHER A CR  IS PRINTED OR WHEN 
;* THE NEXT BYTE IS THE SAME AS WHAT WAS IN A (GIVEN BY THE
;* CALLER).  OLD A IS STORED IN B, OLD B IS LOST.
;* 
;* 'QTSTG' LOOKS FOR A BACK-SLASH, SINGLE QUOTE, OR DOUBLE 
;* QUOTE.  IF NONE OF THESE, RETURN TO CALLER.  IF BACK-SLASH, 
;* OUTPUT A CR WITHOUT A LF.  IF SINGLE OR DOUBLE QUOTE, PRINT 
;* THE STRING IN THE QUOTE AND DEMANDS A MATCHING UNQUOTE. 
;* AFTER THE PRINTING, THE NEXT 3 BYTES OF THE CALLER IS SKIPPED
;* OVER (USUALLY A JUMP INSTRUCTION).
;* 
;* 'PRTNUM' PRINTS THE NUMBER IN HL.  LEADING BLANKS ARE ADDED 
;* IF NEEDED TO PAD THE NUMBER OF SPACES TO THE NUMBER IN C. 
;* HOWEVER, IF THE NUMBER OF DIGITS IS LARGER THAN THE # IN
;* C, ALL DIGITS ARE PRINTED ANYWAY.  NEGATIVE SIGN IS ALSO
;* PRINTED AND COUNTED IN, POSITIVE SIGN IS NOT. 
;* 
;* 'PRTLN' PRINTS A SAVED TEXT LINE WITH LINE # AND ALL. 
;*
PRTSTZ:	XRA	A	;CLEAR A, TO STOP AT NULL
PRTSTG:	MOV	B,A	;*** PRTSTG ***
PS1:	LDAX	D	;GET A CHARACTER 
	INX	D	;BUMP POINTER
	CMP	B	;SAME AS OLD A?
	RZ		;YES, RETURN 
	RST	2	;ELSE PRINT IT 
	CPI	CR	;WAS IT A CR?
	JNZ	PS1	;NO, NEXT
	RET		;YES, RETURN 
;* 
QTSTG:  RST	1	;*** QTSTG *** 
	DB	'"' 
	DB	QT3 - $ - 1
	MVI	A,'"'	;IT IS A " 
QT1:	CALL	PRTSTG	;PRINT UNTIL ANOTHER 
	CPI	CR	;WAS LAST ONE A CR?
	POP	H	;RETURN ADDRESS
	JZ	RUNNXL	;WAS CR, RUN NEXT LINE 
QT2:	INX	H	;SKIP 3 BYTES ON RETURN
	INX	H 
	INX	H 
	PCHL		;RETURN
QT3:	RST	1	;IS IT A ' ? 
	DB	27H 
	DB	QT4 - $ - 1
	MVI	A,27H	;YES, DO SAME
	JMP	QT1	;AS IN " 
QT4:	RST	1	;IS IT BACK-SLASH? 
	DB	'\'
	DB	QT5 - $ - 1
	MVI	A,CR	;YES, CR  WITHOUT LF!!
	CALL	COUT
	POP	H	;RETURN ADDRESS
	JMP	QT2 
QT5:	RET		;NONE OF ABOVE 
;* 
PRTNUM:	PUSH	D	;*** PRTNUM ***
	LXI	D,10	;DECIMAL 
	PUSH	D	;SAVE AS A FLAG
	MOV	B,D	;B=SIGN
	DCR	C	;C=SPACES
	CALL	CHKSGN	;CHECK SIGN
	JP	PN1	;NO SIGN 
	MVI	B,'-'	;B=SIGN
	DCR	C	;'-' TAKES SPACE 
PN1:	PUSH	B	;SAVE SIGN & SPACE 
PN2:	CALL	DIVIDE	;DIVIDE HL BY 10 
	MOV	A,B	;RESULT 0? 
	ORA	C 
	JZ	PN3	;YES, WE GOT ALL 
	XTHL		;NO, SAVE REMAINDER
	DCR	L	;AND COUNT SPACE 
	PUSH	H	;HL IS OLD BC
	MOV	H,B	;MOVE RESULT TO BC 
	MOV	L,C 
	JMP	PN2	;AND DIVIDE BY 10
PN3:	POP	B	;WE GOT ALL DIGITS IN
PN4:	DCR	C	;THE STACK 
	MOV	A,C	;LOOK AT SPACE COUNT 
	ORA	A 
	JM	PN5	;NO LEADING BLANKS 
	MVI	A,' '	;LEADING BLANKS
	RST	2 	;OUTC
	JMP	PN4	;MORE? 
PN5:	MOV	A,B	;PRINT SIGN
	RST	2	;MAYBE - OR NULL 
	MOV	E,L	;LAST REMAINDER IN E 
PN6:	MOV	A,E	;CHECK DIGIT IN E
	CPI	10	;10 IS FLAG FOR NO MORE
	POP	D 
	RZ		;IF SO, RETURN 
	ADI	'0'	;ELSE CONVERT TO ASCII
	RST	2	;AND PRINT THE DIGIT 
	JMP	PN6	;GO BACK FOR MORE
;* 
PRTLN:	LDAX	D	;*** PRTLN *** 
	MOV	L,A	;LOW ORDER LINE #
	INX	D 
	LDAX	D	;HIGH ORDER
	MOV	H,A 
	INX	D 
	MVI	C,4	;PRINT 4 DIGIT LINE #
	CALL	PRTNUM
	MVI	A,' '	;FOLLOWED BY A BLANK 
	RST	2 
	SUB	A	;AND THEN THE TEXT 
	CALL	PRTSTG
	RET
;* 
;**************************************************************
;* 
;* *** MVUP *** MVDOWN *** POPA *** & PUSHA ***
;* 
;* 'MVUP' MOVES A BLOCK UP FROM WHERE DE-> TO WHERE BC-> UNTIL 
;* DE = HL 
;* 
;* 'MVDOWN' MOVES A BLOCK DOWN FROM WHERE DE-> TO WHERE HL-> 
;* UNTIL DE = BC 
;* 
;* 'POPA' RESTORES THE 'FOR' LOOP VARIABLE SAVE AREA FROM THE
;* STACK 
;* 
;* 'PUSHA' STACKS THE 'FOR' LOOP VARIABLE SAVE AREA INTO THE 
;* STACK 
;* 
MVUP:	RST	4	;*** MVUP ***
	RZ		;DE = HL, RETURN 
	LDAX	D	;GET ONE BYTE
	STAX	B	;MOVE IT 
	INX	D	;INCREASE BOTH POINTERS
	INX	B 
	JMP	MVUP	;UNTIL DONE
;* 
MVDOWN: MOV	A,B	;*** MVDOWN ***
	SUB	D	;TEST IF DE = BC 
	JNZ	MD1	;NO, GO MOVE 
	MOV	A,C	;MAYBE, OTHER BYTE?
	SUB	E 
	RZ		;YES, RETURN 
MD1:	DCX	D	;ELSE MOVE A BYTE
	DCX	H	;BUT FIRST DECREASE
	LDAX	D	;BOTH POINTERS AND 
	MOV	M,A	;THEN DO IT
	JMP	MVDOWN	;LOOP BACK 
;* 
POPA:	POP	B	;BC = RETURN ADDR. 
	POP	H	;RESTORE LOPVAR, BUT 
	SHLD	LOPVAR	;=0 MEANS NO MORE
	MOV	A,H 
	ORA	L 
	JZ	PP1	;YEP, GO RETURN
	POP	H	;NOP, RESTORE OTHERS 
	SHLD	LOPINC
	POP	H 
	SHLD	LOPLMT
	POP	H 
	SHLD	LOPLN 
	POP	H 
	SHLD	LOPPT 
PP1:	PUSH	B	;BC = RETURN ADDR. 
	RET
;* 
PUSHA:	LXI	H,STKLMT	;*** PUSHA *** 
	CALL	CHGSGN
	POP	B	;BC=RETURN ADDRESS 
	DAD	SP	;OUT OF STACK SPACE?
	JNC	QSORRY	;YES, SORRY FOR THAT.
	LHLD	LOPVAR	;ELSE SAVE LOOP VAR.S
	MOV	A,H	;BUT IF LOPVAR IS 0
	ORA	L	;THAT WILL BE ALL
	JZ	PU1 
	LHLD	LOPPT	;ELSE, MORE TO SAVE
	PUSH	H 
	LHLD	LOPLN 
	PUSH	H 
	LHLD	LOPLMT
	PUSH	H 
	LHLD	LOPINC
	PUSH	H 
	LHLD	LOPVAR
PU1:	PUSH	H 
	PUSH	B	;BC = RETURN ADDR. 
	RET
;* 
;**************************************************************
;* 
;* *** EDITOR *** 
;* 
;* (C) 2017 DAVID HUNTER
;*
;* 'EDITOR' ALLOWS FOR A LINE TO BE EDITED USING AN ANSI TERMINAL (OR EMULATOR)
;* IT HANDLES LEFT & RIGHT ARROWS, BACKSPACE AND CHARACTER INSERTS/DELETES.
;* <F1> (CODE: <ESC>[11~) EXITS THE EDITOR
;* <CR> TERMINATES THE LINE AND EXITS
;* IT IS BASICALLY A ONE LINE "SCREEN EDITOR"
;*
;* TO USE, TYPE "EDIT #" AT THE BASIC PROMPT WHERE # IS THE LINE NUMBER
;*
;*
;* NOTE: FOR ANSI COMMANDS THE FIRST COLUMN = 1 NOT 0
;*
;* INPUTS:
;* D = ADDRESS OF LINE
;*
EDITOR:	PUSH	D	; SAVE LINE
	; PRINT THE LINE
	MVI	A,EPROMPT
	RST	2	; SHOW EDIT MODE PROMPT
	LDAX	D	
	MOV	L,A	; LOW ORDER LINE #
	INX	D 
	LDAX	D	; HIGH ORDER
	MOV	H,A 
	SHLD	CURLIN	; SAVE LINE NUMBER BEING EDITED
	INX	D
	MVI	C,4	; PRINT 4 DIGIT LINE #
	CALL	PRTNUM
	MVI	A,' '	; FOLLOWED BY A BLANK 
	RST	2 
	MVI	A,CR	; AND THEN THE TEXT 
	CALL	PRTSTG	; D,E => END OF LINE+1 (AFTER <CR>)
	XCHG		; H,L => END OF LINE+1
	DCX	H	; H,L => END OF TEXT+1 (AT <CR>)
	SHLD	LINEND	; SAVE IT
	; CONVERT LINE NUMBER TO ASCII, MOVE TO BUFFER
	POP	D	; D,E => START OF LINE
	LDAX	D	; GET LINE NUMBER
	MOV	L,A
	INX	D
	LDAX	D
	MOV	H,A	; H,L = LINE NUMBER
	INX	D
	PUSH	D	; SAVE START OF TEXT
	MVI	D,1000 SHR 8
	MVI	E,1000 AND 255
	CALL	DIVIDE	; BC = HL / DE, HL = HL % DE
	XCHG		; DE = REMAINDER
	MOV	A,C	; GET THOUSANDS
	ADI	'0'	; CONVERT TO ASCII
	LXI	H,BUFFER
	MOV	M,A	; WRITE TO BUFFER
	INX	H
	SHLD	VARTMP	; SAVE BUFFER POINTER
	XCHG		; HL = REMAINDER
	MVI	D,0
	MVI	E,100
	CALL	DIVIDE	; BC = HL / DE, HL = HL % DE
	XCHG		; DE = REMAINDER
	MOV	A,C	; GET HUNDREDS
	ADI	'0'	; CONVERT TO ASCII
	LHLD	VARTMP	; GET BUFFER BACK
	MOV	M,A	; WRITE TO BUFFER
	INX	H
	SHLD	VARTMP	; AND SAVE BUFFER POINTER
	XCHG		; HL = REMAINDER
	MVI	D,0
	MVI	E,10
	CALL	DIVIDE	; BC = HL / DE, HL = HL % DE
	XCHG		; DE = REMAINDER
	MOV	A,C	; GET TENS
	ADI	'0'	; CONVERT TO ASCII
	LHLD	VARTMP	; GET BUFFER BACK
	MOV	M,A	; WRITE TO BUFFER
	INX	H
	MOV	A,E	; GET ONES
	ADI	'0'	; CONVERT TO ASCII
	MOV	M,A	; WRITE TO BUFFER
	INX	H
	MVI	A,' '
	MOV	M,A	; WRITE A SPACE TO THE BUFFER
	INX	H
	MOV	B,H	; MOVE H,L
	MOV	C,L	; TO B,C
	LHLD	LINEND	; RESTORE END OF TEXT+1 (AT <CR>)
	POP	D	; RESTORE START OF TEXT
	;
	; D,E => START OF TEXT
	; H,L => END OF TEXT
	; B,C => DESTINATION
	; COPY THE REST OF THE LINE TO THE BUFFER
	CALL	MVUP	; COPY LINE TO BUFFER
	PUSH	B	; SAVE POSITION AT END OF TEXT IN BUFFER
	MOV	H,B
	MOV	L,C	; HL = FIRST FREE POSITION AFTER TEXT
	MVI	D,BUFFER SHR 8
	MVI	E,BUFFER AND 255
	CALL	SUBDE	; HL = HL - DE
	MOV	C,L	; BUFFER COUNT IN C
	POP	H	; HL => END OF TEXT IN BUFFER (AT <CR>)

;
; EDIT LOOP
EDLOOP:	
	CALL	CIN	; GET CHARACTER
	CPI	ESC	; ESCAPE SEQUENCE?
	JNZ	CHKDEL	; NO, CHECK IF DEL CHARACTER
	CALL	CIN	; YES, GET NEXT CHARACTER
	CPI	'['	; START OF SEQUENCE (CSI)?
	JNZ	EDLOOP	; NO, IGNORE
	CALL	CIN	; YES, GET CODE

	CPI	'A'	; CURSOR UP?
	JNZ	TSTB	; NO
	JMP	EDERR	; YES, IGNORE <UP>

TSTB:	CPI	'B'	; CURSOR DOWN?
	JNZ	TSTC	; NO
	JMP	EDERR	; YES, IGNORE <DOWN>

TSTC:	CPI	'C'	; CURSOR RIGHT?
	JNZ	TSTD	; NO
	CALL	CHKEOL
	JZ	EDERR	; AT END OF LINE, EXIT
	INX	H	; INCREMENT POINTER
	CALL	RIGHT	; SHOW CURSOR MOVEMENT
	JMP	EDLOOP
;
TSTD:	CPI	'D'	; CURSOR LEFT?
	JNZ	TST1	; NO
	MOV	A,L	; GET BUFFER POINTER
	CPI	(BUFFER  + 5) AND 255
	JZ	EDERR	; AT START OF TEXT, EXIT
	DCX	H	; DECREMENT POINTER
	CALL	LEFT	; SHOW CURSOR MOVEMENT
	JMP 	EDLOOP
;
TST1:	CPI	'1'	; CURSOR HOME?
	JNZ	TST4	; NO
	CALL	CIN	; GET THE COMMAND
	CPI	'~'
	JNZ	TSTF1	; NOT HOME KEY, F1 KEY?
	JMP	EDERR	; YES, IGNORE <HOME>
;
TST4:	CPI	'4'	; CURSOR END?
	JNZ	EATCH	; NO
	CALL	CIN	; GET THE COMMAND
	CPI	'~'
	JNZ	EDERR	; NOT END KEY
	JMP	EDERR	; YES, IGNORE <END>
;
TSTF1:	CPI	'1'	; CHECK IF F1 KEY (EXIT)
	JNZ	EATCH	; NO, ERROR
	CALL	CIN	; GET TERMINATOR
	CPI	'~'
	JNZ	EDERR	; NOT F1 KEY
	
	; SET H,L TO END OF BUFFER
	LXI	H,BUFFER; POINT TO START OF BUFFER
	MOV	A,C	; ADD BUFFER COUNT
	ADD	L
	MOV	L,A
	MOV	A,H
	ACI	0
	MOV	H,A	; H,L -> END OF TEXT + 1
;	
EDITX:	MVI	A,CR
	MOV	M,A	; SAVE CR
	INX	H	; INCREMENT POINTER
;
	PUSH	H	; SAVE END OF LINE + 1 ON STACK FOR STORLN
	CALL	CRLF	; START NEW LINE ON TERMINAL
	LHLD	CURLIN	; RETURN WITH H,L = LINE NUMBER
	JMP	STORLN	; STORE LINE
;
EATCH:	CALL	CIN	; GET THE LAST CHARACTER
	JMP	EDERR	; TO IGNORE THE SEQUENCE
;
;
; CHECK FOR DELETE
CHKDEL:	CPI	DEL	; DELETE? (DELETE CHAR UNDER CURSOR)
	JNZ	CHKC
	
	CALL	CHKEOL
	JZ	EDERR	; AT END OF LINE, EXIT
	CALL	DELETE
	JMP	EDLOOP
;
; CHECK FOR A CONTROL CHARACTER
CHKC:	CPI	' '	; CONTROL?
	JNC	ECHO	; NO, ECHO
;
	CPI	CR	; CR?
	JNZ	TSTBK
	LXI	D,CEEOL	; YES
	CALL	PRTSTZ	; ERASE TO END OF LINE
	JZ	EDITX	; EXIT
;
TSTBK:	CPI	CTRH	; BACKSPACE?  (DELETE CHAR LEFT OF CURSOR)
	JNZ	EDERR	; NO, ERROR
	
	MVI	A,5	; OFFSET FOR LINE NUMBER + SPACE
	CMP	C	; CHECK IF START OF TEXT IN BUFFER
	JZ	EDERR	; YES, BEEP AND RETURN
	CALL	CHKEOL	; AT END OF BUFFER?
	JZ	TSTBK1	; YES, JUST DELETE AND RETURN	

	DCX	H	; DECREMENT BUFFER POINTER
	MVI	A,CTRH
	CALL	COUT	; MOVE CURSOR LEFT
	CALL	DELETE	; DELETE THE CHARACTER
	JMP	EDLOOP
;
TSTBK1:	DCX	H	; DECREMENT BUFFER POINTER
	DCR	C	; AND COUNT
	CALL	DELCL	; DELETE CHARACTER AT END OF LINE
	JMP	EDLOOP
;
; STORE THE CHARACTER AND SEND IT
ECHO:	CALL	INSERT	
	JMP	EDLOOP
;
; SEND A BEEP TO THE TERMINAL
EDERR:	MVI	A,BELL
	CALL	COUT
	JMP	EDLOOP
;
; END OF LOOP
;
; ==========================================
; EDITOR SUBROUTINES
;
; CHECK IF AT END OF LINE
CHKEOL:	MOV	A,C	; GET BUFFER COUNT (PTR + 1)
	ADI	BUFFER AND 255	; A = END OF BUFFER LSB
	CMP	L	; SAME AS BUFFER POINTER?
	RET		; SET FLAGS
;
; INSERT CHARACTER INTO BUFFER
; RE-WRITE THE LINE IF NECESSARY
; CHAR IN A
INSERT:	PUSH	PSW	; SAVE A
	MVI	A,BUFSIZ; END OF BUFFER?
	CMP	C
	JZ	INSERR	; YES, EXIT
;
	CALL	CHKEOL
	JZ	INSER3	; AT END OF LINE, JUST INSERT
;
	PUSH	H	; SAVE CURRENT BUFFER POINTER
	PUSH	D	; SAVE REGISTERS
	PUSH	B
;
	LXI	D,CSAV
	CALL	PRTSTZ	; SAVE THE CURSOR POSITION
	LXI	D,CEEOL
	CALL	PRTSTZ	; ERASE TO END OF LINE
;
	MVI	A,BUFFER AND 255
	ADD	C
	MOV	E,A	; D,E = POINTER TO LAST CHARACTER + 1
	MOV	D,H	
	SUB	L
	MOV	B,A	; B = COUNT OF CHARS TO MOVE
	STA	MOVCNT	; SAVE COUNT FOR LATER
	MOV	L,E	; H,L = WRITE PTR (1 PAST LAST CHAR)
	DCX	D	; DECREMENT READ PTR
			;   TO POINT TO LAST CHARACTER
; MOVE THE BUFFER UP
INSER1:	LDAX	D	; READ CHARACTER
	MOV	M,A	; STORE IN NEW POSITION
	DCX	D
	DCX	H
	DCR	B
	JNZ	INSER1
;	
	POP	B
	POP	D
	POP	H
;
; SAVE THE CHARACTER IN THE BUFFER
	POP	PSW	; GET CHARACTER BACK
	MOV	M,A	; SAVE IN BUFFER
;
; H,L NOW POINTS ABOVE THE INSERTED POSITION IN THE BUFFER
; RE-WRITE THE REST OF THE LINE
	PUSH	H	; SAVE REGISTERS AGAIN
	PUSH	D
	PUSH	B
	LDA	MOVCNT
	MOV	B,A	; B = COUNT + 1
	INR	B	; 
INSER2: MOV	A,M	; GET CHARACTER
	CALL	COUT	; WRITE OUT
	INX	H
	DCR	B
	JNZ	INSER2
;
	LXI	D,CUSAV
	CALL	PRTSTZ	; RESTORE THE CURSOR POSITION
	LXI	D,CRIGHT
	CALL	PRTSTZ	; AND MOVE ONE POSITION OVER
;	
	POP	B
	POP	D
	POP	H
	INX	H	; INCREMENT POINTER 
	INR	C	;   AND COUNT
	RET
	
; SAVE THE CHARACTER IN THE BUFFER AND EXIT
INSER3:	POP	PSW	; GET CHARACTER BACK
INSBUF:	MOV	M,A	; SAVE IN BUFFER
	INX	H	; INCREMENT POINTER
	INR	C	;   AND COUNT
	CALL	COUT	; SEND IT OUT
	RET
;
; INDICATE INSERT ERROR
INSERR:	POP	PSW
	MVI	A,BELL
	CALL	COUT
	RET
;
; DELETE CHARACTER FROM BUFFER
; AND RE-WRITE THE LINE IF NECESSARY
DELETE:	
	PUSH	H	; SAVE CURRENT BUFFER POINTER
	PUSH	D	; SAVE REGISTERS
	PUSH	B
;
	LXI	D,CSAV
	CALL	PRTSTZ	; SAVE THE CURSOR POSITION
;
	MVI	A,BUFFER AND 255
	ADD	C	; A = LAST CHAR + 1
	SUB	L
	SUI	1	; NUMBER OF CHARACTERS TO MOVE?
	JZ	DELET2	; NONE, JUST DELETE

	PUSH	PSW
	LXI	D,CEEOL
	CALL	PRTSTZ	; ERASE TO END OF LINE
	POP	PSW
	MOV	B,A	; B = # CHARS TO MOVE
	MOV	D,H
	MOV	E,L	; D,E = READ POINTER
	INX	D	; POINT TO CHAR NEXT TO CURRENT
;
;
; MOVE THE BUFFER DOWN AND RE-WRITE THE LINE
DELET1:	LDAX	D	; READ CHARACTER ABOVE CURRENT
	MOV	M,A	; STORE IN CURRENT POSITION
	CALL	COUT	; DISPLAY IT
	INX	D
	INX	H
	DCR	B
	JNZ	DELET1
	MVI	A,CR
	MOV	M,A	; SET FORMER LAST CHAR TO CR
;
	LXI	D,CUSAV
	CALL	PRTSTZ	; RESTORE THE CURSOR POSITION
	POP	B
	DCR	C	; DECREMENT COUNT
	POP	D
	POP	H
	RET
;
; DELETE LAST CHARACTER
DELET2:	
	POP	B
	DCR	C	; DECREMENT COUNT
	POP	D
	POP	H

	CALL	DELCH	; DELETE CHARACTER
	RET
;
;--------------------------------------
; TERMINAL SUB COMMANDS
;
; CURSOR COMMANDS	
;
RIGHT:	PUSH 	D
	LXI	D,CRIGHT
	CALL	PRTSTZ
	POP	D
	RET
;	
LEFT:	PUSH	D
	LXI	D,CLEFT
	CALL	PRTSTZ
	POP	D
	RET

; DELETE CHAR LEFT, DROP INTO DELCH
DELCL:	MVI	A,CTRH
	CALL	COUT
;
; DELETE CHAR UNDER CURSOR
DELCH:	MVI	A,' '
	CALL	COUT
	MVI	A,CTRH
	CALL	COUT
	RET
;
;**************************************************************
;* 
;* *** XMODEM routines *** 
;* 
;* (C) 2017 DAVID HUNTER
;*
;
; These allow for storing and loading of Tiny BASIC programs
; to another computer using XMODEM protocol
;
;================================================
; XMODEM SEND
; ENTRY:
; 	H,L = START OF DATA
;	D,E = END OF DATA
;
; REGISTER USAGE
; B = BLOCK NUMBER
; C = BLOCK COUNT
; D = TEMP
; E = CHECKSUM
; H,L = MEMORY POINTER
;
; ABORT WITH RESET SWITCH OR ^X
XSEND:	MVI	B,1		; SET BLOCK NUMBER START
	SHLD	PKTADD		; SET BEGIN ADDRESS FROM H,L
	XCHG
	SHLD	ENDADD		; SET END ADDRESS FROM D,E (NOW IN H,L)
;
; FILL PARTIAL PACKET WITH FFH
;
	MOV	A,L		; END ADDRESS LOWER BYTE
	SUB	D		; A = (ENDADD - PKTADD) % 256
	MOV	C,A		; SAVE IN C
	MVI	A,80H
	SUB	C		; A = NUMBER OF FILLER BYTES
	MOV	C,A		; C = COUNT OF FILLER BYTES
				; HL -> END ADDRESS
	MVI	A,0FFH		; SET FILLER BYTE
FILLP:	INX	H		; SET FILL ADDRESS
	MOV	M,A		; FILL BYTE
	DCR	C		; DECREMENT COUNT
	JNZ	FILLP		; FILL PARTIAL PACKET WITH FFH
;
GETCHR:	CALL	XINP		; GET A CHARACTER
	CPI	NAK
	JZ	SENDP		; IF NAK, BEGIN SENDING
	CPI	CAN		; IF CANCEL, EXIT
	RZ
	JMP	GETCHR		; ELSE, IGNORE
;
SENDP:	CALL	OUTPKT		; SEND A PACKET
GETRSP:	CALL	WAITCH		; GET RESPONSE
	ORA	A		; SET FLAGS
	JZ	SENDP		; TIMEOUT, SEND AGAIN
	CPI	NAK		; NAK?
	JZ	SENDP		; YES, SEND AGAIN
	CPI	ACK		; ACK?
	JNZ	GETRSP		; NO, WAIT FOR ANOTHER CHARACTER
;
; SUCCESS, POINT TO THE NEXT PACKET
;
	LDA	PKTADD		; PKTADD = PKTADD + BLKSIZ
	ADI	BLKSIZ
	STA	PKTADD
	LDA	PKTADD+1
	ACI	0
	STA	PKTADD+1
	INR	B		; INCREMENT BLOCK NUMBER
;
; CHECK IF DONE
;
	LHLD	PKTADD
	XCHG
	LHLD	ENDADD
	MOV	A,L
	SUB	E
	MOV	L,A
	MOV	A,H
	SBB	D
	MOV	H,A		; H,L = ENDADD - PKTADD
	JM	SENDX		; IF PKTADD > ENDADD, EXIT
	ORA	L		; PKTADD = ENDADD?
	JNZ	SENDP		; NO, CONTINUE
;
; DONE, EXIT
;
SENDX:	MVI	A,EOT
	CALL	COUT		; SEND END OF TEXT MESSAGE
SENDX1:	CALL	WAITCH		; WAIT FOR RESPONSE
	ORA	A		; SET FLAGS
	RZ			; EXIT IF TIMEOUT
	CPI	NAK		; NAK?
	JZ	SENDX		; YES, SEND EOT AGAIN
	CPI	ACK		; ACK?
	JNZ	SENDX1		; NO, WAIT FOR ACK OR TIMEOUT
	RET			; YES, RETURN
;
; OUTPUT A PACKET
;
OUTPKT:	MVI	C,BLKSIZ 	; SET BLOCK COUNT
	LHLD	PKTADD		; POINT TO DATA BLOCK
	MVI	E,0		; CLEAR CHECKSUM
	MVI	A,SOH
	CALL	COUT		; SEND START OF PACKET
	MOV	A,B		; GET BLOCK NUMBER
	CALL	COUT		; SEND IT
	CMA			; INVERT BLOCK NUMBER
	CALL	COUT		; SEND IT
;
OUTDAT:	MOV	A,M		; GET BYTE
	CALL	COUT		; SEND IT
	ADD	E
	MOV	E,A		; UPDATE CHECKSUM
	INX	H		; POINT TO NEXT BYTE
	DCR	C
	JNZ	OUTDAT		; CONTINUE IF NOT DONE
;
	MOV	A,E
	CALL	COUT		; SEND CHECKSUM
	RET			; AND EXIT
;
;================================================
; XMODEM RECEIVE
; ENTRY:
; 	H,L = START OF DATA
;
; REGISTER USAGE
; B = BLOCK NUMBER
; C = BLOCK COUNT
; D = TEMP
; E = CALCULATED CHECKSUM
; H,L = MEMORY POINTER
;
; ABORT WITH RESET SWITCH
; IF SUCCESSFUL, UPDATE THE TXTUNF POINTER IN BASIC
; IF ERROR, A '!' WILL BE PRINTED
;
XRECV:	SHLD	PKTADD		; SET BEGIN ADDRESS FROM H,L
	MVI	B,1		; SET BLOCK NUMBER START
;
NEWPKT:	XRA	A
	STA	RETRY		; CLEAR RETRY COUNT
	MVI	C,BLKSIZ 	; SET BLOCK COUNT
	LHLD	PKTADD		; POINT TO DATA BLOCK
	MVI	E,0		; CLEAR CHECKSUM	
;
XRCV2:	MVI	A,MAXTIM
	STA	TIMCNT		; SET TIMEOUT COUNT
;
XRCV3:	CALL	WAITCH		; WAIT FOR CHARACTER
	CPI	SOH		; START OF PACKET?
	JZ	XRCV4		; YES, GET PACKET
;	
	CPI	EOT		; END?
	JZ	RECVX		; YES, SEND ACK AND EXIT
;
	ORA	A		; SET FLAGS
	JZ	XTMOUT		; TIMEOUT?
	JMP	XRCV3		; NO, GET ANOTHER CHARACTER
;
XRCV4:	CALL	INPKT		; YES, GET THE PACKET
	JNZ	BADRCV		; BAD PACKET
;
	LDA	PKTADD		; GOOD PACKET
	ADI	BLKSIZ
	STA	PKTADD
	LDA	PKTADD+1
	ACI	0
	STA	PKTADD+1	; PKTADD = PKTADD + BLKSIZ
	INR	B		; INCREMENT BLOCK NUMBER
	MVI	A,ACK		; SEND ACK FOR PACKET
	CALL	COUT
	JMP	NEWPKT		; WAIT FOR NEXT PACKET
;
XTMOUT:	LDA	TIMCNT		; TIMEOUT OCCURRED
	DCR	A
	STA	TIMCNT		; DECREMENT TIMEOUT COUNT
	JNZ	XRCV3		; MAX TIMEOUT NOT REACHED
;
BADRCV:	MVI	A,NAK		; SEND NAK
	CALL	COUT
	LDA	RETRY		; BAD PACKET
	INR	A
	STA	RETRY		; INCREMENT RETRY COUNT
	CPI	MAXTRY		; RETRY = MAX?
	JZ	XERROR		; YES, ERROR
	JC	XRCV2		; NO, KEEP TRYING
				; FALL THROUGH IF RETRY > MAX
;
XERROR:	MVI	A,'!'		; RETRY EXCEEDED
	CALL	COUT
	RET			; AND EXIT
;
RECVX:	MVI	A,ACK
	CALL	COUT		; SEND ACK
	DCX	H		; POINT TO LAST BYTE RECEIVED
	CALL	UPDTXT		; SET THE TXTUNF POINTER
	RET			; DONE
;
; INPUT A PACKET
; NOTE, SOH HAS ALREADY BEEN RECEIVED
; RETURN 0 IN A IF BLOCK NUMBERS AND CHECKSUM ARE GOOD
; 
INPKT:	CALL	XINP		; GET BLOCK NUMBER
	XRA	B		; COMPARE WITH BLOCK NUMBER
	MOV	D,A		; SAVE IN CHECK FLAG
	CALL	XINP		; GET INVERTED BLOCK NUMBER
	CMA			; INVERT
	XRA	B		; COMPARE WITH BLOCK NUMBER
	ORA	D		; COMBINE WITH CHECK FLAG
	MOV	D,A		; AND SAVE
;
; READ BLOCK OF DATA INTO MEMORY
INDAT:	CALL	XINP		; GET BYTE
	MOV	M,A		; SAVE BYTE
	ADD	E		; ADD TO CHECKSUM
	MOV	E,A		; AND SAVE
	INX	H		; POINT TO NEXT BYTE
	DCR	C		; DECREMENT COUNT
	JNZ	INDAT
;
	CALL	XINP		; GET CHECKSUM
	XRA	E		; COMPARE WITH CALCULATED CHECKSUM
	ORA	D		; COMBINE WITH CHECK FLAG AND RETURN IN A
	RET
;
; UPDATE TXTUNF VALUE FROM RECEIVED DATA
; INPUT: H,L = END OF DATA
;
UPDTXT:	MOV	A,M		; GET BYTE
	CPI	0FFH		; FF?
	JNZ	UPDEX		; NO, END OF PROGRAM FOUND
	DCX	H		; YES, DECREMENT ADDRESS
	JMP	UPDTXT
;	
UPDEX:	INX	H		; POINT TO LAST EMPTY BYTE
	SHLD	TXTUNF		; SAVE POINTER
	RET
;	
;================================================
; WAIT FOR A CHARACTER WITH TIMEOUT
; RETURN 0 IF TIMEOUT
; ELSE RETURN THE CHARACTER
;
; THE POLLING LOOP OFFSETS THE CAPTURE OF THE MID BIT
; 99 CLOCKS = 40.28us WHICH IS ~10% OF A BIT TIME OF 2400 BPS
; THEREFORE SAMPLING WILL BE AT THE 60% POINT OF A BIT
; AS A WORST CASE WHICH SHOULD NOT BE A PROBLEM
;
WAITCH:	MVI	A,ONESEC AND 255 ; SET TIMEOUT
	STA	TIMOUT
	MVI	A,ONESEC SHR 8
	STA	TIMOUT+1
WAITLP:	RIM			; 99 CLOCKS IN LOOP = 40.28us
	ORA	A		; SEE IF DATA RECEIVED
	JP	XINP		; YES, GET THE BYTE
;	
	PUSH	H		
	LHLD	TIMOUT		; DECREMENT TIMEOUT
	DCX	H
	SHLD	TIMOUT
	MOV	A,L
	ORA	H		; CHECK IF TIMEOUT = 0
	POP	H
	JNZ	WAITLP
	RET			; RETURN 0 IF TIMEOUT

;================================================
; MODIFIED "BIT-BANG" SERIAL INPUT FOR XMODEM
;
; ADAPTED FROM THE INTEL MCS-80/85 USER'S MANUAL
; RETURNS THE INPUT BYTE IN ACC
;
XINP:	PUSH	B
	PUSH	H
	MVI	B,9		; 8 BITS + STOP
XINP1:	
	RIM			; GET SERIAL INPUT
	ORA	A		; SET/CLEAR SIGN FLAG IN PSW
	JM	XINP1		; WAIT FOR START BIT
;
	MVI	L,HALFBIT 
XINP2:	DCR	L		; WAIT UNTIL THE MIDDLE OF THE START BIT
	JNZ	XINP2
	NOP
;
XINP3:	MVI	L,FULLBIT 	; WAIT ONE BIT TIME
XINP4:	DCR	L
	JNZ	XINP4
	NOP
	NOP
	RIM			; GET DATA BIT
	RAL
	DCR	B
	JZ	XINP5
	MOV	A,C
	RAR
	MOV	C,A
	NOP			; NEEDED TO HAVE EQUAL # CLOCKS WITH COUT
	JMP	XINP3
;
XINP5:	MOV	A,C		; GET BYTE INTO ACC
	POP	H
	POP	B
	RET
;
;**************************************************************
;* 
;* *** OUTC *** & CHKIO ****!
;* THESE ARE THE ONLY I/O ROUTINES IN TBI. 
;* 'OUTC' IS CONTROLLED BY A SOFTWARE SWITCH 'OCSW'.  IF OCSW=0
;* 'OUTC' WILL JUST RETURN TO THE CALLER.  IF OCSW IS NOT 0, 
;* IT WILL OUTPUT THE BYTE IN A.  IF THAT IS A CR, A LF IS ALSO
;* SENT OUT.  ONLY THE FLAGS MAY BE CHANGED AT RETURN, ALL REG.
;* ARE RESTORED. 
;* 
;* 'CHKIO' CHECKS THE INPUT.  IF NO INPUT, IT WILL RETURN TO 
;* THE CALLER WITH THE Z FLAG SET.  IF THERE IS INPUT, Z FLAG
;* IS CLEARED AND THE INPUT BYTE IS IN A.  
;* IF INTERRUPTS ARE ENABLED, THE INTERRUPTS ARE DISABLED AND 
;* RE-ENABLED AROUND THE INPUT CALL
;* IF THE INPUT IS A CONTROL-O, THE 'OCSW' SWITCH IS 
;* COMPLEMENTED, AND Z FLAG IS RETURNED. 
;* A CONTROL-C WILL CAUSE A RESTART
;*
;* 'CKABRT' CHECKS THE ABORT FLAG SET BY THE INTERRUPT
;* IF A CONTROL-C WAS DETECTED BY THE INTERRUPT,
;* RESTART TBI
;* 
;* OUTC:PUSH	PSW	;THIS IS AT LOC. 10H 
;*	LDA	OCSW	;PRINT CHARACTER ONLY
;*	ORA	A	;IF OCSW SWITCH IS ON
;*	JMP	OC2	;REST OF THIS IS AT OC2
OC2:	JNZ	OC3	;IT IS ON, CONTINUE
	POP	PSW	;IT IS OFF 
	RET		;RESTORE AF AND RETURN 
OC3:	POP	PSW	;GET OLD A BACK
	CALL	COUT
	CPI	CR 	;WAS IT A 'CR'?
	RNZ		;NO, DONE
	MVI	A,LF	;YES, LOAD A LINEFEED
	CALL	COUT	;AND SEND
	MVI	A,CR	;GET CR BACK IN A
	RET		;DONE AT LAST
;*
;* THERE IS NO STATUS TO CHECK, THE CALL TO CIN BLOCKS
;*
CHKIO:  RIM		;GET THE INTERRUPT STATUS
	ANI	IEFLG	;CHECK THE INTERRUPT ENABLE FLAG
	JZ	CI0	;INTERRUPTS NOT ENABLED, JUST READ THE CHARACTER
			;OTHERWISE,
	DI		;DISABLE INTERRUPTS TO READ FROM THE SERIAL PORT
	CALL	CIN	;WAIT FOR BYTE FROM TERMINAL
	EI		;INTERRUPTS RE-ENABLED
	RET
;*
CI0:	CALL	CIN	;CALL WITHOUT CHANGING INTERRUPTS
	RET
;*
;* CHECK IF ABORT FLAG WAS SET BY THE INTERRUPT
;*
CKABRT:	LDA	ABORTF
	ORA	A	;SET FLAGS
	RZ		;RETURN IF FLAG IS NOT SET
	JMP	RSTART	;YES, RESTART
;*
;*
;*
;*
;*
;*
;*
;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
; START OF THE ALTAIR 8800B TURNKEY PROM MONITOR
; RETYPED AND ADAPTED FROM ORIGINAL SOURCE:
; altair(TM) 8800b Turnkey PROM Monitor User's Guide
; (c) 1977, MITS, Inc
; 
;
; Prompt:  '.'
;
; Commands:
; 	Mxxxxxx		- change memory location xxxxxx (octal)
;			- enter 3 octal digits for new data
;			- press <SPACE> to skip to next location
;			- any other character to exit
;
;	Dxxxxxx xxxxxx	- dump data (in octal) from start to end address
;			- modified from original to be more of a "standard" dump
;			- and not the Altair loader format
;			- DH 03/11/18
;
;	Jxxxxxx		- jump to location
;
;
; ALL VALUES ARE IN OCTAL
;
;****************************************************************
;*                                                              *
;*  THIS IS A 256 BYTE PROM MONITOR FOR USE WITH THE ALTAIR     *
;*  8800B TURNKEY MODULE.  THIS MONITOR PROVIDES THE USER WITH  *
;*  THE FOLLOWING FUNCTIONS:                                    *
;*                                                              *
;*      1)  MEMORY EXAMINE AND CHANGE FUNCTION                  *
;*              YOU CAN EXAMINE AND CHANGE THE CONTENTS OF ANY  *
;*              VALID MEMORY LOCATION                           *
;*      2)  MEMORY DUMP FUNCTION                                *
;*              YOU CAN DISPLAY THE MEMORY VALUES BETWEEN ANY   *
;*              TWO VALID MEMORY LOCATIONS (changed from orig)  *
;*      3)  JUMP TO FUNCTION                                    *
;*              YOU CAN CAUSE THE MONITOR TO JUMP TO ANY        *
;*              LOCATION AND START EXECUTING THE PROGRAM THERE  *
;*                                                              *
;*  THE MONITOR CAN BE REENTERED FROM THE USER'S PROGRAM        *
;*  SO THAT THE FEATURES OF THE MONITOR ARE ALWAYS AVAILABLE    *
;*  TO ANY USER PROGRAM.                                        *
;*                                                              *
;****************************************************************
;
;MITS TURNKEY MONITOR
;C.W. VERTREES		01/13/77
;REVISED		01/17/77
;			01/19/77
;			01/20/77
; Adapted for Altaids Computer by D. Hunter	3/11/2018
;
;MONITOR STARTS AT THIS LOCATION (DIFFERENT FROM ALTAIR)
	ORG	0F00H		; start at top of first 4K
;
;
;MONITOR CONTROL STRUCTURE
;
TURMON:	LXI	SP,STACK	;LOAD STACK
	CALL	NEWLN		;FORMAT OUTPUT
	MVI	A,APROMPT	;HELLO MONITOR
	CALL	OUTCHK
	CALL	INCH		;WHAT TO DO?
	CPI	'M'
	JZ	MEM		;DO MEMORY EXAMINE
	CPI	'D'
	CZ	DMP		;DO A MEMORY DUMP
	CPI	'J'
	JNZ	TURMON		;NOT A VALID CMD
	CALL	OCTL6		;DO JUMP, GET ADDR
	PCHL
;
;THIS CONTROL STRUCTURE HANDLES THE MEMORY
;EXAMINE AND CHANGE FUNCTION
;
MEM:	CALL	OCTL6		;GET ADDRESS
	DB	076Q		;"MVI A," SKIP NEXT (BOMB A)
CONT:	INX	H		;INCREMENT ADDRESS
	CALL	NEWLN		;NEWLINE
	MOV	D,H		;STORE ADDRESS IN D/E
	MOV	E,L
	CALL	PRINT6		;PRINT ADDRESS
	LDAX	D		;LOAD DATA
	MOV	H,A
	CALL	PRINT3		;PRINT DATA BYTE
	CALL	OCTL3		;GET NEW DATA
	XCHG			;RESTORE ADDRESS
	JC	CONT		;NO NEW DATA
	MOV	M,A		;STORE DATA
	CMP	M		;COMPARE DEPOSIT
	JZ	CONT		;OK, DO NEXT
;
ERR:	MVI	A,'?'		;FLAG BAD DEPOSIT
	CALL	OUTCHK		;PRINT "?"
	JMP	TURMON		;RETURN TO MONITOR
;ERROR CONDITIONS RETURN TO MONITOR VIA "ERR"
;
;THIS CONTROL STRUCTURE RUNS THE MEMORY DUMP FUNCTION
;
DMP:	CALL	OCTL6		;GET START
	XCHG			;STORE IN D/E
	CNC	SPC
	CALL	OCTL6		;GET END IN H/L
	CALL	NEWLN
;
	MOV	A,L		;SUB START FROM END
	SUB	E
	MOV	L,A
	MOV	A,H
	SBB	D
	MOV	H,A		;HL CONTAINS TOT BYTES
	INX	H		;INCLUDE END ADDRESS
;
NXTLIN:	
	XCHG
	PUSH	H
	CALL	PRINT6		;PRINT ADDRESS
	POP	H
	XCHG
DATA:	LDAX	D		;GET DATA BYTE
	PUSH	H
	MOV	H,A
	CALL	PRINT3		;PRINT IT
	POP	H
	INX	D		;INCREM ADDR
	DCX	H		;TOTBYTES = TOTBYTES-1
	MOV	A,H		;THROUGH W/ALL BYTES?
	ORA	L
	JZ	NEWLN		;SEND LAST CRLF AND EXIT
	MOV	A,E		;GET ADDRESS LSB
	ANI	007Q		;EIGHTH BYTE?
	JNZ	DATA		;NO, KEEP PRINTING
	CALL	NEWLN		;YES, PRINT CRLF
	JMP	NXTLIN		;AND A NEW ADDRESS
;
;THIS SUBROUTINE BUILDS 3/6 OCTAL DIGITS IN H&L
;
;SPECIAL RETURN PROVIDED BY A "SPACE", CARRY BIT SET
;ONLY VALID OCTAL OR "SPACE" ACCEPTED, ALL OTHER FLAGGED AND
;CONTROL RETURNS TO THE MONITOR
;
OCTL6:	DB	006Q		;LOAD B WITH 6, SKIP NEXT
OCTL3:	DB	006Q		;LOAD B WITH 3
	DB	003Q
	LXI	H,0		;CLEAR H/L FOR LESS THAN 6 DIG RET
AGN:	CALL	INCH		;GET CHARACTER
	MOV	C,A		;STORE IN C
	CPI	' '		;COMPARE TO "SPACE"
	STC			;SET THE CARRY
	RZ			;RETURN IF "SPACE"
	ANI	270Q		;TEST FOR VALID OCTAL
	XRI	060Q
	JNZ	ERR		;BAD, FLAG & RET TO MON
	MOV	A,C		;RESTORE CHAR
	ANI	007Q		;STRIP ASCII
	DAD	H		;SHIFT H&L LEFT 3 BITS
	DAD	H
	DAD	H
	ADD	L
	MOV	L,A		;PUT OCTAL IN H
	DCR	B		;THROUGH ?
	JNZ	AGN		;NO, DO AGAIN
	RET			;YES, NORM RETURN
;
;THIS SUBROUTINE PRINTS 3 OCTAL DIGITS FROM H
;OR 6 DIGITS FROM H AND L
;
;DIGITS ARE FOLLOWED BY A SPACE
;
PRINT6:	MVI	B,6		;LOAD CNTR W/6
	XRA	A		;CLEAR A
	JMP	NEXT1		;SHIFT ONE BIT (BIT 15)
PRINT3:	MVI	B,3		;LOAD CNTR W/3
	DB	346Q		;SKIP NEXT, SHIFT 2 BITS
NEXT3:	DAD	H		;SHIFT H/L LEFT 3 INTO A
	RAL
	DAD	H
	RAL
NEXT1:	DAD	H
	RAL
	ANI	007Q		;STRIP OFF OCTAL
	ORI	060Q		;ADD ASCII
	CALL	OUTCHK		;PRINT IT
	DCR	B		;THROUGH ?
	JNZ	NEXT3		;NO, SHIFT NEXT THREE	
SPC:	MVI	A,040Q		;YES, PRINT SPACE
	JMP	OUTCHK		;AND RETURN

;RETURN TO CALLING PROG THROUGH OUTCHK
;
;THIS SUBROUTINE WILL INPUT A CHARACTER, STRIP
;PARITY AND AUTOMATICALLY ECHO THE CHARACTER.
;IT WILL ALSO OUTPUT A CHARACTER.
;
INCH:	CALL	INPUTT
	ANI	177Q		;STRIP PARITY
OUTCHK:	CALL	OUTT
	RET			;FROM WHENCE YE CAME
;

;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
; START OF THE 8085 MONITOR
; (c) 2018 David R. Hunter
;
	ORG	1000H	; start of monitor at second 4k boundary
;
; MONITOR JUMP TABLE
;
START:	JMP	COLD	; COLD START
WSTART:	JMP	RSTART	; BASIC WARM START
;
; VECTORS TO USEFUL ROUTINES (ENTER WITH CALL)
;
COUT:	JMP	OUTT	; OUTPUT CHAR IN A TO SERIAL PORT
CIN:	JMP	INPUTT	; INPUT CHAR FROM SERIAL PORT TO A
PRTWD:	JMP	PUTHL	; PRINT H,L IN HEX
PRTBY:	JMP	PUTHEX	; PRINT BYTE IN C IN HEX
GETWD:	JMP	GETW	; GET HEX WORD IN H,L
GETBY:	JMP	GETB	; GET HEX BYTE IN A
PIN:	JMP	IPORT	; GET DATA FROM INPUT PORT
POUT:	JMP	OPORT	; SEND DATA TO OUTPUT PORT
DSPREG:	JMP	DREGS	; DISPLAY REGISTERS
PUTSTR:	JMP	SENDM	; PRINT NULL TERMINATED STRING IN D,E
;
;
;================================================
; COLD START
;
COLD:	LXI	SP,STACK	; SET STACK POINTER
	MVI	A,0C0H
	SIM			; ENABLE SERIAL PORT, SET TXD HIGH
	LXI	D,SIGNON	; SHOW SIGN ON MESSAGE
	CALL	SENDM
	
WARM:	LXI	SP,STACK	; WARM START, CLEAR STACK	
;
; GET COMMAND AND JUMP TO APPROPRIATE ROUTINE
MAIN:	CALL	NEWLN
	MVI	A,PROMPT
	CALL	OUTT		; SEND PROMPT
	CALL	GETCHE		; GET COMMAND AND ECHO
	ANI	5FH		; CONVERT TO UPPER CASE
	SUI	'A'		; A-Z?
	JC	ERROR
	CPI	'Z'-'A'+1
	JNC	ERROR
	
	ADD	A		; CONVERT TO WORD OFFSET
	LXI	H,CMDTBL	; POINT TO COMMAND TABLE
	MVI	D,0
	MOV	E,A		; OFFSET IN D,E
	DAD	D		; ADD OFFSET TO TABLE
	MOV	E,M		; GET ADDRESS
	INX	H
	MOV	D,M
	XCHG			; PUT IN H,L
	PCHL			; JUMP TO COMMAND	
;	
; SEND "?" AS ERROR, AND RETURN TO MONITOR
ERROR:	MVI	A,'?'
	CALL	OUTT
	JMP	WARM
;
; COMMAND TABLE
CMDTBL:	DW	ALTAIR		; A
	DW	TBASIC		; B
	DW	WARM		; C
	DW	DUMP		; D
	DW	ENTER		; E
	DW	WARM		; F
	DW	GO		; G
	DW	HELP		; H
	DW	INPRT		; I
	DW	WARM		; J
	DW	WARM		; K
	DW	LOAD		; L
	DW	WARM		; M
	DW	WARM		; N
	DW	OUTPRT		; O
	DW	WARM		; P
	DW	WARM		; Q
	DW	REGS		; R
	DW	WARM		; S
	DW	TRACE		; T
	DW	WARM		; U
	DW	WARM		; V
	DW	WARM		; W
	DW	WARM		; X
	DW	WARM		; Y
	DW	WARM		; Z
;
; ALTAIR MONITOR
; CMD: A
; JUMP TO ALTAIR TURNKEY MONITOR (OCTAL I/O)
ALTAIR:	CALL	NEWLN
	JMP	TURMON
;
; TINY BASIC
; CMD: B
; JUMP TO TINY BASIC
TBASIC: CALL	NEWLN
	JMP	BASIC
;
; DUMP MEMORY
; CMD: Dnnnn mmmmm
; DISPLAY MEMORY FROM nnnn TO mmmm, BOTH HEX AND ASCII
;
DUMP:	CALL	GETW	; GET START ADDRESS
	XCHG		; SAVE IN D,E
	CALL	SPACE
	CALL	GETW	; GET END ADDRESS
	XCHG		; START IN H,L END IN D,E
DUMP1:	CALL	NEWLN
	MVI	B,RLEN	; 16 BYTES PER LINE
	CALL	PUTHL	; DISPLAY ADDRESS
	PUSH	H	; SAVE ADDRESS
;
DUMP2:	MVI	A,03H	; CHECK IF ADDRESS IS MODULO 4
	ANA	L
	JNZ	DUMP3
	CALL	SPACE	; PRINT SPACE SEPARATOR EVERY 4 BYTES
DUMP3:	MOV	C,M	; GET BYTE
	CALL	PUTB	; DISPLAY IT
	DCR	B	; DECREMENT COUNT
	JZ	DUMP7	; EXIT IF END OF LINE
;
	MOV	A,D
	CMP	H	; CHECK IF AT LAST ADDRESS
	JNZ	DUMP4
	MOV	A,E
	CMP	L
	JZ	DUMP5	; AT END ADDRESS, FILL OUT REST OF LINE
DUMP4:	INX	H	; NEXT BYTE
	JMP	DUMP2	; NOT AT END OF LINE
;
; FILL OUT WITH SPACES IF NOT AT END OF LINE
DUMP5:	INX	H	; KEEP MOVING POINTER
	MVI	A,03H	; CHECK IF ADDRESS IS MODULO 4
	ANA	L
	JNZ	DUMP6
	CALL	SPACE	; PRINT SPACE SEPARATOR EVERY 4 BYTES
DUMP6:	CALL	SPACE	; PRINT FILLER SPACES FOR EMPTY BYTES
	CALL	SPACE
	CALL	SPACE
	DCR	B
	JNZ	DUMP5
;
; PRINT ASCII DATA
DUMP7:	POP	H	; GET START ADDRESS BACK
	CALL	SPACE	; SEPARATE DATA FROM ASCII
	CALL	SPACE
	MVI	B,RLEN	; RESET COUNTER
DUMP8:	MOV	A,M	; GET BYTE
	CPI	20H	; CHECK IF PRINTABLE ASCII (20H - 7EH)
	JC	DUMP9
	CPI	7FH
	JC	DUMPA	; PRINTABLE, SKIP NEXT LINE
DUMP9:	MVI	A,'.'	; PRINT '.' IF UNPRINTABLE
;
DUMPA:	CALL	OUTT
	MOV	A,D
	CMP	H	; CHECK IF AT LAST ADDRESS
	JNZ	DUMPB
	MOV	A,E
	CMP	L
	JZ	MAIN	; AT END, EXIT
DUMPB:	INX	H	; NEXT BYTE
	DCR	B	; DECREMENT COUNT
	JNZ	DUMP8
	JMP	DUMP1	; CONTINUE
;
; ENTER MEMORY DATA
; CMD: Ennnn
; ENTER HEX DATA INTO MEMORY STARTING AT nnnn, 
; <SPACE> TO SKIP, INVALID HEX DIGIT TO EXIT
ENTER:	CALL	GETW	; GET ADDRESS IN H,L
ENTLP:	CALL	NEWLN
	CALL	PUTHL	; DISPLAY ADDRESS
	MOV	C,M	; GET CURRENT BYTE VALUE
	CALL	PUTB	; DISPLAY IT
	CALL	SPACE	; PRINT SPACE
	CALL	GETCHE	; GET CHAR
	CPI	' '	; SPACE?
	JZ	SKIP	; YES, SKIP AHEAD
;
	CALL	CHKHEX	; SEE IF VALID CHARACTER
	RAL
	RAL
	RAL
	RAL
	ANI	0F0H	; MASK OFF UPPER BITS
	MOV	C,A	; SAVE
	CALL	GETHEX	; GET LOWER NIBBLE
	ORA	C	; BRING IN UPPER BITS
	MOV	M,A	; STORE DATA
	CMP	M	; DID IT GET SAVED?
	JNZ	ERROR	; NO, FLAG AS ERROR
;	
SKIP:	INX	H	; NEXT ADDRESS
	JMP	ENTLP
;
; GO TO MEMORY LOCATION
; CMD: Gnnnn
; EXECUTE FROM ADDRESS nnnn
GO:	CALL	GETW	; GET ADDRESS IN H,L
	CALL	NEWLN
	PCHL		; GO THERE
;
; HELP
; CMD: H
; DISPLAY COMMANDS
HELP:	LXI	D,HLPMSG
	CALL	SENDM
	JMP	MAIN
;
; READ INPUT PORT 60H
; CMD: I
INPRT:	CALL	NEWLN
	CALL	IPORT
	CALL	PUTBYT	; PRINT 
	JMP	MAIN
;	
IPORT:	IN	GPI	; READ DATA, RETURN IN ACC
	RET
;
; LOAD INTEL HEX FILE
; CMD: L
; PRINT A '.' FOR EVERY RECORD RECEIVED SUCCESSFULLY
; PRINT A '?' FOR EVERY CHECKSUM ERROR
; PRINT A '!' WHEN DONE
; REGISTER USAGE:
;	B = RECORD TYPE
;	C = COUNT
;	E = CHECKSUM
;	H,L = ADDRESS
;
LOAD:	CALL	NEWLN	; SHOW READY WITH NEWLINE
LOAD1:	CALL 	GETCHE	; GET CHARACTER
	CPI	':'	; START OF RECORD?
	JNZ	LOAD1
	CALL	GETB	; GET COUNT
	MOV	E,A	; START CHECKSUM
	MOV	C,A	; SAVE COUNT
	CALL	GETB	; GET ADDRESS HIGH BYTE
	MOV	H,A
	ADD	E
	MOV	E,A	; ADD TO CHECKSUM
	CALL	GETB	; GET ADDRESS LOW BYTE
	MOV	L,A
	ADD	E
	MOV	E,A	; ADD TO CHECKSUM
	CALL	GETB	; GET TYPE
	MOV	B,A
	ADD	E
	MOV	E,A
	MOV	A,B	; GET TYPE BACK
	ORA	A	; SET FLAGS
	JNZ	ENDLD	; IF TYPE != 0, END

LOADLP:	CALL	GETB	; GET DATA BYTE
	MOV	M,A	; SAVE IN MEMORY
	INX	H	; MOVE POINTER
	ADD	E
	MOV	E,A	; ADD TO CHECKSUM
	DCR	C	; MORE BYTES?
	JNZ	LOADLP

	CALL	GETB	; GET CHECKSUM
	ADD	E
	JNZ	BADLD	; A GOOD CHECKSUM SHOULD RESULT IN 0 IN ACC
	MVI	A,'.'	; OK MESSAGE
	JMP	NEXTLD
	
BADLD:	MVI	A,'?'	; ERROR MESSAGE
NEXTLD:	CALL	OUTT
	MVI	A,LF
	CALL	OUTT
	JMP	LOAD1

ENDLD:	CALL	GETB	; GET CHECKSUM
	MVI	A,'!'	; DONE
	CALL	OUTT
	DCX	H	; BACK UP TO LAST ADDRESS WRITTEN
	CALL	PUTW	; PRINT LAST ADDRESS WRITTEN

	JMP	MAIN
;
; OUTPUT TO PORT 61H
; CMD: O bb
OUTPRT:	CALL	GETB	; GET VALUE
	CALL	OPORT
	JMP	MAIN

OPORT:	OUT	GPO	; SEND TO PORT, VALUE IN ACC
	RET
;
; DISPLAY REGISTERS
; SAVE REGISTERS ON THE STACK, DISPLAY THEM AND RESTORE
; CMD:  R
;
REGS:	CALL	DREGS	; PUT PC ON STACK
	JMP	MAIN

DREGS:	PUSH	H	; SAVE REGISTERS ON STACK
	PUSH	D
	PUSH	B
	PUSH	PSW
	LXI	H,8
	DAD	SP
	PUSH	H	; SAVE SP FROM ENTRY TO REGS
	LXI	D,REGLST ; REGISTER LIST
	CALL	SENDM	; SEND REGISTER DISPLAY HEADER
;	
	POP	H	; GET SAVED SP INTO H,L
	PUSH	H	; AND SAVE IT AGAIN
;
;	THE STACK IS NOW:
;		9: RETURN ADDRESS <= (SAVED SP)
;		7: H,L
;		5: D,E
;		3: B,C
;		1: A
;		0: F		
;		-1: SAVED SP	
;		-2: 		<= CURRENT SP
;
	INX	H	; OFFSET TO UPPER BYTE OF PC OF CALLER
	MOV	C,M	; GET UPPER BYTE OF PC
	CALL	PUTBYT	; PRINT IT WITHOUT A SPACE
	DCX	H	; MOVE POINTER
	MOV	C,M	; GET LOWER BYTE OF PC
	CALL	PUTBYT	; PRINT IT
;	
	POP	H	; GET SAVED SP
	CALL	PUTW	; PRINT
; STACK IS NOW POINTING TO PSW
	POP	H	; GET ACC,FLAGS
	MOV	C,H	; PUT ACC IN C FOR PUTB
	CALL	PUTB	; PRINT
	CALL	BITS	; PRINT FLAGS ALREADY IN L
;
	POP	H	; GET B,C
	CALL	PUTW	; PRINT
;
	POP	H	; GET D,E
	CALL	PUTW	; PRINT
;
	POP	H	; GET H,L
	CALL	PUTW	; PRINT
;
	RET
;
;*********************************************************************
; SINGLE STEP AND DISASSEMBLER MODULE
; 
; THIS PRINTS THE REGISTER VALUES AND THE NEXT INSTRUCTION
; PRESSING ANY KEY GOES TO THE NEXT INSTRUCTION
; USE ^C TO EXIT TO THE MONITOR
;
TRACE:	CALL	GETW		; ADDRESS TO START AT
	SHLD	PSAVE		; SET ENTRY POINT TO START SINGLE STEP
	LXI	D,DISINS 	; MESSAGE
	CALL	SENDM		; SEND IT
	LXI	SP,MSTCK	; SET SINGLE STEP STACK POINTER
;
;*********************************************************************
;*   RETURN POINT AFTER SIMULATION OF OPCODE IN RAM AREA             *
;*********************************************************************
RSTA:	SHLD	LSAVE		; SAVE H
	STA	ASAVE		; TEMP SAVE A
	RAR			; SAVE CY TO ACCUMULATOR
	LXI	H,0		; GET 0'S IN HL
	DAD	SP		; GET VALUE OF STACK POINTER
	SHLD	SSAVE		; SAVE VALUE OF STACK POINTER
	RAL			; RESET CY TO PROPER VALUE
	LDA	ASAVE		; GET VALUE OF A
	LXI	SP,LSAVE	; SET STACK POINTER TO LSAVE
	PUSH	D		; SAVE D-E
	PUSH	B		; SAVE B-C
	PUSH	PSW		; SAVE PSW-A
FINI:	LXI	SP,MSTCK	; RESET STACK POINTER
;
; DISPLAY REGISTERS
;
DSPLY:	LXI	D,REGLST 	; REGISTER LIST
	CALL	SENDM		; SEND IT	
	LHLD	PSAVE
	CALL	PUTHL		; PRINT PC
	LHLD	SSAVE
	CALL	PUTW		; PRINT SP
	LDA	ASAVE
	MOV	C,A
	CALL	PUTB		; PRINT ACC
	LDA	FSAVE
	MOV	L,A
	CALL	BITS		; PRINT FLAG
	LHLD	CSAVE
	CALL	PUTW		; PRINT B,C
	LHLD	ESAVE
	CALL	PUTW		; PRINT D,E
	LHLD	LSAVE
	CALL	PUTW		; PRINT H,L
	MVI	A,' '
	CALL	OUTT		; ADD SPACE BEFORE OPCODE STRINGS
	LHLD	PSAVE		; POINT TO OP CODE IN HL
	CALL 	DISASM		; SHOW OP CODE MNEMONICS
	CALL	NEWLN		; NEW LINE	
; WAIT FOR KEYBOARD INPUT TO CONTINUE, ^C ABORTS AND RETURNS TO MONITOR	
SSWAIT:	CALL	INPUTT	
	CPI	CTRC		; ABORT?
	JNZ	SSTEP		; NO, CONTINUE
;
	JMP	WARM		; YES, RETURN TO MONITOR
;
;*********************************************************************
;*                 SINGLE STEP LOOP CYCLE                            *
;*********************************************************************
SSTEP:	MVI	A,0C3H		; SET JUMP OPCODE
	STA	EXOP3		; STORE IN RAM EXECUTION AREA
	LXI	H,RSTA		; GET RETURN POINT IN H-L
	SHLD	EXOP4		; STORE IN RAM EXECUTION AREA
	LXI	H,0		; GET 0'S IN HL
	SHLD	EXOP1		; MAKE 2ND & 3RD BYTES NOP'S
	LHLD	PSAVE		; LOCATION OPCODE TO BE SIMULATED
	MOV	A,M		; GET THE OPCODE BYTE
	STA	EXOP		; STORE IT IN RAM EXECUTION AREA
	CALL	TCNT		; GET NUMBER OF BYTES OF OPCODE
	LHLD	PSAVE		; GET PROGRAM COUNTER IN H-L AGAIN
	CPI	1		; SEE IF ONE BYTE INSTRUCTION
	JZ	NMB		; IF SO, UPDATE PSAVE
	CPI	2		; SET Z FLAG - TWO BYTE INSTRUCTION
	INX	H		; POINT TO SECOND BYTE
	MOV	A,M		; FETCH THE SECOND BYTE
	STA	EXOP1		; STORE IN RAM EXECUTION AREA
	JZ	NMB		; Z SET IF TWO BYTE INSTRUCTION
	INX	H		; POINT TO THIRD BYTE
	MOV	A,M		; FETCH THE THIRD BYTE
	STA	EXOP2		; STORE IN RAM EXECUTION AREA
NMB:	INX	H		; INCREMENT TO PROPER VALUE
	SHLD	PSAVE		; STORE NEW PROGRAM COUNTER
;*********************************************************************
;* CHECK ODD OPCODE TABLE FOR BYTE AND JUMP TO CORRESPONDING ADDRESS *
;* THESE ARE OPCODES WHICH ARE OUT OF ALIGNMENT WITH THE SYSTEM TYPE *
;* OPCODES                                                           *
;*********************************************************************
	LDA	EXOP		; GET THE OPCODE BYTE AGAIN
	LXI	H,OOTBL		; SET H-L TO BEGINNING OF OOTBL
	MVI	B,5		; SET COUNT OF NUMBER OF ENTRIES
; SEE IF IN TABLE
TBCHK:	INR	B		; INCREMENT LOOP COUNTER
TBC1:	DCR	B		; DECREMENT LOOP COUNTER
	JZ	TBNOT		; IF B IS ZERO, BYTE NOT IN TABLE
	CMP	M		; SEE IF BYTE IN TABLE
	JZ	TBC2		; IF SO, THEN NEED ADDRESS
	INX	H		; SKIP DATA BYTE
	INX	H		; AND SKIP THE TWO
	INX	H		; SUBSEQUENT ADDRESS BYTES
	JMP	TBC1		; DO THE LOOP AGAIN
TBC2:	INX	H		; POINT TO LOW ORDER ADDRESS BYTE
	JMP	HLJMP		; GET ADDRESS AND MAKE JUMP
;
TBNOT:	ANI	300Q		; NOT IN TABLE, GET HIGH OCTAL PART
	CPI	300Q		; SEE IF IT IS THREE
	JZ	SYSOP		; JUMP TO SYSTEM TYPE OPCODES IF SO
;*********************************************************************
;*   NORMAL REGISTER AND STACK POINTER RESTORING SEQUENCE            *
;*********************************************************************
EXCYC:	POP	PSW		; RESTORE PSW
	POP	B		; RESTORE B-C
	POP	D		; RESTORE D-E
	LHLD	SSAVE		; GET VALUE OF STACK POINTER
	SPHL			; RESTORE STACK POINTER VALUE
	LHLD	LSAVE		; RESTORE H-L
	JMP	EXOP		; EXECUTE THE OPCODE
;*********************************************************************
;*    SYSTEM TYPE OPCODES -- HIGH ORDER OCTAL PART IS 3              *
;*    A JUMP IS MADE TO THE APPROPRIATE ROUTINE CONSISTENT           *
;*    WITH THE FOLLOWING OCTAL ORGANIZATION OF THE OPCODE            *
;*                                                                   *
;*  RETYP . EXCYC . BRTYP . EXCYC . CALTY . EXCYC  . EXCYC . RSTTY   *
;*  ...............................................................  *
;*   3X0  .  3X1  .  3X2  .  3X3  .  3X4  .  3X5   .  3X6  .  3X7    *
;*  ...............................................................  *
;*   RNZ  . POP B .  JNZ  .  JMP  .  CNZ  . PUSH B .  ADI  . RST 0   *
;*   RZ   . RET   .  JZ   .  ---  .  CZ   . CALL   .  ACI  . RST 1   *
;*   RNC  . POP D .  JNC  .  OUT  .  CNC  . PUSH D .  SUI  . RST 2   *
;*   RC   . ---   .  JC   .  IN   .  CC   . ---    .  SBI  . RST 3   *
;*   RPO  . POP H .  JPO  .  XTHL .  CPO  . PUSH H .  ANI  . RST 4   *
;*   RPE  . PCHL  .  JPE  .  XCHG .  CPE  . ---    .  XRI  . RST 5   *
;*   RP   . POP P .  JP   .  DI   .  CP   . PUSH P .  ORI  . RST 6   *
;*   RM   . SPHL  .  JM   .  EI   .  CM   . ---    .  CPI  . RST 7   *
;*                                                                   *
;*    NOTE:                                                          *
;*          JMP, RET, CALL AND PCHL HAVE BEEN ELIMINATED             *
;*          FROM CONSIDERATION AT THIS POINT                         *
;*********************************************************************
SYSOP:	LXI	H,SYTBL		; GET START OF SYTBL ADDRESS
	LDA	EXOP		; GET OPCODE
	ANI	07Q		; GET LOW ORDER OCTAL PART
;*********************************************************************
;*        INDIRECT JUMP COMPUTE ROUTINE                              *
;*********************************************************************
INJMP:	ADD	A		; MULTIPLY BY TWO
	MOV	E,A		; SET UP FOR COMPUTING
	MVI	D,0		; THE OFFSET
	DAD	D		; COMPUTE THE OFFSET
HLJMP:	MOV	E,M		; LOW ORDER ADDRESS
	INX	H		; POINT TO HIGH ORDER ADDRESS
	MOV	D,M		; HIGH ORDER ADDRESS
	XCHG			; MOVE TO H-L
	PCHL			; MAKE THE JUMP
;
;*********************************************************************
;*       INSTRUCTION SIMULATION ROUTINES                             *
;*********************************************************************
PCH:	LHLD	LSAVE		; GET ORIGINAL VALUE OF H-L
	SHLD 	PSAVE		; UPDATE PROGRAM COUNTER
	JMP	FINI		; FINISHED
;
BRTYP:	LHLD	EXOP1		; GET USER'S JUMP TO ADDRESS
	XCHG			; PASS D-E
	LXI	H,JMPSC		; SUCCESSFUL JUMP ADDRESS
	JMP	BRSB		; COMPLETE BRANCH OPERATION
JMPSC:	LHLD	MSTC2		; GET JUMP ADDRESS FROM MSTC2
	SHLD	PSAVE		; STORE THE ADDRESS
	JMP	FINI		; FINISHED
;
CALTY:	LHLD	EXOP1		; GET USER'S CALL ADDRESS
	XCHG			; PASS IN D-E
	LXI	H,CALSC		; SUCCESSFUL CALL ADDRESS
BRSB:	SHLD	EXOP1		; REPLACE JUMP ADDRESS IN RAM
	XCHG			; PASS USER'S SAVE ADDRESS IN H-L
	JMP	FLRS		; RESTORE FLAGS AND EXECUTE
RETYP:	LXI	H,RETSC		; RETURN SUCCESSFUL ADDRESS
FLRS:	POP	PSW		; RESTORE FLAGS
	PUSH	PSW		; RESTORE STACK POINTER TO MSTCK
	PUSH	H		; PUT USER'S ADDRESS AT MSTCK-2
	LXI	H,FINI		; GET RETURN POINT
	SHLD	EXOP4		; FOR UNSUCCESSFUL CALL/RET
	JMP	EXOP		; EXECUTION STEP
;
RETSC:	LHLD	SSAVE		; GET ORIGINAL STACK POINTER VALUE
	SPHL			; RESET STACK POINTER TO THIS VALUE
	POP	H		; RETURN ADDRESS - ORIGINAL STACK
	JMP	SAVPS		; UPDATE PSAVE AND SSAVE
RSTTY:	LDA	EXOP		; GET OPCODE
	ANI	070Q		; EXTRACT MIDDLE ORDER OCTAL PART
	MOV	L,A		; WHICH IS LOW ORDER ADDRESS
	MVI	H,0		; FILL H WITH 0'S
	PUSH	H		; SAVE AT MSTCK-2
CALSC:	LHLD	SSAVE		; GET ORIGINAL STACK POINTER VALUE
	SPHL			; RESET STACK POINTER TO THIS VALUE
	LHLD	PSAVE		; GET RETURN ADDRESS AFTER CALL
	PUSH	H		; PUT ON ORIGINAL STACK
	LHLD	MSTC2		; GET ORIGINAL CALL ADDRESS
SAVPS:	SHLD	PSAVE		; UPDATE PSAVE TO CORRECT ADDRESS
	LXI	H,0		; FILL H-L WITH 0'S
	DAD	SP		; GET VALUE OF STACK POINTER
	SHLD	SSAVE		; SAVE - NEW VALUE OF STACK POINTER
	JMP	FINI		; FINISHED
;
;*********************************************************************
;*               RETURN NUMBER OF BYTES FOR OPCODE                   *
;*       A- HAS OPCODE ON ENTRY AND BYTE COUNT ON EXIT               *
;*********************************************************************
TCNT:	LXI	H,CLTBL		; GET 1ST PART OF OP COUNT TABLE
	CPI	40H		; SEE IF LOW PART OF OP COUNT TABLE
	JC	MAKCN		; IF SO NEED TO LOOK UP THE COUNT
	LXI	H,CHTBL		; GET SECOND PART OF OP COUNT TABLE
	SUI	0C0H		; SEE IF 2ND PART OF OP COUNT TABLE
	JNC	MAKCN		; IF SO NEED TO LOOK UP THE COUNT
	MVI	A,1		; IF NOT, COUNT MUST BE 1
	RET			; AND NO MORE TO DO
;
MAKCN:	CPI	4		; SEE IF LESS THAN OR EQUAL TO 3
	JC	EXBYT		; IF SO EXTRACT THE BYTE
	INX	H		; POINT H TO NEXT BYTE
	SUI	4		; SUBTRACT 4 FROM ACCUMULATOR
	JMP	MAKCN		; TRY AGAIN
EXBYT:	ORA	A		; SET FLAG IF A SUBTRACTED TO ZERO
	RLC			; DOUBLE VALUE IN A
	MOV	B,A		; SAVE A IN B
	MOV	A,M		; GET BYTE OF OP COUNT INFORMATION
	JZ	FSTCN		; EXTRACT DATA IF Z FLAG = 1
RLC10:	RLC			; ROTATE ACCUMULATOR LEFT ONCE
	DCR	B		; ONE LESS FOR B
	JNZ	RLC10		; ROTATE SOME MORE IF B NOT ZERO YET
FSTCN:	RLC			; ROTATE VALUE TO BIT 0
	RLC			; AND TO BIT 1
	ANI	03H		; MASK OUT REST OF BYTE
	RET			; OPCODE BYTE COUNT IS NOW IN A
;
;
;************************************************************
;* 8085 DISASSEMBLER
;* (c) 2017  DAVID HUNTER
;*
;* PRINT THE OPCODE AND APPROPRIATE BYTES/WORDS 
;* FOR THE INSTRUCTION POINTED TO BY (H,L)
;* H,L IS UPDATED BEFORE IT RETURNS SO IT CAN BE CALLED AGAIN
;************************************************************
DISASM:	MOV	A,M		; GET OP CODE
	ANI	0C0H		; DETERMINE INSTRUCTION TYPE
	JZ	TYPE0
	CPI	40H
	JZ	TYPE1
	CPI	80H
	JZ	TYPE2
;
; TYPE 3 INSTRUCTIONS CALLS, RETURNS, JUMPS, ETC.
; FORMAT: 11 YYY ZZZ
TYPE3:	MOV	A,M		; GET OP CODE
	ANI	07H		; DETERMINE SUB TYPE
	JNZ	TYPE3A
				; 11YYY000
	MVI	A,'R'		; CONDITIONAL RETURN
	CALL	OUTT
	CALL	PCOND		; PRINT CONDITION CODE
	INX	H		; INCREMENT POINTER
	JMP	PEXIT
;
TYPE3A:	DCR	A		; 11YYY001
	JNZ	TYPE3B
;	
	MOV	A,M		; GET OP CODE
	ANI	08H		; CHECK IF POP OR OTHER
	JNZ	TYP3A1
	LXI	D,IPOP		; 11YY0001 POP
	CALL	SENDM		; SEND STRING
	LXI	D,STKPR
	CALL	PPAIR		; PRINT REGISTER PAIR
	INX	H		; INCREMENT POINTER
	JMP	PEXIT
;	
TYP3A1:	MOV	A,M		; 11YY1001 RET,PCHL,SPHL
	ANI	30H		; DETERMINE SPECIAL INSTRUCTION
	RRC			; OFFSET * 8
	LXI	D,IOP31		; POINT TO TABLE
	CALL	POFF		; AND PRINT
	INX	H		; INCREMENT POINTER
	JMP	PEXIT
;
TYPE3B:	DCR	A		; 11YYY010
	JNZ	TYPE3C
	MVI	A,'J'		; CONDITIONAL JUMP
	CALL	OUTT
	CALL	PCOND		; PRINT CONDITION CODE
	MVI	A,' '
	CALL	OUTT		; ALIGN ADDRESS
	INX	H
	JMP	PWORD		; PRINT ADDRESS AND RETURN
;
TYPE3C:	DCR	A		; 11YYY011
	JNZ	TYPE3D
	MOV	A,M		; JMP, OUT, IN, XTHL, XCHG, DI, EI
	CPI	0C3H		; JUMP?
	JZ	TYP3C1
	CPI	0D3H		; OUT?
	JZ	TYP3C2
	CPI	0DBH		; IN?
	JZ	TYP3C3
	ANI	38H		; NO, DETERMINE INSTRUCTION
	LXI	D,IOP33		; POINT TO TABLE
	CALL	POFF		; PRINT INSTRUCTION
	INX	H		; INCREMENT POINTER
	JMP	PEXIT
;
TYP3C1:	LXI	D,IJMP		; JMP INSTRUCTION
	CALL	SENDM
	MVI	A,' '
	CALL	OUTT		; PRINT SPACE
	INX	H		; POINT TO ADDRESS
	JMP	PWORD		; AND PRINT IT AND RETURN
;
TYP3C2:	LXI	D,IOUT		; OUT INSTRUCTION
	CALL	SENDM
	MVI	A,' '
	CALL	OUTT		; PRINT SPACE
	INX	H		; POINT TO PORT NUMBER
	JMP	PBYTE		; AND PRINT IT AND RETURN
;
TYP3C3:	LXI	D,IIN		; IN INSTRUCTION
	CALL	SENDM
	MVI	A,' '
	CALL	OUTT		; PRINT SPACE
	INX	H		; POINT TO PORT NUMBER
	JMP	PBYTE		; AND PRINT IT AND RETURN
;
TYPE3D:	DCR	A		; 11YYY100
	JNZ	TYPE3E
	MVI	A,'C'		; CONDITIONAL CALL
	CALL	OUTT
	CALL	PCOND		; PRINT CONDITION CODE
	MVI	A,' '
	CALL	OUTT		; ALIGN ADDRESS
	INX	H		; POINT TO ADDRESS
	JMP	PWORD		; AND PRINT IT AND RETURN	
;
TYPE3E:	DCR	A		; 11YYY101
	JNZ	TYPE3F
	MOV	A,M		; GET OP CODE
	ANI	08H		; CHECK IF PUSH OR CALL
	JNZ	TYP3E1
	LXI	D,IPUSH		; 11YY0101 PUSH
	CALL	SENDM		; SEND STRING
	LXI	D,STKPR
	CALL	PPAIR		; PRINT REGISTER PAIR
	INX	H		; INCREMENT POINTER
	JMP	PEXIT
;	
TYP3E1:	MOV	A,M		; 11YY1101 CALL
	CPI	0CDH		; CALL INSTRUCTION
	JNZ	PINV
	LXI	D,ICALL
	CALL	SENDM		; 11001101 CALL
	MVI	A,' '
	CALL	OUTT		; PRINT SPACE
	INX	H		; INCREMENT POINTER
	JMP	PWORD		; PRINT ADDRESS AND RETURN
;
TYPE3F:	DCR	A		; 11YYY110 ADI,ACI, ETC.
	JNZ	TYPE3G
	MOV	A,M
	ANI	38H		; DETERMINE INSTRUCTION
	LXI	D,IOP36
	CALL	POFF		; PRINT OP CODE
	MVI	A,' '
	CALL	OUTT		; PRINT SPACE
	INX	H		; INCREMENT POINTER
	JMP	PBYTE		; PRINT 8 BIT VALUE AND RETURN
;
TYPE3G:	LXI	D,IRST		; 11YYY111 RST
	CALL	SENDM		; SEND OP CODE
	MVI	A,' '
	CALL	OUTT
	MOV	A,M
	ANI	38H		; MASK RESET CODE
	RRC
	RRC
	RRC			; SHIFT OVER TO LOWER BITS
	ADI	30H		; CONVERT TO ASCII
	INX	H		; INCREMENT POINTER
	JMP	OUTT		; PRINT AND RETURN
;
; TYPE 2 INSTRUCTIONS REGISTER MATH
; FORMAT: 10 YYY ZZZ
TYPE2:	MOV	A,M
	ANI	38H		; DETERMINE INSTRUCTION
	LXI	D,IOP2X
	CALL	POFF		; PRINT OP CODE
	MVI	A,' '
	CALL	OUTT		; PRINT A SPACE
	MOV	A,M		; GET OP CODE
	ANI	07H		; MASK OFF REGISTER
	INX	H		; INCREMENT POINTER
	JMP	PNAME		; PRINT NAME AND RETURN
;	
; TYPE 1 INSTRUCTIONS REGISTER MOVE
; FORMAT: 01 YYY ZZZ
TYPE1:	MOV	A,M
	CPI	76H		; HALT INSTRUCTION?
	JZ	TYPE1A		; YES, HANDLE SEPARATELY
	LXI	D,IMOV		; NO,
	CALL	SENDM		; PRINT OP CODE
	MVI	A,' '
	CALL	OUTT		; PRINT SPACE
	MOV	A,M		; GET OP CODE BACK
	ANI	38H		; GET UPPER REGISTER
	RRC
	RRC
	RRC
	CALL	PNAME		; PRINT REGISTER NAME
	MVI	A,','
	CALL	OUTT		; PRINT COMMA
	MOV	A,M
	ANI	07H		; GET LOWER REGISTER
	INX	H		; INCREMENT POINTER
	JMP	PNAME		; PRINT NAME AND RETURN
;
TYPE1A:	LXI	D,IHLT
	INX	H		; INCREMENT POINTER
	JMP	SENDM		; PRINT HALT AND RETURN
;	
; TYPE 1 INSTRUCTIONS NOP, RIM, SIM, LXI, DAD, ETC.
; FORMAT: 00 YYY ZZZ
TYPE0:	MOV	A,M		; GET OP CODE
	ANI	07H		; DETERMINE SUB TYPE
	JNZ	TYPE0A
	MOV	A,M		; 00YYY000
	CPI	20H		; RIM?
	JNZ	TYP01
	INX	H		; INCREMENT POINTER
	LXI	D,IRIM
	JMP	SENDM		; YES, PRINT IT AND RETURN

TYP01:	CPI	30H		; SIM?
	JNZ	TYP02
	INX	H		; INCREMENT POINTER
	LXI	D,ISIM
	JMP	SENDM		; YES, PRINT IT AND RETURN
	
TYP02:	ORA	A		; SET FLAGS
	LXI	D,INOP
	INX	H		; INCREMENT POINTER
	JZ	SENDM		; NOP? YES, SEND AND RETURN
	JMP	PINV		; ELSE INVALID
;
TYPE0A:	DCR	A		; 00YYY001 LXI OR DAD
	JNZ	TYPE0B
	MOV	A,M		; GET OP CODE
	ANI	08H
	JZ	TYP0A1		; LXI OR DAD?
	LXI	D,IDAD
	CALL	SENDM		; DAD, SEND OP 
	LXI	D,REGPR
	CALL	PPAIR		; SEND REGISTER PAIR AND RETURN
	INX	H		; INCREMENT POINTER
	JMP	PEXIT
;	
TYP0A1:	LXI	D,ILXI		; LXI, SEND OP
	CALL	SENDM		; SEND STRING
	LXI	D,REGPR
	CALL	PPAIR		; PRINT REGISTER PAIR
	MVI	A,','		; PRINT COMMA
	CALL	OUTT
	INX	H
	JMP	PWORD		; PRINT VALUE AND RETURN
;
TYPE0B:	DCR	A		; 00YYY010  STAX,LDAX, ETC.
	JNZ	TYPE0C
	MOV	A,M		; GET OP CODE
	ANI	38H		; GET OFFSET
	LXI	D,IOP02
	CALL	POFF		; PRINT OP
	MOV	A,M
	ANI	20H		; PRINT REGISTER PAIR? (STAX,LDAX)
	JNZ	TYP0B1		; NO, PRINT ADDRESS
	INX	H		; INCREMENT POINTER
	JMP	PEXIT
;	
TYP0B1:	MVI	A,' '
	CALL	OUTT		; PRINT SPACE
	INX	H
	JMP	PWORD		; PRINT ADDRESS AND RETURN
;
TYPE0C:	DCR	A		; 00YYY011  INX, DCX
	JNZ	TYPE0D
	MOV	A,M		; GET OP CODE
	ANI	08H
	JZ	TYP0C1		; INX OR DCX?
	LXI	D,IDCX		; DCX
	JMP	TYP0C2
TYP0C1:	LXI	D,IINX		; INX
TYP0C2:	CALL	SENDM		; PRINT OP
	LXI	D,REGPR
	CALL	PPAIR		; PRINT REGISTER PAIR
	INX	H		; INCREMENT POINTER
	JMP	PEXIT
;
TYPE0D:	DCR	A		; 00YYY100  INR
	JNZ	TYPE0E
	LXI	D,IINR
	JMP	TYP0E1
;
TYPE0E:	DCR	A		; 00YYY101  DCR
	JNZ	TYPE0F
	LXI	D,IDCR
;
TYP0E1:	CALL	SENDM		; PRINT OP
	MVI	A,' '
	CALL	OUTT		; PRINT SPACE
	MOV	A,M		; GET OP CODE
	ANI	38H		; GET REGISTER
	RRC
	RRC
	RRC
	INX	H		; INCREMENT POINTER
	JMP	PNAME		; PRINT REGISTER NAME AND RETURN
;
TYPE0F:	DCR	A		; 00YYY110  MVI
	JNZ	TYPE0G
	LXI	D,IMVI
	CALL	SENDM
;
	MVI	A,' '
	CALL	OUTT		; PRINT SPACE
	MOV	A,M		; GET OP CODE
	ANI	38H		; GET REGISTER
	RRC
	RRC
	RRC
	CALL	PNAME		; PRINT REGISTER NAME
	MVI	A,','
	CALL	OUTT		; PRINT COMMA
	INX	H		; INCREMENT POINTER
	JMP	PBYTE		; PRINT BYTE AND RETURN
;
TYPE0G:	MOV	A,M		; 00YYY111  OTHER
	ANI	38H
	LXI	D,IOP07
	CALL	POFF		; PRINT STRING
	INX	H		; INCREMENT POINTER
	JMP	PEXIT
;
; PRINT REGISTER PAIR, REGISTER STRING POINTER IN (D,E)
PPAIR:	MVI	A,' '
	CALL	OUTT		; PRINT A SPACE
	MOV	A,M		; GET OP CODE
	ANI	30H		; GET REGISTER PAIR
	RRC
	RRC			; OFFSET INTO TABLE
	JMP	POFF		; PRINT THE STRING
;
; PRINT CONDITION CODE
PCOND:	MOV	A,M		; GET OPCODE
	ANI	38H		; GET CONDITION CODE
	RRC			; OFFSET VALUE TO TABLE
	LXI	D,CONDF		; POINT TO CONDITION FLAGS
				; DROP INTO PRINT STRING WITH OFFSET
; 
; PRINT THE STRING IN (D,E) + A
POFF:	PUSH	H		; SAVE POINTER
	XCHG			; PUT DE -> HL
	MOV	E,A		; OFFSET IN DE
	MVI	D,0		; 
	DAD	D		; COMPUTE THE OFFSET FROM HL
	XCHG			; STRING ADDRESS IN DE
	CALL	SENDM		; PRINT THE STRING
	POP	H
	JMP	PEXIT
;
; PRINT REGISTER NAME BASED ON OFFSET IN A
PNAME:	PUSH	H
	LXI	H,REGNAM
	MOV	E,A		; OFFSET IN DE
	MVI	D,0		; 
	DAD	D		; COMPUTE THE OFFSET FROM HL
	MOV	A,M		; GET REGISTER NAME
	CALL	OUTT		; PRINT
	POP	H
	JMP	PEXIT
;
; PRINT SPACE AND BYTE VALUE FROM (H,L), INCREMENT HL
PBYTE: 	MOV	C,M
	INX	H		; INCREMENT POINTER
	CALL	PUTB
	JMP	PEXIT
;
; PRINT SPACE AND 16 BIT VALUE FROM (H,L), INCREMENT HL TWICE
PWORD:	MOV	E,M
	INX	H		; INCREMENT POINTER
	MOV	D,M		; VALUE IN D
	INX	H		; INCREMENT POINTER
	PUSH	H
	XCHG			; 16 BIT VALUE IN H
	CALL	PUTW		; PRINT IT
	POP	H
PEXIT:	RET
;
; PRINT INVALID OP CODE AND RETURN
PINV:	LXI	D,IERR
	JMP	SENDM
;
;
;================================================
; "BIT-BANG" SERIAL I/O
;
; CONSOLE INPUT ROUTINE
; ADAPTED FROM THE INTEL MCS-80/85 USER'S MANUAL
; RETURNS THE INPUT BYTE IN ACC
; ALSO INCREMENTS A COUNTER TO USE FOR "RANDOMIZE" KEYWORD
; SAVES REGISTERS
INPUTT:	PUSH	B
	PUSH	H
	MVI	B,9	; 8 BITS + STOP
INP1:	
	RIM		; (4 CLK) GET SERIAL INPUT
	ORA	A	; (7 CLK) SET/CLEAR SIGN FLAG IN PSW
	JP	INP1A	; (7/10 CLK) EXIT IF START BIT ARRIVED
	LHLD	RANDOM	; (16 CLK) INCREMENT RANDOM COUNTER 
	INX	H	; (6 CLK)
	SHLD	RANDOM	; (16 CLK) 
	JMP	INP1	; (10 CLK) WAIT FOR START BIT
			; POLLING INTERVAL = 66 CLKS => 26.8us => 6.4% OF A BIT TIME
;
INP1A:	MVI	L,HALFBIT 
INP2:	DCR	L	; WAIT UNTIL THE MIDDLE OF THE START BIT
	JNZ	INP2
	NOP
;
INP3:	MVI	L,FULLBIT ; WAIT ONE BIT TIME
INP4:	DCR	L
	JNZ	INP4
	NOP
	NOP
	RIM		; GET DATA BIT
	RAL
	DCR	B
	JZ	INP5
	MOV	A,C
	RAR
	MOV	C,A
	NOP		; NEEDED TO HAVE EQUAL # CLOCKS WITH COUT
	JMP	INP3
;
INP5:	MOV	A,C	; GET BYTE INTO ACC
	ANI	7FH	; MASK OFF 7 BITS
	POP	H
	POP	B
	CPI	CTRX	; ABORT?
	JZ	WARM	; YES, 
	RET
;
;
; CONSOLE OUTPUT ROUTINE
; OUTPUT BYTE IN ACC
; SAVES REGISTERS
OUTT:	
	PUSH	PSW
	PUSH	B
	PUSH	H
	MOV	C,A	; OUTPUT BYTE INTO C
	
	XRA	A	; CLEAR A, CARRY
	MVI	B,10	; 10 BITS FOR 8N1
OUT1:	MVI	A,80H	; SET SOD ENABLE BIT << 1
	RAR		; GET BIT FROM CARRY
	SIM		; OUTPUT BIT
;	
	MVI	L,FULLBIT
OUT2:	DCR	L	; DELAY ONE BIT TIME
	JNZ	OUT2
	NOP
	NOP
	STC		; SET STOP BIT
	MOV	A,C
	RAR		; GET NEXT BIT INTO CARRY
	MOV	C,A
	DCR	B
	JNZ	OUT1
;	
	POP	H
	POP	B
	POP	PSW	; RETURN THE OUTPUT BYTE
	RET
;
;================================================
; MONITOR UTILITY SUBROUTINES
;
; GET CHARACTER AND ECHO
GETCHE:	CALL	INPUTT
	JMP	OUTT
;
; SEND NULL TERMINATED STRING IN D,E
SENDM:	LDAX	D	; GET CHARACTER
	ORA	A	; SET FLAGS
	RZ		; EXIT IF NULL
	CALL	OUTT	; SEND IT
	INX	D	; NEXT CHARACTER
	JMP	SENDM
;
; SEND CR,LF
NEWLN:	MVI	A,CR
	CALL	OUTT
	MVI	A,LF
	JMP	OUTT
;
; SEND SPACE
SPACE:	MVI	A,' '
	JMP	OUTT
;
; SEND SPACE, THEN 16 BIT WORD IN H,L AS HEX
PUTW:	CALL	SPACE
PUTHL:	MOV	C,H
	CALL	PUTBYT
	MOV	C,L
	JMP	PUTBYT
;
; SEND SPACE, THEN BYTE IN C OUT AS HEX
PUTB:	CALL	SPACE
PUTBYT:	MOV	A,C	; GET BYTE
	RRC		; MOVE UPPER NIBBLE OVER
	RRC
	RRC
	RRC
	ANI	0FH	; MASK OFF BITS
	CALL	PUTHEX
	MOV	A,C	; GET BYTE BACK
	ANI	0FH	; MASK OFF BITS
			; DROP INTO PUTHEX
;
; PRINT LOWER 4 BITS OF ACC AS HEX VALUE
PUTHEX:	ADI	90H
	DAA
	ACI	40H
	DAA
	JMP	OUTT
;
; SEND BYTE IN L AS 8 BITS
BITS:	CALL	SPACE
	PUSH	B	; SAVE REGISTERS
	MVI	B,0	; ZERO REGISTER B FOR ACC CLEAR
	MVI	C,8	; 8 BITS
NXTBIT:	MOV	A,L	; GET BYTE
	RLC		; MOVE UPPER BIT INTO CARRY
	MOV	L,A	; SAVE BYTE
	MOV	A,B	; CLEAR ACC
	ACI	'0'	; PRINT CARRY BIT
	CALL	OUTT	; SEND DIGIT
	DCR	C	; DECREMENT COUNT
	JNZ	NXTBIT
	POP	B
	RET		; EXIT IF DONE
;
; GET 16 BIT HEX WORD, CONVERT TO BINARY, RETURN IN H,L
GETW:	CALL	GETB	; GET UPPER BYTE
	MOV	H,A	; PUT IN H
	CALL	GETB	; GET LOWER BYTE
	MOV	L,A	; PUT IN L
	RET
;
; GET HEX BYTE, CONVERT TO BINARY, RETURN IN A
GETB:	PUSH	B	; SAVE REGISTERS
	CALL	GETHEX	; GET UPPER NIBBLE
	RAL
	RAL
	RAL
	RAL
	ANI	0F0H	; MASK OFF UPPER BITS
	MOV	C,A	; SAVE
	CALL	GETHEX	; GET LOWER NIBBLE
	ORA	C	; BRING IN UPPER BITS
	POP	B
	RET
;
GETHEX: CALL	GETCHE	; GET CHAR AND ECHO
CHKHEX:	CPI	'0'	; BETWEEN 0 AND 9?
	JC	ERROR
	CPI	'9'+1
	JC	CONVHX
	ANI	05FH	; CONVERT TO UPPER CASE
	CPI	'A'	; BETWEEN A AND F?
	JC	ERROR
	CPI	'F'+1
	JNC	ERROR
			; FALL INTO CONVHX
;
CONVHX:	SUI	'0'	; CONVERT TO BINARY
	CPI	0AH	; 0-9?
	RC		; YES, RETURN
	SUI	7	; NO, ADJUST A-F
	RET
;
;
;================================================
;
; SIGN ON MESSAGE AT EACH COLD START
SIGNON:	DB	CR,LF
	DB	'Altaids Monitor Ver '
	DW	VERS
	DB	CR,LF
	DB	'Copyright (C) 2018 David R. Hunter',CR,LF
	DB	'This program comes with ABSOLUTELY NO WARRANTY',CR,LF
	DB 	'This is free software, and you are welcome to redistribute it',CR,LF
	DB	'under certain conditions; see the GNU GPL Version 3 for details',CR,LF
	DB	'Type "B" for BASIC, "H" for help',CR,LF
	DB	'Type ^X to return to the Monitor',CR,LF
	DB	0
;
; MONITOR HELP MESSAGE
HLPMSG:	DB	CR,LF
	DB	'Monitor commands',CR,LF
	DB	'A : ALTAIR MONITOR',CR,LF
	DB	'B : TINY BASIC',CR,LF
	DB	'D : DUMP [Dnnnn mmmmm]',CR,LF
	DB	'E : ENTER [Ennnn]',CR,LF
	DB	'G : RUN [Gnnnn]',CR,LF
	DB	'H : HELP (this message)',CR,LF
	DB	'I : INPUT FROM PRT 60H',CR,LF
	DB	'L : LOAD HEX FILE',CR,LF
	DB	'O : OUTPUT TO PRT 61H [Obb]',CR,LF
	DB	'R : DISPLAY REG',CR,LF
	DB	'T : TRACE (STEP) [Tnnnn]',CR,LF
	DB	0
;
;
;*********************************************************************
;*   TABLES USED TO LOOK UP CERTAIN OPCODES AND JUMP LOCATIONS       *
;* THESE ARE EXCEPTIONS TO THE "REGULAR" OP CODE DECODING            *
;*********************************************************************
OOTBL:	DB	0E9H		; PCHL INSTRUCTION BYTE
	DW	PCH
	DB	0C3H		; JMP INSTRUCTION BYTE
	DW	BRTYP
	DB	0CDH		; CALL INSTRUCTION BYTE
	DW	CALTY
	DB	0C9H		; RET INSTRUCTION BYTE
	DW	RETYP
	DB	076H		; HLT INSTRUCTION BYTE
	DW	WARM		; EXIT WITH HALT
SYTBL:	DW	RETYP
	DW	EXCYC
	DW	BRTYP
	DW	EXCYC
	DW	CALTY
	DW	EXCYC
	DW	EXCYC
	DW	RSTTY
	; PACKED COUNT OF BYTES (4 PER BYTE) FOR INSTRUCTIONS 00 - 3F
	;       00H,04H,08H,0CH,10H,14H,18H,1CH,20H,24H,28H,2CH,30H,34H,38H,3CH
CLTBL:	DB	75H,59H,15H,59H,35H,59H,15H,59H,7DH,59H,1DH,59H,7DH,59H,1DH,59H
	; INSTRUCTIONS 40 - BF ARE SINGLE BYTE INSTRUCTIONS
	; PACKED COUNT OF BYTES FOR INSTRUCTIONS C0 - FF
	;	C0H,C4H, C8H, CCH,D0H, D4H,D8H, DCH,E0H, E4H,E8H, ECH,F0H, F4H,F8H, FCH
CHTBL:	DB	5FH,0D9H,5CH,0F9H,5EH,0D9H,4EH,0C9H,5DH,0D9H,5DH,0C9H,5DH,0D9H,5DH,0C9H
;
; REGISTER IDENTIFIERS
;
REGLST:	DB	CR,LF
	DB	"PC  :SP  :A  SZ_A_P_C:B C :D E :H L"
	DB	CR,LF,0
;
; USER INSTRUCTIONS
DISINS:	DB	CR,LF
	DB	'Press any key to step to the next instruction'
	DB	CR,LF
	DB	'Press ^C to return to the Monitor'
	DB	0
;
;
;*********************************************************************
;* DISASSEMBLER TABLES
;*********************************************************************
; REGISTER NAMES  (IN OP CODE ORDER)
REGNAM:	DB	"B"
	DB	"C"
	DB	"D"
	DB	"E"
	DB	"H"
	DB	"L"
	DB	"M"
	DB	"A"
; REGISTER PAIRS (IN OP CODE ORDER, 4 BYTES EACH)
REGPR:	DB	"B  ",0
	DB	"D  ",0
	DB	"H  ",0
	DB	"SP ",0
; STACK REGISTER PAIRS (IN OP CODE ORDER, 4 BYTES EACH)
STKPR:	DB	"B  ",0
	DB	"D  ",0
	DB	"H  ",0
	DB	"PSW",0
; CONDITIONAL FLAGS (IN OP CODE ORDER, 4 BYTES EACH)
CONDF:	DB	"NZ ",0
	DB	"Z  ",0
	DB	"NC ",0
	DB	"C  ",0
	DB	"PO ",0
	DB	"PE ",0
	DB	"P  ",0
	DB	"M  ",0
; OP CODE STRINGS (INTEL MNEMONICS)
;
; THESE ARE SPECIAL TABLES (IN OP CODE ORDER, 8 BYTES EACH)
; OP CODE 00YYY010
IOP02:	DB	"STAX B",0,0
	DB	"LDAX B",0,0
	DB	"STAX D",0,0
	DB	"LDAX D",0,0
	DB	"SHLD",0,0,0,0
	DB	"LHLD",0,0,0,0
	DB	"STA ",0,0,0,0
	DB	"LDA ",0,0,0,0
;
; OP CODE 00YYY111
IOP07:	DB	"RLC",0,0,0,0,0
	DB	"RRC",0,0,0,0,0
	DB	"RAL",0,0,0,0,0
	DB	"RAR",0,0,0,0,0
	DB	"DAA",0,0,0,0,0
	DB	"CMA",0,0,0,0,0
	DB	"STC",0,0,0,0,0
	DB	"CMC",0,0,0,0,0
;
; OP CODE 10YYYZZZ
IOP2X:	DB	"ADD ",0,0,0,0
	DB	"ADC ",0,0,0,0
	DB	"SUB ",0,0,0,0
	DB	"SBB ",0,0,0,0
	DB	"ANA ",0,0,0,0
	DB	"XRA ",0,0,0,0
	DB	"ORA ",0,0,0,0
	DB	"CMP ",0,0,0,0
;
; OP CODE  11YY1001
IOP31: 	DB	"RET ",0,0,0,0
IERR:	DB	"????",0,0,0,0	; NOT USED
	DB	"PCHL",0,0,0,0
	DB	"SPHL",0,0,0,0
;
; OP CODE 11YYY011
IOP33:	
IJMP:	DB	"JMP ",0,0,0,0
	DB	"????",0,0,0,0	; NOT USED
IOUT:	DB	"OUT ",0,0,0,0
IIN:	DB	"IN  ",0,0,0,0
	DB	"XTHL",0,0,0,0
	DB	"XCHG",0,0,0,0
	DB	"DI",0,0,0,0,0
	DB	"EI",0,0,0,0,0
;
; OP CODE 11YYY110
IOP36:	DB	"ADI ",0,0,0,0
	DB	"ACI ",0,0,0,0
	DB	"SUI ",0,0,0,0
	DB	"SBI ",0,0,0,0
	DB	"ANI ",0,0,0,0
	DB	"XRI ",0,0,0,0
	DB	"ORI ",0,0,0,0
	DB	"CPI ",0,0,0,0
;
; OTHER OP CODE NAMES
ICALL:	DB	"CALL",0
IDAD:	DB	"DAD ",0
IDCR:	DB	"DCR ",0
IDCX:	DB	"DCX ",0
IHLT:	DB	"HLT ",0
IINR:	DB	"INR ",0
IINX:	DB	"INX ",0
ILXI:	DB	"LXI ",0
IMOV:	DB	"MOV ",0
IMVI:	DB	"MVI ",0
INOP:	DB	"NOP ",0
IPOP:	DB	"POP ",0
IPUSH:	DB	"PUSH",0
IRIM:	DB	"RIM ",0
IRST:	DB	"RST ",0
ISIM:	DB	"SIM ",0	
;
;******
LSTROM: EQU	$	; END OF ROM
;
; RAM START
	ORG	2000H
;* PATB INTERPRETER VARIABLES
ABORTF	DB	0	; ABORT (^C) FLAG
OCSW:	DB	0FFH	; SWITCH FOR OUTPUT
CURRNT:	DW	0	; POINTS TO CURRENT LINE
STKGOS:	DW	0	; SAVES SP IN 'GOSUB'
VARNXT:	DW	0	; TEMPORARY STORAGE
STKINP:	DW	0	; SAVES SP IN 'INPUT'
LOPVAR:	DW	0	; 'FOR' LOOP SAVE AREA
LOPINC:	DW	0	; INCREMENT
LOPLMT:	DW	0	; LIMIT
LOPLN:	DW	0	; LINE NUMBER
LOPPT:	DW	0	; TEXT POINTER
SEED:	DW	BASIC	; RANDOM NUMBER SEED
ARRUNF: DW	TXTEND-1; POINTER TO UNFILLED ARRAY SPACE
TXTUNF:	DW	TXTBGN	; ->UNFILLED TEXT AREA
;
TXTBGN:	DS	1	; TEXT SAVE AREA BEGINS 
;
;	TEXT AREA HERE ~ 7.5K
;	AND GOES UP IN MEMORY
;	
;
;	A-Z ARRAY MEMORY STARTS BELOW VARIABLES
;	AND GOES DOWN IN MEMORY IN THE ORDER OF THE "DIM"
;	STATEMENTS
;
;	@ ARRAY MEMORY STARTS FROM VARBGN GOES DOWN IN MEMORY
;	AND THEREFORE OVERLAPS THE OTHER ARRAY MEMORY
;
; NOTE: PATB USER VARIABLES MUST START ON A PAGE BOUNDARY
;
	ORG	3E00H
TXTEND:	EQU	$	; TEXT SAVE AREA ENDS 
VARBGN: DS	2*27	; USER VARIABLES @(0), A-Z
	DS	2	; EXTRA BYTES FOR LINE NUMBER
BUFFER: DS	80	; INPUT BUFFER
BUFEND: EQU	$	; BUFFER ENDS
	DS	10	; PADDING BETWEEN BUFFER AND STACK
STKLMT:	EQU	$	; TOP LIMIT FOR STACK
;
	ORG	3F00H
;
; 8085 MONITOR SINGLE STEP VARIABLES AND TEMPORARY STACK
;
; NOTE: WHEN PATB IS RUNNING, THESE VARIABLES ARE PART OF 
; 	THE TINY BASIC STACK
;
MSTC2:	DS	2	; ADDRESS AND STACK SAVE LOCATION
MSTCK:	EQU	$
FSAVE:	DS	1	; FLAG SAVE LOCATION
ASAVE:	DS	1	; A REGISTER SAVE LOCATION
CSAVE:	DS	1	; C REGISTER SAVE LOCATION
BSAVE:	DS	1	; B REGISTER SAVE LOCATION
ESAVE:	DS	1	; E REGISTER SAVE LOCATION
DSAVE:	DS	1	; D REGISTER SAVE LOCATION
LSAVE:	DS	1	; L REGISTER SAVE LOCATION
HSAVE:	DS	1	; H REGISTER SAVE LOCATION
SSAVE:	DS	2	; STACK POINTER SAVE LOCATION
PSAVE:	DS	2	; PROGRAM COUNTER SAVE LOCATION
EXOP:	DS	1	; TEMPORARY OP CODES FOR SINGLE STEP
EXOP1:	DS	1
EXOP2:	DS	1
EXOP3:	DS	1
EXOP4:	DS	2
;
; STACK RESIDES HERE
; AND GOES DOWN IN MEMORY
;
	ORG	3FA0H	; STACK START + 1
STACK:	EQU	$	
;
; TEMPORARY VARIABLES FOR PATB SUBROUTINES
;
; EDITOR VARIABLES
;
VARTMP:	DW	0	; TEMPORARY VARIABLE
MOVCNT:	DW	0	; MOVE COUNT
LINEND:	DW	0	; LINE END
CURLIN: DW	0	; CURRENT LINE BEING EDITED
;
; XMODEM VARIABLES
;
TIMOUT:	DW	0	; TIME OUT VALUE
PKTADD:	DW	0	; PACKET ADDRESS
ENDADD:	DW	0	; END ADDRESS (SEND)
RETRY:	DB	0	; RETRY COUNT
TIMCNT:	DB	0	; TIME OUT COUNT
;
; ARRAY VARIABLE
;
VADDR:	DW	0	; VARIABLE ADDRESS
;
; RANDOMIZE VARIABLE
;
RANDOM:	DW	0	; COUNTER UPDATED BY SERIAL POLL
;
	END
	